<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="kernel基础知识, StarrySky">
    <meta name="description" content="Love rises from the east and descends to the west,romance makes no changes until death.">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>kernel基础知识 | StarrySky</title>
    <link rel="icon" type="image/jpeg" href="/favicon.jpg">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="StarrySky" type="application/atom+xml">
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">StarrySky</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>主页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>文章</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>个人简介</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友链</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">StarrySky</div>
        <div class="logo-desc">
            
            Love rises from the east and descends to the west,romance makes no changes until death.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			主页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			文章
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			个人简介
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友链
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/Steel%20Gray.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">kernel基础知识</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/kernel/">
                                <span class="chip bg-color">kernel</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/kernel/" class="post-category">
                                kernel
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-03-12
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    7.1k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    29 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="内核基础知识"><a href="#内核基础知识" class="headerlink" title="内核基础知识"></a>内核基础知识</h2><h3 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h3><p>用于管理软件发出的数据<code>I/O</code>要求的程序，将要求转义为指令交给<code>CPU</code>和其他组件处理，包括<code> I/O</code>，权限控制，系统调用，进程管理，内存管理等，<strong>kernel 的 crash 通常会引起重启</strong></p>
<ul>
<li>控制并与硬件进行交互</li>
<li>提供应用能运行的环境</li>
</ul>
<h3 id="Ring-Model"><a href="#Ring-Model" class="headerlink" title="Ring Model"></a>Ring Model</h3><p><code>cpu</code>分为<code>ring 0-3</code>四个特权级别，<code>ring0</code>仅<code>os</code>使用，<code>ring3</code>所以程序可用，大多操作系统仅<code>ring0</code>和<code>ring3</code></p>
<h3 id="Loadable-Kernel-Modules-LKMs"><a href="#Loadable-Kernel-Modules-LKMs" class="headerlink" title="Loadable Kernel Modules(LKMs)"></a>Loadable Kernel Modules(LKMs)</h3><p>可加载核心模块 (或直接称为内核模块) ,是内核空间的可执行程序，包括<strong>驱动程序（设备驱动、文件系统驱动）和内核扩展模块</strong>,和用户态的可执行程序相同，<code>Linux</code> 下为 <code>ELF</code>，<code>Windows</code> 下为 <code>exe/dll</code>，<code>mac</code> 下为 <code>MACH-O</code></p>
<p><strong>模块</strong>可以被单独编译，但不能单独运行，运行时<strong>被链接到内核</strong>作为内核的一部分在内核空间运行，这与运行在用户控件的进程不同</p>
<blockquote>
<p><code>Linux</code> 内核之所以提供模块机制，是因为它本身是一个单内核 (<code>monolithic kernel</code>)。单内核的优点是效率高，因为所有的内容都集合在一起，但缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。</p>
</blockquote>
<h4 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h4><ul>
<li><strong>insmod</strong>: 将指定<strong>模块加载到内核</strong>中</li>
<li><strong>rmmod</strong>: 从内核中<strong>卸载指定模块</strong></li>
<li><strong>lsmod</strong>: <strong>列出</strong>已经加载的模块</li>
<li><strong>modprobe</strong>: <strong>添加或删除</strong>模块，加载模块时会查找依赖关系</li>
</ul>
<blockquote>
<p>大多数　<code>CTF</code> 中的 <code>kernel vulnerability</code> 也出现在 <code>LKM</code> 中。</p>
</blockquote>
<h3 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h3><p>系统调用，指的是用户空间的程序向操作系统内核请求需要更高权限的服务，系统调用提供用户程序与操作系统间的接口，部分库函数实际上是对系统调用的封装</p>
<h3 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">NAME
       ioctl <span class="token operator">-</span> control device

SYNOPSIS
       <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/ioctl.h></span></span>

       <span class="token keyword">int</span> <span class="token function">ioctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> request<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>ioctl</code>也是一个系统调用，用于与设备通信</p>
<p><code>int ioctl(int fd, unsigned long request, ...)</code> 的第一个参数为打开设备 (<code>open</code>) 返回的文件描述符，第二个参数为用户程序对设备的<strong>控制命令</strong>，再后边的参数则是一些补充参数，与设备有关</p>
<blockquote>
<p>内核被设计成可扩展的，可以加入一个称为设备驱动的模块，驱动的代码允许在内核空间运行而且可以对设备直接寻址。对设备驱动的请求是一个以设备和请求号码为参数的 <code>ioctl</code> 调用，如此内核就允许用户空间访问设备驱动进而访问设备而不需要了解具体的设备细节，同时也不需要一大堆针对不同设备的系统调用</p>
</blockquote>
<h3 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h3><h4 id="user-space-to-kernel-space"><a href="#user-space-to-kernel-space" class="headerlink" title="user space to kernel space"></a>user space to kernel space</h4><p>当发生  <strong>系统调用</strong>， <strong>产生异常</strong> ， <strong>外设产生中断</strong> 等事件时，会发生用户态到内核态的切换，具体的过程为：</p>
<ol>
<li><p>通过 <code>swapgs</code> <strong>切换</strong> <code>gs</code> 段寄存器，将 <code>gs</code> 寄存器值和一个特定位置的值进行<strong>交换</strong>，目的是<strong>保存</strong> <code>gs</code> 值，同时将该位置的值作为内核执行时的 <code>gs</code> 值使用</p>
</li>
<li><p>将当前栈顶（<strong>用户空间栈顶</strong>）<strong>记录</strong>在 CPU 独占变量区域里，将 CPU 独占区域里记录的<strong>内核栈顶</strong>放入 <code>rsp/esp</code></p>
</li>
<li><p>通过 <code>push</code> 保存各寄存器值，具体的代码 如下:</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"> ENTRY(entry_SYSCALL_64)
 &#x2F;* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 *&#x2F;
 SWAPGS_UNSAFE_STACK

 &#x2F;* 保存栈值，并设置内核栈 *&#x2F;
 movq %rsp, PER_CPU_VAR(rsp_scratch)
 movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp


&#x2F;* 通过push保存寄存器值，形成一个pt_regs结构 *&#x2F;
&#x2F;* Construct struct pt_regs on stack *&#x2F;
pushq  $__USER_DS      &#x2F;* pt_regs-&gt;ss *&#x2F;
pushq  PER_CPU_VAR(rsp_scratch)  &#x2F;* pt_regs-&gt;sp *&#x2F;
pushq  %r11             &#x2F;* pt_regs-&gt;flags *&#x2F;
pushq  $__USER_CS      &#x2F;* pt_regs-&gt;cs *&#x2F;
pushq  %rcx             &#x2F;* pt_regs-&gt;ip *&#x2F;
pushq  %rax             &#x2F;* pt_regs-&gt;orig_ax *&#x2F;
pushq  %rdi             &#x2F;* pt_regs-&gt;di *&#x2F;
pushq  %rsi             &#x2F;* pt_regs-&gt;si *&#x2F;
pushq  %rdx             &#x2F;* pt_regs-&gt;dx *&#x2F;
pushq  %rcx tuichu    &#x2F;* pt_regs-&gt;cx *&#x2F;
pushq  $-ENOSYS        &#x2F;* pt_regs-&gt;ax *&#x2F;
pushq  %r8              &#x2F;* pt_regs-&gt;r8 *&#x2F;
pushq  %r9              &#x2F;* pt_regs-&gt;r9 *&#x2F;
pushq  %r10             &#x2F;* pt_regs-&gt;r10 *&#x2F;
pushq  %r11             &#x2F;* pt_regs-&gt;r11 *&#x2F;
sub $(6*8), %rsp      &#x2F;* pt_regs-&gt;bp, bx, r12-15 not saved *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>通过汇编指令判断是否为 <code>x32_abi</code></p>
</li>
<li><p>通过系统调用号，跳到全局变量 <code>sys_call_table</code> 相应位置继续执行系统调用</p>
</li>
</ol>
<h4 id="kernel-space-to-user-space"><a href="#kernel-space-to-user-space" class="headerlink" title="kernel space to user space"></a>kernel space to user space</h4><p>退出时，流程如下：</p>
<ol>
<li>通过 <code>swapgs</code> 恢复 <code>gs</code> 值</li>
<li>通过 <code>sysretq</code> 或者 <code>iretq</code> 恢复到用户控件继续执行。如果使用 <code>iretq</code> 还需要给出用户空间的一些信息（<code>CS</code>, <code>eflags/rflags</code>, <code>esp/rsp</code> 等）</li>
</ol>
<h3 id="struct-cred"><a href="#struct-cred" class="headerlink" title="struct cred"></a>struct cred</h3><p><code>kernel</code> 用 <code>cred</code> 结构体记录了进程的权限等信息（<code>uid</code>，<code>gid</code> 等），每个进程中都有一个 <code>cred</code> 结构，如果能修改某个进程的 <code>cred</code>，那么也就修改了这个进程的权限</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">cred</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">atomic_t</span>    usage<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_DEBUG_CREDENTIALS</span></span>
    <span class="token class-name">atomic_t</span>    subscribers<span class="token punctuation">;</span>    <span class="token comment">/* number of processes subscribed */</span>
    <span class="token keyword">void</span>        <span class="token operator">*</span>put_addr<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span>    magic<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CRED_MAGIC</span>  <span class="token expression"><span class="token number">0x43736564</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CRED_MAGIC_DEAD</span> <span class="token expression"><span class="token number">0x44656144</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token class-name">kuid_t</span>      uid<span class="token punctuation">;</span>        <span class="token comment">/* real UID of the task */</span>
    <span class="token class-name">kgid_t</span>      gid<span class="token punctuation">;</span>        <span class="token comment">/* real GID of the task */</span>
    <span class="token class-name">kuid_t</span>      suid<span class="token punctuation">;</span>       <span class="token comment">/* saved UID of the task */</span>
    <span class="token class-name">kgid_t</span>      sgid<span class="token punctuation">;</span>       <span class="token comment">/* saved GID of the task */</span>
    <span class="token class-name">kuid_t</span>      euid<span class="token punctuation">;</span>       <span class="token comment">/* effective UID of the task */</span>
    <span class="token class-name">kgid_t</span>      egid<span class="token punctuation">;</span>       <span class="token comment">/* effective GID of the task */</span>
    <span class="token class-name">kuid_t</span>      fsuid<span class="token punctuation">;</span>      <span class="token comment">/* UID for VFS ops */</span>
    <span class="token class-name">kgid_t</span>      fsgid<span class="token punctuation">;</span>      <span class="token comment">/* GID for VFS ops */</span>
    <span class="token keyword">unsigned</span>    securebits<span class="token punctuation">;</span> <span class="token comment">/* SUID-less security management */</span>
    <span class="token class-name">kernel_cap_t</span>    cap_inheritable<span class="token punctuation">;</span> <span class="token comment">/* caps our children can inherit */</span>
    <span class="token class-name">kernel_cap_t</span>    cap_permitted<span class="token punctuation">;</span>  <span class="token comment">/* caps we're permitted */</span>
    <span class="token class-name">kernel_cap_t</span>    cap_effective<span class="token punctuation">;</span>  <span class="token comment">/* caps we can actually use */</span>
    <span class="token class-name">kernel_cap_t</span>    cap_bset<span class="token punctuation">;</span>   <span class="token comment">/* capability bounding set */</span>
    <span class="token class-name">kernel_cap_t</span>    cap_ambient<span class="token punctuation">;</span>    <span class="token comment">/* Ambient capability set */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_KEYS</span></span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span>   jit_keyring<span class="token punctuation">;</span>    <span class="token comment">/* default keyring to attach requested
                     * keys to */</span>
    <span class="token keyword">struct</span> <span class="token class-name">key</span> __rcu <span class="token operator">*</span>session_keyring<span class="token punctuation">;</span> <span class="token comment">/* keyring inherited over fork */</span>
    <span class="token keyword">struct</span> <span class="token class-name">key</span>  <span class="token operator">*</span>process_keyring<span class="token punctuation">;</span> <span class="token comment">/* keyring private to this process */</span>
    <span class="token keyword">struct</span> <span class="token class-name">key</span>  <span class="token operator">*</span>thread_keyring<span class="token punctuation">;</span> <span class="token comment">/* keyring private to this thread */</span>
    <span class="token keyword">struct</span> <span class="token class-name">key</span>  <span class="token operator">*</span>request_key_auth<span class="token punctuation">;</span> <span class="token comment">/* assumed request_key authority */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_SECURITY</span></span>
    <span class="token keyword">void</span>        <span class="token operator">*</span>security<span class="token punctuation">;</span>  <span class="token comment">/* subjective LSM security */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token keyword">struct</span> <span class="token class-name">user_struct</span> <span class="token operator">*</span>user<span class="token punctuation">;</span>   <span class="token comment">/* real user ID subscription */</span>
    <span class="token keyword">struct</span> <span class="token class-name">user_namespace</span> <span class="token operator">*</span>user_ns<span class="token punctuation">;</span> <span class="token comment">/* user_ns the caps and keyrings are relative to. */</span>
    <span class="token keyword">struct</span> <span class="token class-name">group_info</span> <span class="token operator">*</span>group_info<span class="token punctuation">;</span>  <span class="token comment">/* supplementary groups for euid/fsgid */</span>
    <span class="token keyword">struct</span> <span class="token class-name">rcu_head</span> rcu<span class="token punctuation">;</span>        <span class="token comment">/* RCU deletion hook */</span>
<span class="token punctuation">&#125;</span> __randomize_layout<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="内核态函数"><a href="#内核态函数" class="headerlink" title="内核态函数"></a>内核态函数</h3><p>相比用户态库函数，内核态的函数有了一些变化</p>
<ul>
<li><code>printf() -&gt; printk()</code>，但需要注意的是 <code>printk()</code> 不一定会把内容显示到终端上，但<strong>一定在内核缓冲区</strong>里，可以通过 <code>dmesg</code> 查看效果</li>
<li><code>memcpy() -&gt; copy_from_user()/copy_to_user()</code><ul>
<li><code>copy_from_user()</code> 将<strong>用户</strong>空间的数据传送到<strong>内核</strong>空间</li>
<li><code>copy_to_user() </code>     将<strong>内核</strong>空间的数据传送到<strong>用户</strong>空间</li>
</ul>
</li>
<li><code>malloc() -&gt; kmalloc()</code>，内核态的内存分配函数，和<code>malloc()</code>相似，但使用的是 <code>slab/slub 分配器</code></li>
<li><code>free() -&gt; kfree()</code>，同 <code>kmalloc()</code></li>
</ul>
<p>另外要注意的是，<code>kernel 管理进程,也记录了进程的权限</code>,<code>kernel </code>中改变权限的函数：</p>
<ul>
<li><strong>int commit_creds(struct cred *new)</strong></li>
<li><strong>struct cred* prepare_kernel_cred(struct task_struct* daemon)</strong></li>
</ul>
<p><em><u>从函数名也可以看出，执行 <code>commit_creds(prepare_kernel_cred(0))</code> 即可获得 <code>root</code> 权限，<code>0</code> 表示 以 <code>0</code> 号进程作为参考准备新的 <code>credentials</code></u></em></p>
<p>执行 <code>commit_creds(prepare_kernel_cred(0))</code> 也是最常用的提权手段，两个函数的地址都可以在 <code>/proc/kallsyms</code> 中查看（较老的内核版本中是 <code>/proc/ksyms</code>）。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">grep</span> commit_creds /proc/kallsyms 
ffffffffbb6af9e0 T commit_creds
ffffffffbc7cb3d0 r __ksymtab_commit_creds
ffffffffbc7f06fe r __kstrtab_commit_creds
$ <span class="token function">sudo</span> <span class="token function">grep</span> prepare_kernel_cred /proc/kallsyms
ffffffffbb6afd90 T prepare_kernel_cred
ffffffffbc7d4f20 r __ksymtab_prepare_kernel_cred
ffffffffbc7f06b7 r __kstrtab_prepare_kernel_cred<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>一般情况下，<code>/proc/kallsyms</code> 的内容需要 <code>root</code> 权限才能查看</p>
</blockquote>
<h3 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h3><blockquote>
<p><code>canary</code>, <code>dep</code>, <code>PIE</code>, <code>RELRO</code> 等保护与用户态原理和作用相同</p>
</blockquote>
<ul>
<li><code>smep</code>: <code>Supervisor Mode Execution Protection</code>，当处理器处于 <code>ring0</code> 模式，<strong>执行</strong>用户空间的代码会触发页错误。（在 <code>arm</code> 中该保护称为 <code>PXN</code>）</li>
<li><code>smap</code>: <code>Superivisor Mode Access Protection</code>，类似于 <code>smep</code>，通常是在<strong>访问数据</strong>时</li>
<li><code>mmap_min_addr</code></li>
</ul>
<h3 id="CTF-kernel-pwn-相关"><a href="#CTF-kernel-pwn-相关" class="headerlink" title="CTF kernel pwn 相关"></a>CTF kernel pwn 相关</h3><h4 id="题目文件"><a href="#题目文件" class="headerlink" title="题目文件"></a>题目文件</h4><ol>
<li><p><code>boot.sh</code>: 一个用于启动 <code>kernel</code> 的 <code>shell</code> 的脚本，多用 <code>qemu</code>，保护措施与 <code>qemu</code> 不同的启动参数有关</p>
</li>
<li><p><code>bzImage</code>: <code>kernel binary</code></p>
</li>
<li><p><code>rootfs.cpio</code>: 文件系统映像</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$x</span> babydriver.tar
boot.sh
bzImage
rootfs.cpio
<span class="token variable">$file</span> bzImage
bzImage: Linux kernel x86 boot executable bzImage, version <span class="token number">4.4</span>.72 <span class="token punctuation">(</span>atum@ubuntu<span class="token punctuation">)</span> <span class="token comment">#1 SMP Thu Jun 15 19:52:50 PDT 2017, RO-rootFS, swap_dev 0x6, Normal VGA</span>
<span class="token variable">$file</span> rootfs.cpio
rootfs.cpio: <span class="token function">gzip</span> compressed data, last modified: Tue Jul  <span class="token number">4</span> 08:39:15 <span class="token number">2017</span>, max compression, from Unix, original size <span class="token number">2844672</span>
<span class="token variable">$file</span> boot.sh
boot.sh: Bourne-Again shell script, ASCII text executable
<span class="token variable">$bat</span> boot.sh 
───────┬────────────────────────────────────────────────────────────
       │ File: boot.sh
───────┼───────────────────────────────────────────────────────────
         <span class="token comment">#!/bin/bash</span>
         qemu-system-x86_64 <span class="token punctuation">\</span>
         <span class="token parameter variable">-initrd</span> rootfs.cpio <span class="token punctuation">\</span>
         <span class="token parameter variable">-kernel</span> bzImage <span class="token punctuation">\</span>
         <span class="token parameter variable">-append</span> <span class="token string">'console=ttyS0 root=/dev/ram oops=panic panic=1'</span> <span class="token punctuation">\</span>
         -enable-kvm <span class="token parameter variable">-monitor</span> /dev/null <span class="token punctuation">\</span>
         <span class="token parameter variable">-m</span> 64M <span class="token punctuation">\</span>
         <span class="token parameter variable">--nographic</span>  <span class="token punctuation">\</span>
         <span class="token parameter variable">-smp</span> <span class="token assign-left variable">cores</span><span class="token operator">=</span><span class="token number">1</span>,threads<span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">\</span>
         <span class="token parameter variable">-cpu</span> kvm64,+smep<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>-initrd rootfs.cpio</code>，使用<code>rootfs.cpio</code>作为内核启动的文件系统</li>
<li><code>-kernel bzImage</code>，使用 <code>bzImage</code> 作为 <code>kernel</code> 映像</li>
<li><code>-cpu kvm64,+smep</code>，设置 <code>CPU</code> 的安全选项，这里开启了 <code>smep</code></li>
<li><code>-m 64M</code>，设置虚拟 <code>RAM</code> 为 <code>64M</code>，默认为 <code>128M</code></li>
</ul>
<h4 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h4><p><code>KASLR</code>：内核地址随机化，相当于<code>ASLR</code>(并非默认启用，需要在内核命令行中加入<code>kaslr</code>开启)</p>
<p><code>SMEP/SMAP</code>：[<code>SMEP</code>管理模式<strong>执行</strong>保护，禁止<strong>内核访问用户</strong>空间的数据]，[<code>SMAP</code>管理模式<strong>访问</strong>保护，类似于<code>NX</code>，即<strong>内核态无法执行<code>shellcode</code></strong>]</p>
<p><code>Stack Protector</code>：(<code>canary</code>)在编译内核时设置<code>CONFIG_CC_STACKPROTECTOR</code>，开了这个保护再编译驱动会有<code>canary</code></p>
<p><code>KPTI</code>：<code>KPTI</code>即内核页表隔离(<code>Kernel page-table isolation</code>)，内核空间与用户空间分别使用两组不同的页表集，这对于内核的<strong>内存管理</strong>产生了根本性的变化</p>
<h4 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h4><ol>
<li>解包<code>rootfs</code>,检查保护</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mkdir</span> File_system
$ <span class="token function">mv</span> rootfs.cpio ./File_system/rootfs.cpio.gz
$ <span class="token builtin class-name">cd</span> File_system
$ gunzip rootfs.cpio.gz
$ cpio <span class="token parameter variable">-idmv</span> <span class="token operator">&lt;</span> rootfs.cpio

$ <span class="token function">file</span> babydriver.ko 
$ checksec <span class="token parameter variable">--file</span><span class="token operator">=</span>babydriver.ko<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>2.拖进<code>IDA</code>在内核代码中找到漏洞</p>
<p>3.利用<code>Shellcode</code>, <code>ROP</code>, 等攻击方式实现代码执行</p>
<p>4.提权</p>
<p>5.本地写好 <code>exploit</code> 后，可以通过 <code>base64</code> 编码等方式把编译好的二进制文件保存到远程目录下，进而拿到<code> flag</code>，同时可以使用 <code>musl</code>, <code>uclibc</code> 等方法减小 <code>exploit</code> 的体积方便传输</p>
<p>测试<code>exp</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cp</span> ./exp ./fs <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> fs
$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token operator">|</span> cpio <span class="token parameter variable">-o</span> <span class="token parameter variable">--format</span><span class="token operator">=</span>newc <span class="token operator">></span> <span class="token punctuation">..</span>/rootfs.cpio <span class="token comment"># 重新打包文件系统</span>
$ ./boot.sh <span class="token comment"># 启动&amp;测试exp</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>即获取到 <code>root</code> 权限</p>
<h4 id="改变自身"><a href="#改变自身" class="headerlink" title="改变自身"></a>改变自身</h4><p>通过改变自身进程的权限，使其具有 root 权限,内核会通过进程的 <code>task_struct</code> 结构体中的 <code>cred</code> 指针来索引 <code>cred</code> 结构体，<code>cred</code>结构体成员中的 <code>uid-fsgid</code> 都为 <code>0</code>则具有 <code>root </code>权限,这种提权方法分为定位和修改两个步骤，<code>cred</code>结构体在<code>include/linux/cred.h</code></p>
<h5 id="直接改cred结构体的内容"><a href="#直接改cred结构体的内容" class="headerlink" title="直接改cred结构体的内容"></a>直接改cred结构体的内容</h5><h6 id="定位cred具体位置"><a href="#定位cred具体位置" class="headerlink" title="定位cred具体位置"></a>定位cred具体位置</h6><ul>
<li><p>直接定位</p>
<p><code>cred</code> 结构体的最前面记录了各种<code> id</code> 信息，对于一个普通的进程而言，<code>uid-fsgid</code> 都是执行进程的用户的身份,因此可以通过<strong>扫描内存</strong>来定位 <code>cred</code></p>
<p><strong>在实际定位的过程中，我们可能会发现很多满足要求的 cred，这主要是因为 cred 结构体可能会被拷贝、释放。</strong>可以利用 <code>usage</code> 不为 <code>0</code> 来筛除掉一些 <code>cred</code>，但仍然会发现一些 <code>usage</code> 为 <code>0</code> 的 <code>cred</code>,这是因为 <code>cred</code> 从 <code>usage</code> 为 <code>0</code>， 到释放有一定的时间,此外，<code>cred</code> 是使用 <code>rcu</code> <strong>延迟释放</strong>的</p>
</li>
<li><p>间接定位</p>
<ul>
<li><p><code> task_struct</code></p>
<p>进程的 <code>task_struct</code> 结构体中会存放指向 <code>cred</code> 的指针，因此我们可以</p>
<ol>
<li>定位当前进程 <code>task_struct</code> 结构体的地址</li>
<li>根据<code> cred</code> 指针相对于 <code>task_struct</code> 结构体的偏移计算得出 <code>cred</code> 指针存储的地址</li>
<li>获取 <code>cred</code> 具体的地址</li>
</ol>
</li>
<li><p><code>comm</code></p>
<p><code>comm </code>用来标记可执行<strong>文件的名字</strong>，位于进程的 <code>task_struct</code> 结构体中, <code>comm</code> 在 <code>cred</code> 的正下方，所以可以先定位 <code>comm </code>，然后定位 <code>cred</code> 的地址</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cred</span> __rcu     <span class="token operator">*</span>ptracer_cred<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cred</span> __rcu     <span class="token operator">*</span>real_cred<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cred</span> __rcu     <span class="token operator">*</span>cred<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_KEYS</span></span>
    <span class="token keyword">struct</span> <span class="token class-name">key</span>          <span class="token operator">*</span>cached_requested_key<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token keyword">char</span>                comm<span class="token punctuation">[</span>TASK_COMM_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>进程名字并不特殊的情况下可能会有多个同样的字符串，,可以使用 <code>prctl</code> 设置进程的<code>comm</code>为一个特殊的字符串，然后再开始定位 <code>comm</code></p>
</li>
</ul>
</li>
<li><p>修改</p>
<p>直接将 <code>cred</code> 中的 <code>uid-fsgid</code> 都修改为 <code>0</code>,当然修改的方式有很多种</p>
<ul>
<li><p>在我们具有任意地址读写后，可以直接修改 <code>cred</code></p>
</li>
<li><p>在我们可以 <code>ROP</code> 执行代码后，可以利用 <code>ROP gadget</code> 修改 <code>cred</code></p>
</li>
</ul>
</li>
</ul>
<h6 id="间接定位"><a href="#间接定位" class="headerlink" title="间接定位"></a>间接定位</h6><p>不一定非得知道 <code>cred</code> 的具体位置，只需要能够修改 <code>cred</code> 即可</p>
<p><strong>UAF 使用同样堆块-过时</strong></p>
<p>如果我们在进程初始化时能控制 <code>cred</code> 结构体的位置，并且我们可以在初始化后修改该部分的内容，那么我们就可以很容易地达到提权的目的,且不需要任何信息泄露，例子:</p>
<ol>
<li>申请一块与 <code>cred</code> 结构体大小一样的堆块</li>
<li>释放该堆块</li>
<li><code>fork</code> 出新进程，恰好使用刚刚释放的堆块</li>
<li>修改 <code>cred</code> 结构体特定内存，从而提权</li>
</ol>
<p><strong>此种方法在较新版本内核中已不再可行，我们已无法直接分配到 cred_jar 中的 object</strong>，这是因为 <code>cred_jar</code> 在创建时设置了 <code>SLAB_ACCOUNT</code> 标记，在 <code>CONFIG_MEMCG_KMEM=y</code> 时（默认开启）<strong>cred_jar 不会再与相同大小的 kmalloc-192 进行合并</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> __init <span class="token function">cred_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">/* allocate a slab in which we can store credentials */</span>
    cred_jar <span class="token operator">=</span> <span class="token function">kmem_cache_create</span><span class="token punctuation">(</span><span class="token string">"cred_jar"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cred</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>
            SLAB_HWCACHE_ALIGN<span class="token operator">|</span>SLAB_PANIC<span class="token operator">|</span>SLAB_ACCOUNT<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="修改-task-struct-结构体中的-cred-指针"><a href="#修改-task-struct-结构体中的-cred-指针" class="headerlink" title="修改 task_struct 结构体中的 cred 指针"></a>修改 task_struct 结构体中的 cred 指针</h5><h6 id="定位cred结构体指针具体位置"><a href="#定位cred结构体指针具体位置" class="headerlink" title="定位cred结构体指针具体位置"></a>定位cred结构体指针具体位置</h6><ul>
<li><p>间接定位</p>
<ul>
<li><p><code>task_struct</code></p>
<p><code>task_struct</code> 结构体中会存放指向 <code>cred</code> 的指针，可以定位<code>task_struct</code> 结构体的地址,再根据 <code>cred</code> 指针的偏移计算得出 <code>cred</code> 指针地址</p>
</li>
<li><p><code>comm</code></p>
<p>在<code>cred</code>指针正下方，可以使用 <code>prctl</code> 设置进程的 <code>comm</code> 为一个特殊的字符串，然后再定位 <code>comm</code></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cred</span> __rcu     <span class="token operator">*</span>ptracer_cred<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cred</span> __rcu     <span class="token operator">*</span>real_cred<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cred</span> __rcu     <span class="token operator">*</span>cred<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_KEYS</span></span>
    <span class="token keyword">struct</span> <span class="token class-name">key</span>          <span class="token operator">*</span>cached_requested_key<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token keyword">char</span>                comm<span class="token punctuation">[</span>TASK_COMM_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>修改</p>
<ul>
<li>修改 <code>cred</code> 指针为内核镜像中<strong>已有的</strong><code> init_cred</code> 的地址。这种方法适合于我们<strong>能够直接修改 cred 指针以及知道 init_cred 地址</strong>的情况</li>
<li>伪造一个 <code>cred</code>，然后修改 <code>cred</code> 指针指向该地址即可。比较麻烦，一般不使用</li>
</ul>
</li>
</ul>
<h6 id="间接定位-1"><a href="#间接定位-1" class="headerlink" title="间接定位"></a>间接定位</h6><ul>
<li><p><code>commit_creds(&amp;init_cred)</code></p>
<p><code>commit_creds()</code> :将一个新的 <code>cred</code> 设为当前进程 <code>task_struct</code> 的 <code>real_cred</code> 与 <code>cred</code> 字段，调用该函数并传入一个具有 <code>root</code> 权限的 <code>cred</code>，则能直接完成对当前进程的提权工作</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">commit_creds</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cred</span> <span class="token operator">*</span>new<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task <span class="token operator">=</span> current<span class="token punctuation">;</span><span class="token comment">//内核宏，用以从 percpu 段获取当前进程的 PCB</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cred</span> <span class="token operator">*</span>old <span class="token operator">=</span> task<span class="token operator">-></span>real_cred<span class="token punctuation">;</span>

    <span class="token comment">//...</span>
    <span class="token function">rcu_assign_pointer</span><span class="token punctuation">(</span>task<span class="token operator">-></span>real_cred<span class="token punctuation">,</span> new<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">rcu_assign_pointer</span><span class="token punctuation">(</span>task<span class="token operator">-></span>cred<span class="token punctuation">,</span> new<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在内核初始化过程当中会以 <code>root</code> 权限启动 <code>init</code> 进程，其 <code>cred</code> 结构体为<strong>静态定义</strong>的 <code>init_cred</code>，可以通过 <code>commit_creds(&amp;init_cred)</code> 来完成提权的工作</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">cred</span> init_cred <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span>usage          <span class="token operator">=</span> <span class="token function">ATOMIC_INIT</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_DEBUG_CREDENTIALS</span></span>
    <span class="token punctuation">.</span>subscribers        <span class="token operator">=</span> <span class="token function">ATOMIC_INIT</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>magic          <span class="token operator">=</span> CRED_MAGIC<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token punctuation">.</span>uid            <span class="token operator">=</span> GLOBAL_ROOT_UID<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>gid            <span class="token operator">=</span> GLOBAL_ROOT_GID<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>suid           <span class="token operator">=</span> GLOBAL_ROOT_UID<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>sgid           <span class="token operator">=</span> GLOBAL_ROOT_GID<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>euid           <span class="token operator">=</span> GLOBAL_ROOT_UID<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>egid           <span class="token operator">=</span> GLOBAL_ROOT_GID<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>fsuid          <span class="token operator">=</span> GLOBAL_ROOT_UID<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>fsgid          <span class="token operator">=</span> GLOBAL_ROOT_GID<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>securebits     <span class="token operator">=</span> SECUREBITS_DEFAULT<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>cap_inheritable    <span class="token operator">=</span> CAP_EMPTY_SET<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>cap_permitted      <span class="token operator">=</span> CAP_FULL_SET<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>cap_effective      <span class="token operator">=</span> CAP_FULL_SET<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>cap_bset       <span class="token operator">=</span> CAP_FULL_SET<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>user           <span class="token operator">=</span> INIT_USER<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>user_ns        <span class="token operator">=</span> <span class="token operator">&amp;</span>init_user_ns<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>group_info     <span class="token operator">=</span> <span class="token operator">&amp;</span>init_groups<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ucounts        <span class="token operator">=</span> <span class="token operator">&amp;</span>init_ucounts<span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>commit_creds(prepare_kernel_cred(0))</code>-<code>6.2</code>之后失效</p>
<p><code>prepare_kernel_cred()</code> 函数用以拷贝指定进程的 <code>cred</code> 结构体，参数为 <code>NULL </code>时，该函数会拷贝 <code>init_cred</code> 并返回一个有着 <code>root</code> 权限的 <code>cred</code>：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">cred</span> <span class="token operator">*</span><span class="token function">prepare_kernel_cred</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>daemon<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cred</span> <span class="token operator">*</span>old<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">cred</span> <span class="token operator">*</span>new<span class="token punctuation">;</span>

    new <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>cred_jar<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>new<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    <span class="token function">kdebug</span><span class="token punctuation">(</span><span class="token string">"prepare_kernel_cred() alloc %p"</span><span class="token punctuation">,</span> new<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>daemon<span class="token punctuation">)</span>
        old <span class="token operator">=</span> <span class="token function">get_task_cred</span><span class="token punctuation">(</span>daemon<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        old <span class="token operator">=</span> <span class="token function">get_cred</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>init_cred<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>调用 <code>commit_creds(prepare_kernel_cred(NULL))</code>能直接完成提权的工作</p>
<p>不过自从内核版本 <code>6.2</code> 起，<code>prepare_kernel_cred(NULL)</code> 将<strong>不再拷贝 init_cred，而是将其视为一个运行时错误并返回 NULL</strong>，因此内核<code>6.2</code>之后失效</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">cred</span> <span class="token operator">*</span><span class="token function">prepare_kernel_cred</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>daemon<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cred</span> <span class="token operator">*</span>old<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">cred</span> <span class="token operator">*</span>new<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WARN_ON_ONCE</span><span class="token punctuation">(</span><span class="token operator">!</span>daemon<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    new <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>cred_jar<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>new<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h4 id="改变别人"><a href="#改变别人" class="headerlink" title="改变别人"></a>改变别人</h4><p>通过影响高权限进程的执行，使其完成我们想要的功能</p>
<h5 id="改数据"><a href="#改数据" class="headerlink" title="改数据"></a>改数据</h5><p><strong>符号链接</strong></p>
<p>如果一个 <code>root </code>权限的进程会执行一个<strong>符号链接</strong>的程序，并且该<strong>符号链接或者符号链接指向的程序</strong>可以由攻击者控制，攻击者就可以实现提权</p>
<ul>
<li><p><code>call_usermodehelper</code></p>
<p>一种内核线程执行用户态应用的方式，并且启动的进程具有<code>root</code>权限，通过改变某个变量指定的具体要执行的应用提权</p>
<ul>
<li><p>修改<code>modprobe_path</code></p>
<ul>
<li>获取<code>modprobe_path</code>地址<ul>
<li>直接定位：取值确定，<code>modprobe_path</code>扫描内存寻找字符串</li>
<li>间接定位：相对内核基址偏移固定，先获取内核基址再通过偏移得到地址</li>
</ul>
</li>
<li>修改<code>modprobe_path</code>为指定的程序</li>
<li>触发 <code>call_modprobe</code><ul>
<li>执行满足相应要求的非法可执行文件</li>
<li>使用未知协议触发</li>
</ul>
</li>
</ul>
<p>模板如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// step 1. modify modprobe_path to the target value</span>

<span class="token comment">// step 2. create related file</span>
<span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"echo -ne '#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag\ncat flag' > /home/pwn/catflag.sh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"chmod +x /home/pwn/catflag.sh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// step 3. trigger it using unknown executable</span>
<span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"echo -ne '\\xff\\xff\\xff\\xff' > /home/pwn/dummy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"chmod +x /home/pwn/dummy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"/home/pwn/dummy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// step 3. trigger it using unknown protocol</span>
<span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">,</span><span class="token number">132</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>修改 <code>poweroff_cmd</code></p>
</li>
</ul>
</li>
<li><p><code>poweroff_cmd</code></p>
<ul>
<li>获取<code>poweroff_cmd</code>地址，方法同上</li>
<li>修改 <code>poweroff_cmd</code> 为指定的程序</li>
<li>劫持控制流执行 <code>__orderly_poweroff</code></li>
</ul>
</li>
</ul>
<h5 id="改代码"><a href="#改代码" class="headerlink" title="改代码"></a>改代码</h5><p>修改<code>root</code>权限执行的代码，内核中 <code>vDSO</code> 的代码会被映射到所有的用户态进程中,高特权的进程周期性地调用 <code>vDSO</code> 中的函数时可以考虑把 <code>vDSO</code> 中相应的函数修改为特定的 <code>shellcode</code>,早期<code>vDSO</code> 是可写的，后来引入 <code>post-init read-only</code> 的数据，即将初始化后不再被写的数据标记为只读，来防御这样的利用</p>
<ul>
<li><p>定位 <code>vDSO</code></p>
<ul>
<li><p><code>IDA</code>在<code>vmlinux</code>里定位<code>vDSO</code></p>
<p>点击<code>init_vdso函数 -&gt; vdso_image_64 / vdso_image_x32 -&gt; raw_data</code></p>
<p>或直接使用<code>raw_data</code>来寻找<code>vDSO</code></p>
</li>
<li><p>内存中定位</p>
<p>直接定位：<code>vDSO</code>是一个<code>ELF</code>文件，有<code>ELF</code>文件头，<code>vDSO</code>特定位置存储导出函数的字符串，根据这两个特征扫描内存</p>
<p><code>vDSO</code>相对内核基址偏移固定，先获取内核基址再根据偏移得到地址</p>
</li>
</ul>
</li>
<li><p>修改 <code>vDSO</code> 的特定函数为指定的 <code>shellcode</code></p>
</li>
<li><p>等待触发执行 <code>shellcode</code></p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="改变自身-1"><a href="#改变自身-1" class="headerlink" title="改变自身"></a>改变自身</h5><ul>
<li>改<code>cred</code>结构体：扫描内存定位&#x2F;<code>task_struct</code>结构体存放<code>cred</code>结构体指针&#x2F;<code>comm</code>偏移定位<code>cred</code>结构体位置，通过任意地址写&#x2F;<code>rop</code>来改<code>cred</code>中的<code>uid-fsgid</code>为<code>0</code></li>
<li>改<code>cred</code>结构体指针：<code>task_struct</code>结构体存放<code>cred</code>结构体指针&#x2F;<code>comm</code>偏移定位<code>cred</code>结构体指针位置，能够直接修改 <code>cred</code> 指针以及知道有<code>root</code>权限的 <code>init_cred</code> 地址时，修改 <code>cred</code> 指针为内核镜像中已有的<code> init_cred</code> 的地址</li>
<li><code>UAF</code> 使用同样堆块控制<code>cred</code>结构体-过时</li>
<li><code>commit_creds(&amp;init_cred)</code>，传入有<code>root</code>权限的<code>init_cred</code>的地址</li>
<li><code>commit_creds(prepare_kernel_cred(0))</code>-<code>6.2</code>之后失效</li>
</ul>
<h5 id="改变别人-1"><a href="#改变别人-1" class="headerlink" title="改变别人"></a>改变别人</h5><ul>
<li>修改<code>modprobe_path</code>为指定程序之后触发 <code>call_modprobe</code></li>
<li>修改 <code>poweroff_cmd</code> 为指定的程序之后触发<code>__orderly_poweroff</code></li>
<li>写<code>vDSO</code>为<code>shellcode</code></li>
</ul>
<h3 id="泄露敏感信息"><a href="#泄露敏感信息" class="headerlink" title="泄露敏感信息"></a>泄露敏感信息</h3><p>需要我们具有读取内核数据的能力，具体想要泄漏什么数据与利用场景紧密相关</p>
<h3 id="DoS"><a href="#DoS" class="headerlink" title="DoS"></a>DoS</h3><p>即使得内核崩溃</p>
<ul>
<li>触发内核中的某个<strong>漏洞</strong>让内核崩溃</li>
<li>触发内核中的<strong>死锁</strong></li>
<li>触发<strong>大量的内核内存泄漏</strong>，即存在大量的内存被申请但是没有被释放</li>
</ul>
<h2 id="内核防御机制"><a href="#内核防御机制" class="headerlink" title="内核防御机制"></a>内核防御机制</h2><h3 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h3><h4 id="内核态和用户态的隔离"><a href="#内核态和用户态的隔离" class="headerlink" title="内核态和用户态的隔离"></a>内核态和用户态的隔离</h4><h5 id="默认"><a href="#默认" class="headerlink" title="默认"></a>默认</h5><p><strong>用户态</strong>不可直接<strong>访问</strong>内核态的<strong>数据</strong>、执行内核态的<strong>代码</strong></p>
<h5 id="SMEP"><a href="#SMEP" class="headerlink" title="SMEP"></a>SMEP</h5><p><strong>内核态</strong>不可<strong>执行</strong>用户态的代码&#x2F;用户代码不可执行，位于<code>cr4</code>的第<code>20</code>位，不开的话会导致攻击者控制了内核中的执行流，就可以执行处于用户态的代码，由于用户态的代码是攻击者可控的，所以更容易实施攻击</p>
<p><strong>开启</strong>：默认开启，<code>qemu</code>开启在启动时加<code>-append +smep</code></p>
<p><strong>关闭</strong>：<code>/etc/default/grub</code>中如下两行添加<code>nosmep</code>，运行<code>update-grub</code>并重启系统，<code>qemu</code>中加<code>-append nosmep</code></p>
<pre class="line-numbers language-none"><code class="language-none">GRUB_CMDLINE_LINUX_DEFAULT&#x3D;&quot;quiet&quot;  
GRUB_CMDLINE_LINUX&#x3D;&quot;initrd&#x3D;&#x2F;install&#x2F;initrd.gz&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>状态查看</strong>：存在<code>smep</code>字符即开启了<code>smep</code>保护</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> smep /proc/cpuinfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>攻击</strong>：内核中存在固定的修改<code>cr4</code>的代码，比如<code>refresh_pce</code>函数、<code>set_tsc_mode</code>函数，或者控制程序流后执行内核中的<code>gadget</code>修改，将<code>CR4</code>寄存器第<code>20</code>位置<code>0</code>后即关闭<code>smep</code>，一般将<code>CR4</code>设置位<code>0x6f0</code>，这样同时也关闭了<code>smap</code></p>
<h5 id="SMAP"><a href="#SMAP" class="headerlink" title="SMAP"></a>SMAP</h5><p><strong>内核态</strong>不可<strong>访问</strong>用户态的数据&#x2F;用户数据不可访问，位于<code>cr4</code>的第<code>21</code>位，不开<code>smap</code>可能导致攻击者可以通过栈迁移将栈迁移到用户态，然后进行 <code>ROP</code></p>
<p><strong>开启&#x2F;关闭&#x2F;状态查看</strong>：同上</p>
<p><strong>攻击</strong>：设置<code>rc4</code>同上，劫持程序流之后可以调用 <code>copy_from_user</code> 和 <code>copy_to_user</code> 来访问用户态的内存。这两个函数会临时清空禁止访问用户态内存的标志</p>
<h5 id="KPTI-Kernel-Page-Table-Isolation"><a href="#KPTI-Kernel-Page-Table-Isolation" class="headerlink" title="KPTI-Kernel Page Table Isolation"></a>KPTI-Kernel Page Table Isolation</h5><p><strong>用户态</strong>不可看到内核态的<strong>页表</strong>；<strong>内核态</strong>不可<strong>执行用户</strong>态的<strong>代码</strong>,进一步增强了用户态和内核态内存的隔离，在开启 <code>KPTI</code> 机制后，用户态进入内核态或内核态进入用户态时都会进行页表切换</p>
<ul>
<li>内核态页表：用户空间内存的页表（标记为不可执行，类似<code>smep</code>，未开启<code>smap</code>则仍然可以访问用户态空间内存，只是不能执行<code>shellcode</code>）+内核空间内存的页表</li>
<li>用户态的页表：用户空间内存的页表+必要的内核空间内存的页表（如用于处理系统调用、中断等信息的内存</li>
</ul>
<p><code>Linux 4.15</code> 中引入了 <code>KPTI </code>机制，并且该机制被反向移植到了 <code>Linux 4.14.11</code>，<code>4.9.75，4.4.110</code></p>
<p><strong>开启：</strong><code>-append kpti=1</code></p>
<p><strong>关闭</strong>：<code>-append nopti</code></p>
<p><strong>状态查看</strong>：<code>dmesg | grep &#39;page table&#39;</code></p>
<p><strong>攻击</strong>：<code>KPTI</code> 机制和 <code>SMAP 、SMEP</code> 不太一样，由于与源码紧密结合，似乎没有办法在运行时刻关闭</p>
<ul>
<li><p>修改页表</p>
<p>用户态空间所有数据被标记了<code>NX</code>，可以修改对应页表权限，未开<code>smep</code>修改后可以返回到用户态执行用户态代码</p>
</li>
<li><p><code>SWITCH_TO_USER_CR3_STACK</code></p>
<p>控制内核执行返回用户态时执行的切换页表代码判断也可以正常返回到用户态，页表切换主要靠<code>SWITCH_TO_USER_CR3_STACK</code>汇编宏，只要能调用这部分代码即可进行页表切换</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.macro SWITCH_TO_USER_CR3_STACK scratch_reg:req
    pushq   %rax
    SWITCH_TO_USER_CR3_NOSTACK scratch_reg&#x3D;\scratch_reg scratch_reg2&#x3D;%rax
    popq    %rax
.endm
.macro SWITCH_TO_USER_CR3_NOSTACK scratch_reg:req scratch_reg2:req
    ALTERNATIVE &quot;jmp .Lend_\@&quot;, &quot;&quot;, X86_FEATURE_PTI
    mov %cr3, \scratch_reg

    ALTERNATIVE &quot;jmp .Lwrcr3_\@&quot;, &quot;&quot;, X86_FEATURE_PCID

    &#x2F;*
     * Test if the ASID needs a flush.
     *&#x2F;
    movq    \scratch_reg, \scratch_reg2
    andq    $(0x7FF), \scratch_reg      &#x2F;* mask ASID *&#x2F;
    bt  \scratch_reg, THIS_CPU_user_pcid_flush_mask
    jnc .Lnoflush_\@

    &#x2F;* Flush needed, clear the bit *&#x2F;
    btr \scratch_reg, THIS_CPU_user_pcid_flush_mask
    movq    \scratch_reg2, \scratch_reg
    jmp .Lwrcr3_pcid_\@

.Lnoflush_\@:
    movq    \scratch_reg2, \scratch_reg
    SET_NOFLUSH_BIT \scratch_reg

.Lwrcr3_pcid_\@:
    &#x2F;* Flip the ASID to the user version *&#x2F;
    orq $(PTI_USER_PCID_MASK), \scratch_reg

.Lwrcr3_\@:
    &#x2F;* Flip the PGD to the user version *&#x2F;
    orq     $(PTI_USER_PGTABLE_MASK), \scratch_reg
    mov \scratch_reg, %cr3
.Lend_\@:
.endm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>页表切换后还要返回到用户态，需要复用内核中返回至用户态的代码，主要有两种方式：<code>iret</code>和<code>sysret</code></p>
<ul>
<li><p><code>iret</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">SYM_INNER_LABEL(swapgs_restore_regs_and_return_to_usermode, SYM_L_GLOBAL)
#ifdef CONFIG_DEBUG_ENTRY
    &#x2F;* Assert that pt_regs indicates user mode. *&#x2F;
    testb   $3, CS(%rsp)
    jnz 1f
    ud2
1:
#endif
    POP_REGS pop_rdi&#x3D;0

    &#x2F;*
     * The stack is now user RDI, orig_ax, RIP, CS, EFLAGS, RSP, SS.
     * Save old stack pointer and switch to trampoline stack.
     *&#x2F;
    movq    %rsp, %rdi
    movq    PER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp
    UNWIND_HINT_EMPTY

    &#x2F;* Copy the IRET frame to the trampoline stack. *&#x2F;
    pushq   6*8(%rdi)   &#x2F;* SS *&#x2F;
    pushq   5*8(%rdi)   &#x2F;* RSP *&#x2F;
    pushq   4*8(%rdi)   &#x2F;* EFLAGS *&#x2F;
    pushq   3*8(%rdi)   &#x2F;* CS *&#x2F;
    pushq   2*8(%rdi)   &#x2F;* RIP *&#x2F;

    &#x2F;* Push user RDI on the trampoline stack. *&#x2F;
    pushq   (%rdi)

    &#x2F;*
     * We are on the trampoline stack.  All regs except RDI are live.
     * We can do future final exit work right here.
     *&#x2F;
    STACKLEAK_ERASE_NOCLOBBER

    SWITCH_TO_USER_CR3_STACK scratch_reg&#x3D;%rdi

    &#x2F;* Restore RDI. *&#x2F;
    popq    %rdi
    SWAPGS
    INTERRUPT_RETURN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>伪造如下栈跳转到<code>movq %rsp, %rdi</code>就可以切换页表并且返回至用户态</p>
<pre class="line-numbers language-none"><code class="language-none">fake rax
fake rdi
RIP
CS
EFLAGS
RSP
SS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>sysret</code></p>
<p><code>rcx</code>、<code>r11</code>取值</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">rcx, save the rip of the code to be executed when returning to userspace
r11, save eflags<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>构造栈</p>
<pre class="line-numbers language-none"><code class="language-none">fake rdi
rsp, the stack of the userspace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>跳转<code>entry_SYSCALL_64</code>的如下部分即可返回到用户态</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">SWITCH_TO_USER_CR3_STACK scratch_reg&#x3D;%rdi

    popq    %rdi
    popq    %rsp
    swapgs
    sysretq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p><code>signal handler</code></p>
<p>在用户态注册<code>signal handler</code>来执行用户态的代码，无需切换页表</p>
</li>
</ul>
<h4 id="内核自身内部不同对象间的隔离"><a href="#内核自身内部不同对象间的隔离" class="headerlink" title="内核自身内部不同对象间的隔离"></a>内核自身内部不同对象间的隔离</h4><h5 id="堆块隔离"><a href="#堆块隔离" class="headerlink" title="堆块隔离"></a>堆块隔离</h5><h6 id="GFP-KERNEL-amp-GFP-KERNEL-ACCOUNT-的隔离"><a href="#GFP-KERNEL-amp-GFP-KERNEL-ACCOUNT-的隔离" class="headerlink" title="GFP_KERNEL &amp; GFP_KERNEL_ACCOUNT 的隔离"></a>GFP_KERNEL &amp; GFP_KERNEL_ACCOUNT 的隔离</h6><p><code>GFP_KERNEL</code> 与 <code>GFP_KERNEL_ACCOUNT</code> 是内核中最为常见与通用的分配 flag，常规情况下他们的分配都来自同一个 <code>kmem_cache</code> ——即通用的 <code>kmalloc-xx</code>。</p>
<p>在 <code>5.9</code> 版本之前<code>GFP_KERNEL</code> 与 <code>GFP_KERNEL_ACCOUNT</code> 存在隔离机制，自内核版本 5.14 起又重新引入：</p>
<ul>
<li>对于开启了 <code>CONFIG_MEMCG_KMEM</code> 编译选项的 <code>kernel</code> 而言（默认开启），其会为使用 <code>GFP_KERNEL_ACCOUNT</code> 进行分配的通用对象<strong>创建一组独立的 <code>kmem_cache</code> ——名为 <code>kmalloc-cg-\*</code></strong> ，从而导致使用这两种 flag 的 object 之间的隔离。</li>
</ul>
<h6 id="SLAB-ACCOUNT"><a href="#SLAB-ACCOUNT" class="headerlink" title="SLAB_ACCOUNT"></a>SLAB_ACCOUNT</h6><p>如果在使用 <code>kmem_cache_create</code> 创建一个 <code>cache</code> 时，传递了 <code>SLAB_ACCOUNT</code> 标记，那么这个 <code>cache</code> 就会单独存在，不会与其它相同大小的 <code>cache</code> 合并。在早期，许多结构体（如 <strong><code>cred</code> 结构体</strong>）对应的堆块并不单独存在，会和相同大小的堆块使用相同的 <code>cache</code>。在 <code>Linux 4.5</code> 版本引入了这个 <code>flag</code> 后，许多结构体就单独使用了自己的 <code>cache</code></p>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>使得内核中相应的对象具有一定的访问控制要求，比如不可写，或者不可读</p>
<h4 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h4><h5 id="dmesg-restrict"><a href="#dmesg-restrict" class="headerlink" title="dmesg_restrict"></a>dmesg_restrict</h5><p>内核日志有一些地址信息或者敏感信息，因此对<strong>内核日志</strong>的访问进行限制</p>
<p>该选项用于控制是否可以使用 <code>dmesg</code> 来<strong>查看内核日志</strong>。当 <code>dmesg_restrict</code> 为<code>0</code>时，没有任何限制；当该选项为 1 时，只有具有 <code>CAP_SYSLOG</code> 权限的用户才可以通过 <code>dmesg</code> 命令来查看内核日志</p>
<h5 id="kptr-restrict"><a href="#kptr-restrict" class="headerlink" title="kptr_restrict"></a>kptr_restrict</h5><p>在<strong>输出内核地址</strong>时施加的限制，主要限制通过 <code>/proc</code> 获取的内核地址</p>
<p>选项配置:</p>
<ul>
<li><code>0</code>：默认情况下，没有任何限制</li>
<li><code>1</code>：使用 <code>％pK</code> 输出的内核指针地址将被替换为 <code>0</code>，除非用户具有 <code>CAP_ SYSLOG</code> 特权，并且 <code>group id</code> 和真正的 <code>id</code> 相等</li>
<li><code>2</code>：使用 <code>％pK</code> 输出的内核指针都将被替换为 <code>0</code> ，<strong>与权限无关</strong></li>
</ul>
<p>当开启该保护后，攻击者就不能通过 <code>/proc/kallsyms</code> 来获取内核中某些敏感的地址了，如 <code>commit_creds</code>、<code>prepare_kernel_cred</code></p>
<h4 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h4><h5 id="ro-after-init"><a href="#ro-after-init" class="headerlink" title="__ro_after_init"></a>__ro_after_init</h5><p>使用 <code>__ro_after_init</code> 标记在 <code>__init</code> 阶段被初始化且初始化后就不会改变的内存，在 <code>init</code> 阶段结束后，不能够被再次修改</p>
<p>我们可以使用 <code>set_memory_rw(unsigned long addr, int numpages)</code> 来修改对应页的权限</p>
<h5 id="mmap-min-addr"><a href="#mmap-min-addr" class="headerlink" title="mmap_min_addr"></a>mmap_min_addr</h5><p><code>mmap_min_addr</code> 是用来对抗 <code>NULL Pointer Dereference</code> 的，指定用户进程通过 <code>mmap</code> 可以使用的最低的虚拟内存地址</p>
<h3 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h3><h4 id="Kernel-Stack-Canary"><a href="#Kernel-Stack-Canary" class="headerlink" title="Kernel Stack Canary"></a>Kernel Stack Canary</h4><p><strong>开启</strong>：开启编译选项<code>CONFIG_CC_STACKPROTECTOR</code></p>
<p><strong>关闭</strong>：重新编译内核，并关闭编译选项</p>
<p><strong>状态检查</strong>：<code>checksec</code></p>
<p><strong>特点</strong>：<code>x86</code> 架构下同一个 <code>task</code> 共享 <code>Canary</code></p>
<p><strong>攻击</strong>：只要泄露一次系统调用中的<code>canary</code>，同一<code>task</code>的其他系统调用中的<code>canary</code>就都被泄露了</p>
<h3 id="随机化"><a href="#随机化" class="headerlink" title="随机化"></a>随机化</h3><h4 id="KASLR"><a href="#KASLR" class="headerlink" title="KASLR"></a>KASLR</h4><p>内核的代码段基地址等地址会整体偏移</p>
<p><strong>开启</strong>：<code>-append kaslr</code></p>
<p><strong>关闭</strong>：<code>-append nokaslr</code></p>
<p><strong>攻击</strong>：泄露某个段的地址得到该段的基址</p>
<h4 id="FGKASLR"><a href="#FGKASLR" class="headerlink" title="FGKASLR"></a>FGKASLR</h4><p>在<code>KASLR</code>基础上，在加载时刻以函数粒度重新排布内核代码</p>
<p><strong>特点</strong>：<code>.text</code>参与随机化，<code>.data</code>不参与随机化</p>
<p><strong>开启</strong>:开启<code>CONFIG_FG_KASLR=y</code>选项</p>
<p><strong>关闭</strong>：<code>nokaslr</code>会同时关闭<code>FGKASLR</code>，也可以单独使用<code>nofgkaslr</code></p>
<p><strong>缺点</strong>：</p>
<ul>
<li>函数粒度随机化，如果函数内的某个地址知道了，函数内部的相对地址也就知道了</li>
<li><code>.text</code>节区不参与函数随机化，一旦知道其中的某个地址，就可以获取该节区所有的地址。系统调用的入口代码都在该节区内，且该节区具有以下 <code>gadget</code><ul>
<li><code>swapgs_restore_regs_and_return_to_usermode</code>，用于绕过 KPTI 防护</li>
<li><code>memcpy</code> 内存拷贝</li>
<li><code>sync_regs</code>，可以把 <code>RAX</code> 放到 <code>RDI</code> 中</li>
</ul>
</li>
<li><code>__ksymtab</code>相对于内核镜像的偏移是固定的，如果我们可以泄露数据，那就可以泄露出其它的符号地址，如 <code>prepare_kernel_cred</code>、<code>commit_creds</code><ul>
<li>基于内核镜像地址获取 <code>__ksymtab</code> 地址</li>
<li>基于 <code>__ksymtab</code> 获取对应符号记录项的地址</li>
<li>根据符号记录项中具体的内容来获取对应符号的地址</li>
</ul>
</li>
<li><code>data</code> 节区相对于内核镜像的偏移是固定的。因此在获取了内核镜像的基地址后，就可以计算出数据区数据的地址，这个节区有一些重要数据比如<code>modprobe_path</code></li>
</ul>
<p><code>__ksymtab</code> 格式</p>
<p><code>__ksymtab</code> 中每个记录项的名字的格式为 <code>__ksymtab_func_name</code>，以 <code>prepare_kernel_cred</code> 为例，对应的记录项的名字为<code>__ksymtab_prepare_kernel_cred</code>，因此，我们可以直接通过该名字在 IDA 里找到对应的位置，如下</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">__ksymtab:FFFFFFFF81F8D4FC __ksymtab_prepare_kernel_cred dd 0FF5392F4h
__ksymtab:FFFFFFFF81F8D500                 dd 134B2h
__ksymtab:FFFFFFFF81F8D504                 dd 1783Eh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>__ksymtab</code> 每一项的结构为</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">kernel_symbol</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> value_offset<span class="token punctuation">;</span>
    <span class="token keyword">int</span> name_offset<span class="token punctuation">;</span>
    <span class="token keyword">int</span> namespace_offset<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第一个表项记录了重定位表项相对于当前地址的偏移。那么，<code>prepare_kernel_cred</code> 的地址应该为 <code>0xFFFFFFFF81F8D4FC-(2**32-0xFF5392F4)=0xffffffff814c67f0</code></p>
<p>即<code>__ksymtab_prepare_kernel_cred addr - (2 ** 32 - __ksymtab_prepare_kernel_cred)</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.text.prepare_kernel_cred:FFFFFFFF814C67F0                 public prepare_kernel_cred
.text.prepare_kernel_cred:FFFFFFFF814C67F0 prepare_kernel_cred proc near           ; CODE XREF: sub_FFFFFFFF814A5ED5+52↑p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/kernel-mode">https://ctf-wiki.org/pwn/linux/kernel-mode</a></p>
<p><a target="_blank" rel="noopener" href="https://www.z1r0.top/2021/11/21/kernel-pwn%EF%BC%88%E4%B8%89%EF%BC%89%E9%98%B2%E5%BE%A1%E6%9C%BA%E5%88%B6/#%E7%BC%BA%E7%82%B9">https://www.z1r0.top/2021/11/21/kernel-pwn%EF%BC%88%E4%B8%89%EF%BC%89%E9%98%B2%E5%BE%A1%E6%9C%BA%E5%88%B6/#%E7%BC%BA%E7%82%B9</a></p>
<p><a target="_blank" rel="noopener" href="https://www.z1r0.top/2021/10/29/kernel-pwn%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#/">https://www.z1r0.top/2021/10/29/kernel-pwn%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#/</a></p>

                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/kernel/">
                                    <span class="chip bg-color">kernel</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2024/03/18/ciscn-babydriver-kernel-pwn-jie-ti-yi-ban-guo-cheng/ciscn-babydriver-kernel-pwn-jie-ti-yi-ban-guo-cheng/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/Steel%20Gray.jpg" class="responsive-img" alt="ciscn_babydriver-kernel_pwn解题一般过程">
                        
                        <span class="card-title">ciscn_babydriver-kernel_pwn解题一般过程</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            从ciscn_babydriver学习kernel pwn的一般解题过程
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-03-18
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/kernel/" class="post-category">
                                    kernel
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/kernel/">
                        <span class="chip bg-color">kernel</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/03/09/kernel-huan-jing-pei-zhi/kernel-huan-jing-pei-zhi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/Steel%20Gray.jpg" class="responsive-img" alt="kernel环境配置">
                        
                        <span class="card-title">kernel环境配置</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            kernel相关环境配置
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-03-09
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/kernel/" class="post-category">
                                    kernel
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/kernel/">
                        <span class="chip bg-color">kernel</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2024</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">StarrySky</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">106.9k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/starrysky1004" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:starrysky20041005@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2726736810" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2726736810" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>









    <a href="https://space.bilibili.com/85923475" class="tooltipped" target="_blank" data-tooltip="关注我的bilibili" data-position="top" data-delay="50">
        <i class="fas fa-video"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":260,"height":300},"mobile":{"show":true},"log":false});</script></body>

</html>
