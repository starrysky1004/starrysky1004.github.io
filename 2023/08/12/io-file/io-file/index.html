<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="IO_FILE, StarrySky">
    <meta name="description" content="Love rises from the east and descends to the west,romance makes no changes until death.">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>IO_FILE | StarrySky</title>
    <link rel="icon" type="image/jpeg" href="/favicon.jpg">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="StarrySky" type="application/atom+xml">
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">StarrySky</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>主页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>文章</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>个人简介</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友链</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">StarrySky</div>
        <div class="logo-desc">
            
            Love rises from the east and descends to the west,romance makes no changes until death.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			主页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			文章
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			个人简介
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友链
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/Steel%20Gray.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">IO_FILE</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/IO/">
                                <span class="chip bg-color">IO</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-08-12
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    7.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    41 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="IO FILE"></a>IO FILE</h2><p><code>IO_FILE</code>结构体：通过<code>chain</code>域连接<code>stderr</code>、<code>stdout</code>、<code>stdin</code>的链表，链表的表头是<code>__IO_list_all</code>，<code>stderr</code>、<code>stdout</code>、<code>stdin</code>是程序启动时打开的文件流,<code>_IO_FILE</code>结构体定义在<code>libio.h</code>头文件中，<code>gdb</code>查看结构体可以使用命令：<code>p *_IO_list_all</code></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">struct _IO_FILE &#123;
  int _flags;		&#x2F;* High-order word is _IO_MAGIC; rest is flags. *&#x2F;
#define _IO_file_flags _flags

  char* _IO_read_ptr;	&#x2F;* Current read pointer *&#x2F;
  char* _IO_read_end;	&#x2F;* End of get area. *&#x2F;
  char* _IO_read_base;	&#x2F;* Start of putback+get area. *&#x2F;
  char* _IO_write_base;	&#x2F;* Start of put area. *&#x2F;
  char* _IO_write_ptr;	&#x2F;* Current put pointer. *&#x2F;
  char* _IO_write_end;	&#x2F;* End of put area. *&#x2F;
  char* _IO_buf_base;	&#x2F;* Start of reserve area. *&#x2F;
  char* _IO_buf_end;	&#x2F;* End of reserve area. *&#x2F;
  &#x2F;* The following fields are used to support backing up and undo. *&#x2F;
  char *_IO_save_base; &#x2F;* Pointer to start of non-current get area. *&#x2F;
  char *_IO_backup_base;  &#x2F;* Pointer to first valid character of backup area *&#x2F;
  char *_IO_save_end; &#x2F;* Pointer to end of non-current get area. *&#x2F;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
#if 0
  int _blksize;
#else
  int _flags2;
#endif
  _IO_off_t _old_offset; &#x2F;* This used to be _offset but it&#39;s too small.  *&#x2F;

#define __HAVE_COLUMN &#x2F;* temporary *&#x2F;
  &#x2F;* 1+column number of pbase(); 0 is unknown. *&#x2F;
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  &#x2F;*  char* _save_gptr;  char* _save_egptr; *&#x2F;

  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">			        stderr		     stdout		      stdin
IO_list_all  ––⇨     flag	   ¦ ⇨   flag	   ¦ ⇨   flag
                     chain   ––      chain    ––      chain<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>_IO_FILE_plus</code>结构体：定义在<code>libioP.h</code>中，包含<code>vtable</code>虚函数表</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">struct _IO_FILE_plus
&#123;
  _IO_FILE file;
  const struct _IO_jump_t *vtable;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>vtable</code>：是一个函数指针数组，存储了一个类的虚函数的地址，<code>_IO_jump_t</code>是一个结构体，它定义了一组函数指针，用于实现<code>_IO_FILE_plus</code>结构体中的虚函数表。这些函数指针对应了<code>_IO_FILE_plus</code>结构体中的各种操作，通过虚函数表，可以实现对<code>_IO_FILE_plus</code>结构体中的函数进行动态绑定，使得在运行时可以根据具体对象的类型来调用相应的函数。<code>gdb</code>查看结构体内容时可以使用命令:<code>p *_IO_list_all-&gt;vtable</code></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">struct _IO_jump_t
&#123;
    JUMP_FIELD(size_t, __dummy);
    JUMP_FIELD(size_t, __dummy2);
    JUMP_FIELD(_IO_finish_t, __finish);
    JUMP_FIELD(_IO_overflow_t, __overflow);
    JUMP_FIELD(_IO_underflow_t, __underflow);
    JUMP_FIELD(_IO_underflow_t, __uflow);
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);
    &#x2F;* showmany *&#x2F;
    JUMP_FIELD(_IO_xsputn_t, __xsputn);
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);
    JUMP_FIELD(_IO_seekoff_t, __seekoff);
    JUMP_FIELD(_IO_seekpos_t, __seekpos);
    JUMP_FIELD(_IO_setbuf_t, __setbuf);
    JUMP_FIELD(_IO_sync_t, __sync);
    JUMP_FIELD(_IO_doallocate_t, __doallocate);
    JUMP_FIELD(_IO_read_t, __read);
    JUMP_FIELD(_IO_write_t, __write);
    JUMP_FIELD(_IO_seek_t, __seek);
    JUMP_FIELD(_IO_close_t, __close);
    JUMP_FIELD(_IO_stat_t, __stat);
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);
    JUMP_FIELD(_IO_imbue_t, __imbue);
#if 0
    get_column;
    set_column;
#endif
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>_IO_wide_data</code>结构体：结构体中实现了虚表</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">struct _IO_wide_data
&#123;
  wchar_t *_IO_read_ptr;	&#x2F;* Current read pointer *&#x2F;
  wchar_t *_IO_read_end;	&#x2F;* End of get area. *&#x2F;
  wchar_t *_IO_read_base;	&#x2F;* Start of putback+get area. *&#x2F;
  wchar_t *_IO_write_base;	&#x2F;* Start of put area. *&#x2F;
  wchar_t *_IO_write_ptr;	&#x2F;* Current put pointer. *&#x2F;
  wchar_t *_IO_write_end;	&#x2F;* End of put area. *&#x2F;
  wchar_t *_IO_buf_base;	&#x2F;* Start of reserve area. *&#x2F;
  wchar_t *_IO_buf_end;		&#x2F;* End of reserve area. *&#x2F;
  &#x2F;* The following fields are used to support backing up and undo. *&#x2F;
  wchar_t *_IO_save_base;	&#x2F;* Pointer to start of non-current get area. *&#x2F;
  wchar_t *_IO_backup_base;	&#x2F;* Pointer to first valid character of
				   backup area *&#x2F;
  wchar_t *_IO_save_end;	&#x2F;* Pointer to end of non-current get area. *&#x2F;

  __mbstate_t _IO_state;
  __mbstate_t _IO_last_state;
  struct _IO_codecvt _codecvt;

  wchar_t _shortbuf[1];

  const struct _IO_jump_t *_wide_vtable;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>st</code>结构体：<code>struct stat64</code>是一个结构体，用于存储文件的状态信息。在<code>_IO_file_doallocate</code>函数中，通过调用<code>_IO_SYSSTAT</code>宏来获取文件的状态信息，并将其存储在<code>st</code>结构体中。然后根据文件的类型和块大小来确定缓冲区的大小，并使用<code>malloc</code>函数分配相应大小的内存。最后，使用<code>_IO_setb</code>函数将分配的内存设置为文件的缓冲区</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">struct stat64 &#123;
    __dev_t         st_dev;         &#x2F;* 文件所在的设备的ID *&#x2F;
    __ino64_t       st_ino;         &#x2F;* 文件的inode号 *&#x2F;
    __mode_t        st_mode;        &#x2F;* 文件的类型和访问权限 *&#x2F;
    __nlink_t       st_nlink;       &#x2F;* 文件的硬链接数 *&#x2F;
    __uid_t         st_uid;         &#x2F;* 文件的所有者的用户ID *&#x2F;
    __gid_t         st_gid;         &#x2F;* 文件的所有者的组ID *&#x2F;
    __dev_t         st_rdev;        &#x2F;* 如果文件是特殊文件（如设备文件），则为其设备号 *&#x2F;
    __off64_t       st_size;        &#x2F;* 文件的大小（以字节为单位） *&#x2F;
    __blksize_t     st_blksize;     &#x2F;* 文件系统的块大小 *&#x2F;
    __blkcnt64_t    st_blocks;      &#x2F;* 文件所占用的块数 *&#x2F;
    struct timespec st_atim;        &#x2F;* 文件的最后访问时间 *&#x2F;
    struct timespec st_mtim;        &#x2F;* 文件的最后修改时间 *&#x2F;
    struct timespec st_ctim;        &#x2F;* 文件的最后状态更改时间 *&#x2F;
    __ino64_t       st_ino;         &#x2F;* 文件的inode号（备用） *&#x2F;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()&#123;
    FILE*fp &#x3D; fopen(&quot;test&quot;,&quot;wb&quot;);
    char *ptr &#x3D; malloc(0x20);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>跟进<code>fopen</code>函数</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">► 0x555555555183 &lt;main+26&gt;    call   fopen@plt                &lt;fopen@plt&gt;
        filename: 0x555555556007 ◂— 0x31b010074736574 &#x2F;* &#39;test&#39; *&#x2F;
        modes: 0x555555556004 ◂— 0x74736574006277 &#x2F;* &#39;wb&#39; *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>可以看到真正调用的是<code>_IO_new_fopen</code>函数，接下来调用<code>__fopen_internal</code>函数</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">In file: &#x2F;home&#x2F;starrysky&#x2F;IO&#x2F;glibc-2.23&#x2F;libio&#x2F;iofopen.c
    92 &#125;
    93 
    94 _IO_FILE *
    95 _IO_new_fopen (const char *filename, const char *mode)
    96 &#123;
 ►  97   return __fopen_internal (filename, mode, 1);
    98 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>为<code>locked_FILE</code>结构体变量<code>new_f</code>分配<code>0x230</code>的空间，结构体如下</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C"> struct locked_FILE
  &#123;
    struct _IO_FILE_plus fp;
#ifdef _IO_MTSAFE_IO
    _IO_lock_t lock;
#endif
    struct _IO_wide_data wd;
  &#125; *new_f &#x3D; (struct locked_FILE *) malloc (sizeof (struct locked_FILE));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555b000
Size: 0x231

Top chunk | PREV_INUSE
Addr: 0x55555555b230
Size: 0x20dd1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接下来调用<code>_IO_no_init</code>对结构体中的成员进行<code>null</code>初始化</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">In file: &#x2F;home&#x2F;starrysky&#x2F;IO&#x2F;glibc-2.23&#x2F;libio&#x2F;iofopen.c
   72     return NULL;
   73 #ifdef _IO_MTSAFE_IO
   74   new_f-&gt;fp.file._lock &#x3D; &amp;new_f-&gt;lock;
   75 #endif
   76 #if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
 ► 77   _IO_no_init (&amp;new_f-&gt;fp.file, 0, 0, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);
   78 #else<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">void
_IO_no_init (_IO_FILE *fp, int flags, int orientation,
	     struct _IO_wide_data *wd, const struct _IO_jump_t *jmp)
&#123;
  _IO_old_init (fp, flags);
  fp-&gt;_mode &#x3D; orientation;
#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
  if (orientation &gt;&#x3D; 0)
    &#123;
      fp-&gt;_wide_data &#x3D; wd;
      fp-&gt;_wide_data-&gt;_IO_buf_base &#x3D; NULL;
      fp-&gt;_wide_data-&gt;_IO_buf_end &#x3D; NULL;
      fp-&gt;_wide_data-&gt;_IO_read_base &#x3D; NULL;
      fp-&gt;_wide_data-&gt;_IO_read_ptr &#x3D; NULL;
      fp-&gt;_wide_data-&gt;_IO_read_end &#x3D; NULL;
      fp-&gt;_wide_data-&gt;_IO_write_base &#x3D; NULL;
      fp-&gt;_wide_data-&gt;_IO_write_ptr &#x3D; NULL;
      fp-&gt;_wide_data-&gt;_IO_write_end &#x3D; NULL;
      fp-&gt;_wide_data-&gt;_IO_save_base &#x3D; NULL;
      fp-&gt;_wide_data-&gt;_IO_backup_base &#x3D; NULL;
      fp-&gt;_wide_data-&gt;_IO_save_end &#x3D; NULL;

      fp-&gt;_wide_data-&gt;_wide_vtable &#x3D; jmp;
    &#125;
  else
    &#x2F;* Cause predictable crash when a wide function is called on a byte
       stream.  *&#x2F;
    fp-&gt;_wide_data &#x3D; (struct _IO_wide_data *) -1L;
#endif
  fp-&gt;_freeres_list &#x3D; NULL;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>初始化完成之后结构体中的内容如下</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; p new_f-&gt;fp
$1 &#x3D; &#123;
  file &#x3D; &#123;
    _flags &#x3D; -72548352,
    _IO_read_ptr &#x3D; 0x0,
    _IO_read_end &#x3D; 0x0,
    _IO_read_base &#x3D; 0x0,
    _IO_write_base &#x3D; 0x0,
    _IO_write_ptr &#x3D; 0x0,
    _IO_write_end &#x3D; 0x0,
    _IO_buf_base &#x3D; 0x0,
    _IO_buf_end &#x3D; 0x0,
    _IO_save_base &#x3D; 0x0,
    _IO_backup_base &#x3D; 0x0,
    _IO_save_end &#x3D; 0x0,
    _markers &#x3D; 0x0,
    _chain &#x3D; 0x0,
    _fileno &#x3D; 0,
    _flags2 &#x3D; 0,
    _old_offset &#x3D; 0,
    _cur_column &#x3D; 0,
    _vtable_offset &#x3D; 0 &#39;\000&#39;,
    _shortbuf &#x3D; &quot;&quot;,
    _lock &#x3D; 0x55555555b0f0,
    _offset &#x3D; 0,
    _codecvt &#x3D; 0x0,
    _wide_data &#x3D; 0x55555555b100,
    _freeres_list &#x3D; 0x0,
    _freeres_buf &#x3D; 0x0,
    __pad5 &#x3D; 0,
    _mode &#x3D; 0,
    _unused2 &#x3D; &#39;\000&#39; &lt;repeats 19 times&gt;
  &#125;,
  vtable &#x3D; 0x0
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接下来调用<code>_IO_file_init</code>将该结构体连接到<code>_IO_list_all</code>中，实际调用的是<code>_IO_new_file_init</code>函数</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">In file: &#x2F;home&#x2F;starrysky&#x2F;IO&#x2F;glibc-2.23&#x2F;libio&#x2F;iofopen.c
   77   _IO_no_init (&amp;new_f-&gt;fp.file, 0, 0, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);
   78 #else
   79   _IO_no_init (&amp;new_f-&gt;fp.file, 1, 0, NULL, NULL);
   80 #endif
   81   _IO_JUMPS (&amp;new_f-&gt;fp) &#x3D; &amp;_IO_file_jumps;
 ► 82   _IO_file_init (&amp;new_f-&gt;fp);
   83 #if  !_IO_UNIFIED_JUMPTABLES
   84   new_f-&gt;fp.vtable &#x3D; NULL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">void
_IO_new_file_init (struct _IO_FILE_plus *fp)
&#123;
  &#x2F;* POSIX.1 allows another file handle to be used to change the position
     of our file descriptor.  Hence we actually don&#39;t know the actual
     position before we do the first fseek (and until a following fflush). *&#x2F;
  fp-&gt;file._offset &#x3D; _IO_pos_BAD;
  fp-&gt;file._IO_file_flags |&#x3D; CLOSED_FILEBUF_FLAGS;

  _IO_link_in (fp);
  fp-&gt;file._fileno &#x3D; -1;
&#125;
libc_hidden_ver (_IO_new_file_init, _IO_file_init)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>_IO_new_file_init</code>函数中调用了<code>_IO_link_in</code>函数用于将文件指针链接到全局文件链表中</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">void
_IO_link_in (struct _IO_FILE_plus *fp)
&#123;
  if ((fp-&gt;file._flags &amp; _IO_LINKED) &#x3D;&#x3D; 0)
    &#123;
      fp-&gt;file._flags |&#x3D; _IO_LINKED;
#ifdef _IO_MTSAFE_IO
      _IO_cleanup_region_start_noarg (flush_cleanup);
      _IO_lock_lock (list_all_lock);
      run_fp &#x3D; (_IO_FILE *) fp;
      _IO_flockfile ((_IO_FILE *) fp);
#endif
      fp-&gt;file._chain &#x3D; (_IO_FILE *) _IO_list_all;
      _IO_list_all &#x3D; fp;
      ++_IO_list_all_stamp;
#ifdef _IO_MTSAFE_IO
      _IO_funlockfile ((_IO_FILE *) fp);
      run_fp &#x3D; NULL;
      _IO_lock_unlock (list_all_lock);
      _IO_cleanup_region_end (0);
#endif
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>函数首先检查文件指针的<code>_flags</code>属性是否包含 <code>_IO_LINKED</code> 标志位，如果不包含，则说明还没有链接到链表中，接下来，将结构体的 <code>_chain</code> 属性设置为之前的链表的值并设置<code>_IO_LINKED</code>标志位，查看链表中的内容，将会指向新加入的结构体</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; p _IO_list_all
$3 &#x3D; (struct _IO_FILE_plus *) 0x55555555b010<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>调用<code>_IO_file_fopen</code>打开文件</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">In file: &#x2F;home&#x2F;starrysky&#x2F;IO&#x2F;glibc-2.23&#x2F;libio&#x2F;iofopen.c
   81   _IO_JUMPS (&amp;new_f-&gt;fp) &#x3D; &amp;_IO_file_jumps;
   82   _IO_file_init (&amp;new_f-&gt;fp);
   83 #if  !_IO_UNIFIED_JUMPTABLES
   84   new_f-&gt;fp.vtable &#x3D; NULL;
   85 #endif
 ► 86   if (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) !&#x3D; NULL)
   87     return __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);
   88 
   89   _IO_un_link (&amp;new_f-&gt;fp);
   90   free (new_f);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>实际调用的是<code>_IO_new_file_fopen</code></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">_IO_new_file_fopen (_IO_FILE *fp, const char *filename, const char *mode,
		    int is32not64)
&#123;
  ...
  if (_IO_file_is_open (fp))
    return 0;
  switch (*mode)
    &#123;
    case &#39;r&#39;:
      omode &#x3D; O_RDONLY;
      read_write &#x3D; _IO_NO_WRITES;
      break;
    ...
    &#125;
#ifdef _LIBC
  last_recognized &#x3D; mode;
#endif
  for (i &#x3D; 1; i &lt; 7; ++i)
    &#123;
      switch (*++mode)
	&#123;
	case &#39;\0&#39;:
	  break;
	case &#39;+&#39;:
	  omode &#x3D; O_RDWR;
	  read_write &amp;&#x3D; _IO_IS_APPENDING;
#ifdef _LIBC
	  last_recognized &#x3D; mode;
#endif
	  continue;
	...
    &#125;

  result &#x3D; _IO_file_open (fp, filename, omode|oflags, oprot, read_write,
			  is32not64);
    ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>会先判断文件是否已被打开，如果已经打开则返回，接下来设置打开模式和一些标志位，最后调用<code>_IO_file_open</code>真正打开文件</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">_IO_file_open (_IO_FILE *fp, const char *filename, int posix_mode, int prot,
	       int read_write, int is32not64)
&#123;
  int fdesc;
#ifdef _LIBC
  if (__glibc_unlikely (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL))
    fdesc &#x3D; open_not_cancel (filename,
			     posix_mode | (is32not64 ? 0 : O_LARGEFILE), prot);
  else
    fdesc &#x3D; open (filename, posix_mode | (is32not64 ? 0 : O_LARGEFILE), prot);
#else
  fdesc &#x3D; open (filename, posix_mode, prot);
#endif
  if (fdesc &lt; 0)
    return NULL;
  fp-&gt;_fileno &#x3D; fdesc;
  _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);
  &#x2F;* For append mode, send the file offset to the end of the file.  Don&#39;t
     update the offset cache though, since the file handle is not active.  *&#x2F;
  if ((read_write &amp; (_IO_IS_APPENDING | _IO_NO_READS))
      &#x3D;&#x3D; (_IO_IS_APPENDING | _IO_NO_READS))
    &#123;
      _IO_off64_t new_pos &#x3D; _IO_SYSSEEK (fp, 0, _IO_seek_end);
      if (new_pos &#x3D;&#x3D; _IO_pos_BAD &amp;&amp; errno !&#x3D; ESPIPE)
	&#123;
	  close_not_cancel (fdesc);
	  return NULL;
	&#125;
    &#125;
  _IO_link_in ((struct _IO_FILE_plus *) fp);
  return fp;
&#125;
libc_hidden_def (_IO_file_open)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>调用<code>open</code>系统调用函数打开文件之后设置<code>fileno</code>标志位，再调用<code>_IO_link_in</code>使结构体进入<code>_IO_list_all</code>，至此<code>fopen</code>函数调试结束</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; p new_f-&gt;fp
$6 &#x3D; &#123;
  file &#x3D; &#123;
    _flags &#x3D; -72539004,
    _IO_read_ptr &#x3D; 0x0,
    _IO_read_end &#x3D; 0x0,
    _IO_read_base &#x3D; 0x0,
    _IO_write_base &#x3D; 0x0,
    _IO_write_ptr &#x3D; 0x0,
    _IO_write_end &#x3D; 0x0,
    _IO_buf_base &#x3D; 0x0,
    _IO_buf_end &#x3D; 0x0,
    _IO_save_base &#x3D; 0x0,
    _IO_backup_base &#x3D; 0x0,
    _IO_save_end &#x3D; 0x0,
    _markers &#x3D; 0x0,
    _chain &#x3D; 0x7ffff7dd2540 &lt;_IO_2_1_stderr_&gt;,
    _fileno &#x3D; 3,
    _flags2 &#x3D; 0,
    _old_offset &#x3D; 0,
    _cur_column &#x3D; 0,
    _vtable_offset &#x3D; 0 &#39;\000&#39;,
    _shortbuf &#x3D; &quot;&quot;,
    _lock &#x3D; 0x55555555b0f0,
    _offset &#x3D; -1,
    _codecvt &#x3D; 0x0,
    _wide_data &#x3D; 0x55555555b100,
    _freeres_list &#x3D; 0x0,
    _freeres_buf &#x3D; 0x0,
    __pad5 &#x3D; 0,
    _mode &#x3D; 0,
    _unused2 &#x3D; &#39;\000&#39; &lt;repeats 19 times&gt;
  &#125;,
  vtable &#x3D; 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;
&#125;
pwndbg&gt; p _IO_list_all
$7 &#x3D; (struct _IO_FILE_plus *) 0x55555555b010<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;

int main()&#123;
    char data[20];
    FILE *fp &#x3D; fopen(&quot;test&quot;, &quot;rb&quot;);
    fread(data, 1, 20, fp);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>进入<code>read</code>函数之后实际调用的是<code>_IO_fread</code></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">In file: &#x2F;home&#x2F;starrysky&#x2F;IO&#x2F;glibc-2.23&#x2F;libio&#x2F;iofread.c
   26 
   27 #include &quot;libioP.h&quot;
   28 
   29 _IO_size_t
   30 _IO_fread (void *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)
 ► 31 &#123;
   32   _IO_size_t bytes_requested &#x3D; size * count;
   33   _IO_size_t bytes_read;
   34   CHECK_FILE (fp, 0);
   35   if (bytes_requested &#x3D;&#x3D; 0)
   36     return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>源码如下</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">_IO_size_t
_IO_fread (void *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)
&#123;
  ...
  bytes_read &#x3D; _IO_sgetn (fp, (char *) buf, bytes_requested);
  _IO_release_lock (fp);
  return bytes_requested &#x3D;&#x3D; bytes_read ? count : bytes_read &#x2F; size;
&#125;
libc_hidden_def (_IO_fread)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>调用了<code>_IO_sgetn</code>函数</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">► 0x7ffff7a7c171 &lt;fread+145&gt;    call   _IO_sgetn                &lt;_IO_sgetn&gt;
        arg0: 0x405010 ◂— 0xfbad2488
        arg1: 0x7fffffffde40 —▸ 0x4011a0 (__libc_csu_init) ◂— endbr64 
        arg2: 0x14<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">  464 _IO_sgetn (_IO_FILE *fp, void *data, _IO_size_t n)
  465 &#123;
  466   &#x2F;* FIXME handle putback buffer here! *&#x2F;
► 467   return _IO_XSGETN (fp, data, n);
  468 &#125;
  469 libc_hidden_def (_IO_sgetn)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>该函数调用了<code>_IO_XSGETN</code>函数，实际调用的是<code>_IO_file_xsgetn</code>函数，即<code>vtable</code>的<code>__xsgetn</code>函数，作用是从文件流中读取指定数量的字节，并将其存储到指定的缓冲区中</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">In file: &#x2F;home&#x2F;starrysky&#x2F;IO&#x2F;glibc-2.23&#x2F;libio&#x2F;fileops.c
   1355 &#125;
   1356 libc_hidden_ver (_IO_new_file_xsputn, _IO_file_xsputn)
   1357 
   1358 _IO_size_t
   1359 _IO_file_xsgetn (_IO_FILE *fp, void *data, _IO_size_t n)
 ► 1360 &#123;
   1361   _IO_size_t want, have;
   1362   _IO_ssize_t count;
   1363   char *s &#x3D; data;
   1364 
   1365   want &#x3D; n;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; p *_IO_list_all-&gt;vtable
$1 &#x3D; &#123;
  __dummy &#x3D; 0,
  __dummy2 &#x3D; 0,
  __finish &#x3D; 0x7ffff7a878f0 &lt;_IO_new_file_finish&gt;,
  __overflow &#x3D; 0x7ffff7a88660 &lt;_IO_new_file_overflow&gt;,
  __underflow &#x3D; 0x7ffff7a883d0 &lt;_IO_new_file_underflow&gt;,
  __uflow &#x3D; 0x7ffff7a89530 &lt;__GI__IO_default_uflow&gt;,
  __pbackfail &#x3D; 0x7ffff7a8a8b0 &lt;__GI__IO_default_pbackfail&gt;,
  __xsputn &#x3D; 0x7ffff7a87110 &lt;_IO_new_file_xsputn&gt;,
  __xsgetn &#x3D; 0x7ffff7a86df0 &lt;__GI__IO_file_xsgetn&gt;,
  __seekoff &#x3D; 0x7ffff7a863f0 &lt;_IO_new_file_seekoff&gt;,
  __seekpos &#x3D; 0x7ffff7a89930 &lt;_IO_default_seekpos&gt;,
  __setbuf &#x3D; 0x7ffff7a86360 &lt;_IO_new_file_setbuf&gt;,
  __sync &#x3D; 0x7ffff7a862a0 &lt;_IO_new_file_sync&gt;,
  __doallocate &#x3D; 0x7ffff7a7b130 &lt;__GI__IO_file_doallocate&gt;,
  __read &#x3D; 0x7ffff7a870d0 &lt;__GI__IO_file_read&gt;,
  __write &#x3D; 0x7ffff7a86aa0 &lt;_IO_new_file_write&gt;,
  __seek &#x3D; 0x7ffff7a868a0 &lt;__GI__IO_file_seek&gt;,
  __close &#x3D; 0x7ffff7a86270 &lt;__GI__IO_file_close&gt;,
  __stat &#x3D; 0x7ffff7a86a90 &lt;__GI__IO_file_stat&gt;,
  __showmanyc &#x3D; 0x7ffff7a8aa20 &lt;_IO_default_showmanyc&gt;,
  __imbue &#x3D; 0x7ffff7a8aa30 &lt;_IO_default_imbue&gt;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>跟进该函数， 当文件流的缓冲区为空时调用<code>_IO_doallocbuf</code>函数分配新的缓冲区来初始化</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">
 if (fp-&gt;_IO_buf_base &#x3D;&#x3D; NULL)
   &#123;
     &#x2F;* Maybe we already have a push back pointer.  *&#x2F;
     if (fp-&gt;_IO_save_base !&#x3D; NULL)
&#123;
  free (fp-&gt;_IO_save_base);
  fp-&gt;_flags &amp;&#x3D; ~_IO_IN_BACKUP;
&#125;
     _IO_doallocbuf (fp);
   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>跟进<code>_IO_doallocbuf</code>函数，函数中再次检查缓冲区是否为空，即是否已初始化</p>
<pre class="line-numbers language-none"><code class="language-none">In file: &#x2F;home&#x2F;starrysky&#x2F;IO&#x2F;glibc-2.23&#x2F;libio&#x2F;genops.c
   390 libc_hidden_def (_IO_setb)
   391 
   392 void
   393 _IO_doallocbuf (_IO_FILE *fp)
   394 &#123;
 ► 395   if (fp-&gt;_IO_buf_base)
   396     return;
   397   if (!(fp-&gt;_flags &amp; _IO_UNBUFFERED) || fp-&gt;_mode &gt; 0)
   398     if (_IO_DOALLOCATE (fp) !&#x3D; EOF)
   399       return;
   400   _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+1, 0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">void
_IO_doallocbuf (_IO_FILE *fp)
&#123;
  if (fp-&gt;_IO_buf_base)
    return;
  if (!(fp-&gt;_flags &amp; _IO_UNBUFFERED) || fp-&gt;_mode &gt; 0)
    if (_IO_DOALLOCATE (fp) !&#x3D; EOF)
      return;
  _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+1, 0);
&#125;
libc_hidden_def (_IO_doallocbuf)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>if (_IO_DOALLOCATE (fp) != EOF)</code>中调用<code>_IO_doallocbuf</code>分配缓冲区</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">  0x7ffff7a894b7 &lt;_IO_doallocbuf+39&gt;    mov    rax, qword ptr [rbx + 0xd8]
  0x7ffff7a894be &lt;_IO_doallocbuf+46&gt;    mov    rdi, rbx
► 0x7ffff7a894c1 &lt;_IO_doallocbuf+49&gt;    call   qword ptr [rax + 0x68]        &lt;_IO_file_doallocate&gt;
       rdi: 0x405010 ◂— 0xfbad2488
       rsi: 0x7fffffffde40 —▸ 0x4011a0 (__libc_csu_init) ◂— endbr64 
       rdx: 0x14
       rcx: 0x405010 ◂— 0xfbad2488<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">In file: &#x2F;home&#x2F;starrysky&#x2F;IO&#x2F;glibc-2.23&#x2F;libio&#x2F;filedoalloc.c
    90  * optimisation) right after the _fstat() that finds the buffer size.
    91  *&#x2F;
    92 
    93 int
    94 _IO_file_doallocate (_IO_FILE *fp)
 ►  95 &#123;
    96   _IO_size_t size;
    97   char *p;
    98   struct stat64 st;
    99 
   100 #ifndef _LIBC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>_IO_file_doallocate</code>首先会调用<code>_IO_SYSSTAT</code>，即<code>vtable</code>中的<code> __stat</code>函数，获取文件状态并修改<code>st</code>结构体</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">_IO_file_doallocate (_IO_FILE *fp)
&#123;
 ...
  if (fp-&gt;_fileno &gt;&#x3D; 0 &amp;&amp; __builtin_expect (_IO_SYSSTAT (fp, &amp;st), 0) &gt;&#x3D; 0)
    &#123;
      if (S_ISCHR (st.st_mode))
	&#123;
	  &#x2F;* Possibly a tty.  *&#x2F;
	  if (
#ifdef DEV_TTY_P
	      DEV_TTY_P (&amp;st) ||
#endif
	      local_isatty (fp-&gt;_fileno))
	    fp-&gt;_flags |&#x3D; _IO_LINE_BUF;
	&#125;
#if _IO_HAVE_ST_BLKSIZE
      if (st.st_blksize &gt; 0)
	size &#x3D; st.st_blksize;
#endif
  ...
&#125;
libc_hidden_def (_IO_file_doallocate)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">In file: &#x2F;home&#x2F;starrysky&#x2F;IO&#x2F;glibc-2.23&#x2F;libio&#x2F;fileops.c
   1224 &#125;
   1225 libc_hidden_def (_IO_file_seek)
   1226 
   1227 int
   1228 _IO_file_stat (_IO_FILE *fp, void *st)
 ► 1229 &#123;
   1230   return __fxstat64 (_STAT_VER, fp-&gt;_fileno, (struct stat64 *) st);
   1231 &#125;
   1232 libc_hidden_def (_IO_file_stat)
   1233 
   1234 int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>完成后查看一下<code>st</code>结构体</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; p st
$3 &#x3D; &#123;
  st_dev &#x3D; 2053,
  st_ino &#x3D; 1112909,
  st_nlink &#x3D; 1,
  st_mode &#x3D; 33204,
  st_uid &#x3D; 1000,
  st_gid &#x3D; 1000,
  __pad0 &#x3D; 0,
  st_rdev &#x3D; 0,
  st_size &#x3D; 399,
  st_blksize &#x3D; 4096,
  st_blocks &#x3D; 8,
  st_atim &#x3D; &#123;
    tv_sec &#x3D; 1692447996,
    tv_nsec &#x3D; 127240661
  &#125;,
  st_mtim &#x3D; &#123;
    tv_sec &#x3D; 1692447276,
    tv_nsec &#x3D; 42244262
  &#125;,
  st_ctim &#x3D; &#123;
    tv_sec &#x3D; 1692447276,
    tv_nsec &#x3D; 46248351
  &#125;,
  __glibc_reserved &#x3D; &#123;0, 0, 0&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>size</code>取了<code>st_blksize</code>的值，接下来用这个大小创建堆来分配缓冲区并调用<code>_IO_setb</code>函数设置<code>_IO_list_all</code>中的<code>_IO_buf_base</code>和<code>_IO_buf_end</code>，至此完成初始化</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">_IO_file_doallocate (_IO_FILE *fp)
&#123;
  ...
  p &#x3D; malloc (size);
  if (__glibc_unlikely (p &#x3D;&#x3D; NULL))
    return EOF;
  _IO_setb (fp, p, p + size, 1);
  return 1;
&#125;
libc_hidden_def (_IO_file_doallocate)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; p *_IO_list_all
$4 &#x3D; &#123;
  file &#x3D; &#123;
    _flags &#x3D; -72539000,
    _IO_read_ptr &#x3D; 0x0,
    _IO_read_end &#x3D; 0x0,
    _IO_read_base &#x3D; 0x0,
    _IO_write_base &#x3D; 0x0,
    _IO_write_ptr &#x3D; 0x0,
    _IO_write_end &#x3D; 0x0,
    _IO_buf_base &#x3D; 0x405240 &quot;&quot;,
    _IO_buf_end &#x3D; 0x406240 &quot;&quot;,
    _IO_save_base &#x3D; 0x0,
    _IO_backup_base &#x3D; 0x0,
    _IO_save_end &#x3D; 0x0,
    _markers &#x3D; 0x0,
    _chain &#x3D; 0x7ffff7dd2540 &lt;_IO_2_1_stderr_&gt;,
    _fileno &#x3D; 3,
    _flags2 &#x3D; 0,
    _old_offset &#x3D; 0,
    _cur_column &#x3D; 0,
    _vtable_offset &#x3D; 0 &#39;\000&#39;,
    _shortbuf &#x3D; &quot;&quot;,
    _lock &#x3D; 0x4050f0,
    _offset &#x3D; -1,
    _codecvt &#x3D; 0x0,
    _wide_data &#x3D; 0x405100,
    _freeres_list &#x3D; 0x0,
    _freeres_buf &#x3D; 0x0,
    __pad5 &#x3D; 0,
    _mode &#x3D; 0,
    _unused2 &#x3D; &#39;\000&#39; &lt;repeats 19 times&gt;
  &#125;,
  vtable &#x3D; 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x230 (with flag bits: 0x231)

Allocated chunk | PREV_INUSE
Addr: 0x405230
Size: 0x1010 (with flag bits: 0x1011)

Top chunk | PREV_INUSE
Addr: 0x406240
Size: 0x1fdc0 (with flag bits: 0x1fdc1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接下来回到<code>_IO_file_xsgetn</code>函数，拷贝缓冲区中原本存在的数据。其中<code>_IO_read_end</code>指向输入缓冲区结束地址，<code>_IO_read_ptr</code>指向输入缓冲区开始地址，该过程即将开始到结束部分的内容复制到目标缓冲区</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">_IO_size_t
_IO_file_xsgetn (_IO_FILE *fp, void *data, _IO_size_t n)
&#123;
 ...
  while (want &gt; 0)
    &#123;
      have &#x3D; fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;
      if (want &lt;&#x3D; have)
	&#123;
	  memcpy (s, fp-&gt;_IO_read_ptr, want);
	  fp-&gt;_IO_read_ptr +&#x3D; want;
	  want &#x3D; 0;
	&#125;
      else
	&#123;
	  if (have &gt; 0)
	    &#123;
#ifdef _LIBC
	      s &#x3D; __mempcpy (s, fp-&gt;_IO_read_ptr, have);
#else
	      memcpy (s, fp-&gt;_IO_read_ptr, have);
	      s +&#x3D; have;
#endif
	      want -&#x3D; have;
	      fp-&gt;_IO_read_ptr +&#x3D; have;
	    &#125;

	  &#x2F;* Check for backup and repeat *&#x2F;
	  if (_IO_in_backup (fp))
	    &#123;
	      _IO_switch_to_main_get_area (fp);
	      continue;
	    &#125;
	...
    &#125;

  return n - want;
&#125;
libc_hidden_def (_IO_file_xsgetn)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>最后在目标缓冲区内容长度小于所需长度时调用<code>__underflow</code>函数真正读取文件</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">if (fp-&gt;_IO_buf_base
	      &amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))
	    &#123;
	      if (__underflow (fp) &#x3D;&#x3D; EOF)
		break;

	      continue;
	    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>进行一系列检查之后调用<code>_IO_UNDERFLOW</code>来读取文件，实际调用的是<code>_IO_new_file_underflow</code>函数</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">int
__underflow (_IO_FILE *fp)
&#123;
...
  return _IO_UNDERFLOW (fp);
&#125;
libc_hidden_def (__underflow)
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>_IO_new_file_underflow</code>函数中首先检查是否有读权限</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">if (fp-&gt;_flags &amp; _IO_NO_READS)
    &#123;
      fp-&gt;_flags |&#x3D; _IO_ERR_SEEN;
      __set_errno (EBADF);
      return EOF;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接着判断目标缓冲区是否初始化，若没初始化则调用<code>_IO_doallocbuf</code>初始化</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">if (fp-&gt;_IO_buf_base &#x3D;&#x3D; NULL)
    &#123;
      &#x2F;* Maybe we already have a push back pointer.  *&#x2F;
      if (fp-&gt;_IO_save_base !&#x3D; NULL)
	&#123;
	  free (fp-&gt;_IO_save_base);
	  fp-&gt;_flags &amp;&#x3D; ~_IO_IN_BACKUP;
	&#125;
      _IO_doallocbuf (fp);
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>初始化<code>file</code>结构体即<code>fp</code>为<code>_IO_buf_base</code></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">fp-&gt;_IO_read_base &#x3D; fp-&gt;_IO_read_ptr &#x3D; fp-&gt;_IO_buf_base;
 fp-&gt;_IO_read_end &#x3D; fp-&gt;_IO_buf_base;
 fp-&gt;_IO_write_base &#x3D; fp-&gt;_IO_write_ptr &#x3D; fp-&gt;_IO_write_end
   &#x3D; fp-&gt;_IO_buf_base;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; p *fp
$8 &#x3D; &#123;
  _flags &#x3D; -72539000,
  _IO_read_ptr &#x3D; 0x405240 &quot;&quot;,
  _IO_read_end &#x3D; 0x405240 &quot;&quot;,
  _IO_read_base &#x3D; 0x405240 &quot;&quot;,
  _IO_write_base &#x3D; 0x405240 &quot;&quot;,
  _IO_write_ptr &#x3D; 0x405240 &quot;&quot;,
  _IO_write_end &#x3D; 0x405240 &quot;&quot;,
  _IO_buf_base &#x3D; 0x405240 &quot;&quot;,
  _IO_buf_end &#x3D; 0x406240 &quot;&quot;,
  _IO_save_base &#x3D; 0x0,
  _IO_backup_base &#x3D; 0x0,
  _IO_save_end &#x3D; 0x0,
  _markers &#x3D; 0x0,
  _chain &#x3D; 0x7ffff7dd2540 &lt;_IO_2_1_stderr_&gt;,
  _fileno &#x3D; 3,
  _flags2 &#x3D; 0,
  _old_offset &#x3D; 0,
  _cur_column &#x3D; 0,
  _vtable_offset &#x3D; 0 &#39;\000&#39;,
  _shortbuf &#x3D; &quot;&quot;,
  _lock &#x3D; 0x4050f0,
  _offset &#x3D; -1,
  _codecvt &#x3D; 0x0,
  _wide_data &#x3D; 0x405100,
  _freeres_list &#x3D; 0x0,
  _freeres_buf &#x3D; 0x0,
  __pad5 &#x3D; 0,
  _mode &#x3D; -1,
  _unused2 &#x3D; &#39;\000&#39; &lt;repeats 19 times&gt;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> 调用<code>_IO_SYSREAD</code>读取文件内容，实际调用的是<code>_IO_file_read</code>函数</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">count &#x3D; _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,
       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">In file: &#x2F;home&#x2F;starrysky&#x2F;IO&#x2F;glibc-2.23&#x2F;libio&#x2F;fileops.c
   1211 _IO_ssize_t
   1212 _IO_file_read (_IO_FILE *fp, void *buf, _IO_ssize_t size)
   1213 &#123;
   1214   return (__builtin_expect (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL, 0)
   1215           ? read_not_cancel (fp-&gt;_fileno, buf, size)
 ► 1216           : read (fp-&gt;_fileno, buf, size));
   1217 &#125;
   1218 libc_hidden_def (_IO_file_read)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>函数中调用<code>read</code>函数读取到输入缓冲区中，读入大小为输入缓冲区的大小<code>fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base</code></p>
<p>设置缓冲区结束地址</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">fp-&gt;_IO_read_end +&#x3D; count;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>查看一下<code>_IO_list_all</code>，可以看到<code>_IO_read_end</code>已经设置为缓冲区结束位置</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; p *_IO_list_all
$9 &#x3D; &#123;
  file &#x3D; &#123;
    _flags &#x3D; -72539000,
    _IO_read_ptr &#x3D; 0x405240 &#39;a&#39; &lt;repeats 200 times&gt;...,
    _IO_read_end &#x3D; 0x4053cf &quot;&quot;,
    _IO_read_base &#x3D; 0x405240 &#39;a&#39; &lt;repeats 200 times&gt;...,
    _IO_write_base &#x3D; 0x405240 &#39;a&#39; &lt;repeats 200 times&gt;...,
    _IO_write_ptr &#x3D; 0x405240 &#39;a&#39; &lt;repeats 200 times&gt;...,
    _IO_write_end &#x3D; 0x405240 &#39;a&#39; &lt;repeats 200 times&gt;...,
    _IO_buf_base &#x3D; 0x405240 &#39;a&#39; &lt;repeats 200 times&gt;...,
    _IO_buf_end &#x3D; 0x406240 &quot;&quot;,
    _IO_save_base &#x3D; 0x0,
    _IO_backup_base &#x3D; 0x0,
    _IO_save_end &#x3D; 0x0,
    _markers &#x3D; 0x0,
    _chain &#x3D; 0x7ffff7dd2540 &lt;_IO_2_1_stderr_&gt;,
    _fileno &#x3D; 3,
    _flags2 &#x3D; 0,
    _old_offset &#x3D; 0,
    _cur_column &#x3D; 0,
    _vtable_offset &#x3D; 0 &#39;\000&#39;,
    _shortbuf &#x3D; &quot;&quot;,
    _lock &#x3D; 0x4050f0,
    _offset &#x3D; -1,
    _codecvt &#x3D; 0x0,
    _wide_data &#x3D; 0x405100,
    _freeres_list &#x3D; 0x0,
    _freeres_buf &#x3D; 0x0,
    __pad5 &#x3D; 0,
    _mode &#x3D; -1,
    _unused2 &#x3D; &#39;\000&#39; &lt;repeats 19 times&gt;
  &#125;,
  vtable &#x3D; 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接下来回到<code>_IO_file_xsgetn</code>函数的循环中，再来一次循环将输入缓冲区内容复制给目标缓冲区，<code>fread</code>函数结束</p>
<p>在此过程中调用的<code>vtable</code>函数</p>
<ul>
<li><code>_IO_sgetn</code>函数调用了<code>vtable</code>的<code>_IO_file_xsgetn</code></li>
<li><code>_IO_doallocbuf</code>函数调用了<code>vtable</code>的<code>_IO_file_doallocate</code>以初始化输入缓冲区</li>
<li><code>vtable</code>中的<code>_IO_file_doallocate</code>调用了<code>vtable</code>中的<code>__GI__IO_file_stat</code>以获取文件信息</li>
<li><code>__underflow</code>函数调用了<code>vtable</code>中的<code>_IO_new_file_underflow</code>实现文件数据读取</li>
<li><code>vtable</code>中的<code>_IO_new_file_underflow</code>调用了<code>vtable</code>中的<code>__GI__IO_file_read</code>最终去执行系统调用<code>read</code></li>
</ul>
<p>其他输入函数如<code>scanf</code>、<code>gets</code>等最终实现读取的函数也是<code>_IO_new_file_underflow</code>，因此利用<code>IO</code>攻击读取函数主要是攻击<code>_IO_new_file_underflow</code>，需要注意的是对标志位的判断的绕过</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">if (fp-&gt;_flags &amp; _IO_NO_READS)
  &#123;
    fp-&gt;_flags |&#x3D; _IO_ERR_SEEN;
    __set_errno (EBADF);
    return EOF;
  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;

int main()&#123;
    char *data&#x3D;malloc(0x1000);
    FILE*fp&#x3D;fopen(&quot;test&quot;,&quot;wb&quot;);
    
    fwrite(data,1,0x30,fp);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>看一下<code>vtable</code>里有哪些函数</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; p *_IO_list_all-&gt;vtable
$1 &#x3D; &#123;
  __dummy &#x3D; 0,
  __dummy2 &#x3D; 0,
  __finish &#x3D; 0x7ffff7a878f0 &lt;_IO_new_file_finish&gt;,
  __overflow &#x3D; 0x7ffff7a88660 &lt;_IO_new_file_overflow&gt;,
  __underflow &#x3D; 0x7ffff7a883d0 &lt;_IO_new_file_underflow&gt;,
  __uflow &#x3D; 0x7ffff7a89530 &lt;__GI__IO_default_uflow&gt;,
  __pbackfail &#x3D; 0x7ffff7a8a8b0 &lt;__GI__IO_default_pbackfail&gt;,
  __xsputn &#x3D; 0x7ffff7a87110 &lt;_IO_new_file_xsputn&gt;,
  __xsgetn &#x3D; 0x7ffff7a86df0 &lt;__GI__IO_file_xsgetn&gt;,
  __seekoff &#x3D; 0x7ffff7a863f0 &lt;_IO_new_file_seekoff&gt;,
  __seekpos &#x3D; 0x7ffff7a89930 &lt;_IO_default_seekpos&gt;,
  __setbuf &#x3D; 0x7ffff7a86360 &lt;_IO_new_file_setbuf&gt;,
  __sync &#x3D; 0x7ffff7a862a0 &lt;_IO_new_file_sync&gt;,
  __doallocate &#x3D; 0x7ffff7a7b130 &lt;__GI__IO_file_doallocate&gt;,
  __read &#x3D; 0x7ffff7a870d0 &lt;__GI__IO_file_read&gt;,
  __write &#x3D; 0x7ffff7a86aa0 &lt;_IO_new_file_write&gt;,
  __seek &#x3D; 0x7ffff7a868a0 &lt;__GI__IO_file_seek&gt;,
  __close &#x3D; 0x7ffff7a86270 &lt;__GI__IO_file_close&gt;,
  __stat &#x3D; 0x7ffff7a86a90 &lt;__GI__IO_file_stat&gt;,
  __showmanyc &#x3D; 0x7ffff7a8aa20 &lt;_IO_default_showmanyc&gt;,
  __imbue &#x3D; 0x7ffff7a8aa30 &lt;_IO_default_imbue&gt;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>跟进<code>fwrite</code>函数，实际调用了<code>_IO_fwrite</code></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">In file: &#x2F;home&#x2F;starrysky&#x2F;IO&#x2F;glibc-2.23&#x2F;libio&#x2F;iofwrite.c
   26 
   27 #include &quot;libioP.h&quot;
   28 
   29 _IO_size_t
   30 _IO_fwrite (const void *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)
 ► 31 &#123;
   32   _IO_size_t request &#x3D; size * count;
   33   _IO_size_t written &#x3D; 0;
   34   CHECK_FILE (fp, 0);
   35   if (request &#x3D;&#x3D; 0)
   36     return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>源码如下：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">_IO_fwrite (const void *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)
&#123;
  ...
  if (_IO_vtable_offset (fp) !&#x3D; 0 || _IO_fwide (fp, -1) &#x3D;&#x3D; -1)
    written &#x3D; _IO_sputn (fp, (const char *) buf, request);
  ...
  if (written &#x3D;&#x3D; request || written &#x3D;&#x3D; EOF)
    return count;
  else
    return written &#x2F; size;
&#125;
libc_hidden_def (_IO_fwrite)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>主要就是调用了<code>_IO_sputn</code>函数，跟进之后实际调用的是<code>_IO_new_file_xsputn</code>函数，即<code>vtable</code>中的<code>__xsputn</code></p>
<p>首先计算输出缓冲区剩余空间， 并将所需输出的数据复制到输出缓冲区</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">_IO_size_t
_IO_new_file_xsputn (_IO_FILE *f, const void *data, _IO_size_t n)
&#123;
  ...
  if ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))
    &#123;
      count &#x3D; f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;
      ...
    &#125;
  else if (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)
    count &#x3D; f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; &#x2F;* Space available. *&#x2F;

  &#x2F;* Then fill the buffer. *&#x2F;
  if (count &gt; 0)
    &#123;
      if (count &gt; to_do)
	count &#x3D; to_do;
#ifdef _LIBC
      f-&gt;_IO_write_ptr &#x3D; __mempcpy (f-&gt;_IO_write_ptr, s, count);
#else
      memcpy (f-&gt;_IO_write_ptr, s, count);
      f-&gt;_IO_write_ptr +&#x3D; count;
#endif
      s +&#x3D; count;
      to_do -&#x3D; count;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果没能完全复制过去，那么说明输出缓冲区未建立或已满，调用<code>_IO_OVERFLOW</code>函数来建立或刷新输出缓冲区，刷新<code>_IO_list_all</code></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">In file: &#x2F;home&#x2F;starrysky&#x2F;IO&#x2F;glibc-2.23&#x2F;libio&#x2F;fileops.c
   1326     &#125;
   1327   if (to_do + must_flush &gt; 0)
   1328     &#123;
   1329       _IO_size_t block_size, do_write;
   1330       &#x2F;* Next flush the (full) buffer. *&#x2F;
 ► 1331       if (_IO_OVERFLOW (f, EOF) &#x3D;&#x3D; EOF)
   1332         &#x2F;* If nothing else has to be written we must not signal the
   1333            caller that everything has been written.  *&#x2F;
   1334         return to_do &#x3D;&#x3D; 0 ? EOF : n - to_do;
   1335 
   1336       &#x2F;* Try to maintain alignment: write a whole number of blocks.  *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>跟进这个函数，实际调用的函数是<code>_IO_new_file_overflow</code></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">In file: &#x2F;home&#x2F;starrysky&#x2F;IO&#x2F;glibc-2.23&#x2F;libio&#x2F;fileops.c
   803 
   804 
   805 int
   806 _IO_new_file_overflow (_IO_FILE *f, int ch)
   807 &#123;
 ► 808   if (f-&gt;_flags &amp; _IO_NO_WRITES) &#x2F;* SET ERROR *&#x2F;
   809     &#123;
   810       f-&gt;_flags |&#x3D; _IO_ERR_SEEN;
   811       __set_errno (EBADF);
   812       return EOF;
   813     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>该函数首先判断了是否有可写权限</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">if (f-&gt;_flags &amp; _IO_NO_WRITES) &#x2F;* SET ERROR *&#x2F;
    &#123;
      f-&gt;_flags |&#x3D; _IO_ERR_SEEN;
      __set_errno (EBADF);
      return EOF;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>若输出缓冲区未创建则创建输出缓冲区，调用<code>_IO_doallocbuf</code>函数分配输入输出缓冲区并将指针<code>_IO_buf_base</code>和<code>_IO_buf_end</code>赋值，调用<code>_IO_setg</code>宏将输入相关的缓冲区指针赋值为<code>_IO_buf_base</code>指针</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">if (f-&gt;_IO_write_base &#x3D;&#x3D; NULL)
	&#123;
	  _IO_doallocbuf (f);
	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);
	&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _IO_setg(fp, eb, g, eg)  ((fp)-&gt;_IO_read_base &#x3D; (eb),\
  (fp)-&gt;_IO_read_ptr &#x3D; (g), (fp)-&gt;_IO_read_end &#x3D; (eg))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>接着将<code>f-&gt;_IO_write_base</code>、<code>f-&gt;_IO_write_ptr</code>设置成<code>f-&gt;_IO_read_ptr</code>指针；将<code>f-&gt;_IO_write_end</code>赋值为<code>f-&gt;_IO_buf_end</code></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">   if (__glibc_unlikely (_IO_in_backup (f)))
&#123;
  size_t nbackup &#x3D; f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;
  _IO_free_backup_area (f);
  f-&gt;_IO_read_base -&#x3D; MIN (nbackup,
			   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);
  f-&gt;_IO_read_ptr &#x3D; f-&gt;_IO_read_base;
&#125;

     if (f-&gt;_IO_read_ptr &#x3D;&#x3D; f-&gt;_IO_buf_end)
f-&gt;_IO_read_end &#x3D; f-&gt;_IO_read_ptr &#x3D; f-&gt;_IO_buf_base;
     f-&gt;_IO_write_ptr &#x3D; f-&gt;_IO_read_ptr;
     f-&gt;_IO_write_base &#x3D; f-&gt;_IO_write_ptr;
     f-&gt;_IO_write_end &#x3D; f-&gt;_IO_buf_end;
     f-&gt;_IO_read_base &#x3D; f-&gt;_IO_read_ptr &#x3D; f-&gt;_IO_read_end;

     f-&gt;_flags |&#x3D; _IO_CURRENTLY_PUTTING;
     if (f-&gt;_mode &lt;&#x3D; 0 &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))
f-&gt;_IO_write_end &#x3D; f-&gt;_IO_write_ptr;
   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>指针执行完看一下<code>_IO_list_all</code>，<code>_IO_buf_base</code>和<code>_IO_buf_end</code>被赋值，且输入缓冲区相关指针被赋值为<code>_IO_buf_base</code></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; p *_IO_list_all
$3 &#x3D; &#123;
  file &#x3D; &#123;
    _flags &#x3D; -72536956,
    _IO_read_ptr &#x3D; 0x406250 &quot;&quot;,
    _IO_read_end &#x3D; 0x406250 &quot;&quot;,
    _IO_read_base &#x3D; 0x406250 &quot;&quot;,
    _IO_write_base &#x3D; 0x406250 &quot;&quot;,
    _IO_write_ptr &#x3D; 0x406250 &quot;&quot;,
    _IO_write_end &#x3D; 0x407250 &quot;&quot;,
    _IO_buf_base &#x3D; 0x406250 &quot;&quot;,
    _IO_buf_end &#x3D; 0x407250 &quot;&quot;,
    _IO_save_base &#x3D; 0x0,
    _IO_backup_base &#x3D; 0x0,
    _IO_save_end &#x3D; 0x0,
    _markers &#x3D; 0x0,
    _chain &#x3D; 0x7ffff7dd2540 &lt;_IO_2_1_stderr_&gt;,
    _fileno &#x3D; 3,
    _flags2 &#x3D; 0,
    _old_offset &#x3D; 0,
    _cur_column &#x3D; 0,
    _vtable_offset &#x3D; 0 &#39;\000&#39;,
    _shortbuf &#x3D; &quot;&quot;,
    _lock &#x3D; 0x406100,
    _offset &#x3D; -1,
    _codecvt &#x3D; 0x0,
    _wide_data &#x3D; 0x406110,
    _freeres_list &#x3D; 0x0,
    _freeres_buf &#x3D; 0x0,
    __pad5 &#x3D; 0,
    _mode &#x3D; -1,
    _unused2 &#x3D; &#39;\000&#39; &lt;repeats 19 times&gt;
  &#125;,
  vtable &#x3D; 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接下来调用<code>_IO_new_do_write</code>函数来执行<code>write</code>将<code>write_ptr</code>到<code>write_end</code>之间的输入读入缓冲区</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">if (ch &#x3D;&#x3D; EOF)
    return _IO_do_write (f, f-&gt;_IO_write_base,
			 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">int
_IO_new_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do)
&#123;
  return (to_do &#x3D;&#x3D; 0
	  || (_IO_size_t) new_do_write (fp, data, to_do) &#x3D;&#x3D; to_do) ? 0 : EOF;
&#125;
libc_hidden_ver (_IO_new_do_write, _IO_do_write)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>函数中又调用了<code>_IO_new_do_write</code>函数</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">static
_IO_size_t
new_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do)
&#123;
  _IO_size_t count;
  ...
  count &#x3D; _IO_SYSWRITE (fp, data, to_do);
  if (fp-&gt;_cur_column &amp;&amp; count)
    fp-&gt;_cur_column &#x3D; _IO_adjust_column (fp-&gt;_cur_column - 1, data, count) + 1;
  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);
  fp-&gt;_IO_write_base &#x3D; fp-&gt;_IO_write_ptr &#x3D; fp-&gt;_IO_buf_base;
  fp-&gt;_IO_write_end &#x3D; (fp-&gt;_mode &lt;&#x3D; 0
		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))
		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);
  return count;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此时来到了最终实现<code>write</code>的地方，即<code>_IO_SYSWRITE</code>函数（<code>vtable</code>中的&#96;&#96;__write<code>函数），实际调用的是</code>_IO_new_file_write<code>函数，按照指定长度调用</code>write&#96;函数写入内容</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">In file: &#x2F;home&#x2F;starrysky&#x2F;IO&#x2F;glibc-2.23&#x2F;libio&#x2F;fileops.c
   1253 
   1254 _IO_ssize_t
   1255 _IO_new_file_write (_IO_FILE *f, const void *data, _IO_ssize_t n)
   1256 &#123;
   1257   _IO_ssize_t to_do &#x3D; n;
 ► 1258   while (to_do &gt; 0)
   1259     &#123;
   1260       _IO_ssize_t count &#x3D; (__builtin_expect (f-&gt;_flags2
   1261                                              &amp; _IO_FLAGS2_NOTCANCEL, 0)
   1262                            ? write_not_cancel (f-&gt;_fileno, data, to_do)
   1263                            : write (f-&gt;_fileno, data, to_do));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">_IO_ssize_t
_IO_new_file_write (_IO_FILE *f, const void *data, _IO_ssize_t n)
&#123;
  _IO_ssize_t to_do &#x3D; n;
  while (to_do &gt; 0)
    &#123;
      _IO_ssize_t count &#x3D; (__builtin_expect (f-&gt;_flags2
					     &amp; _IO_FLAGS2_NOTCANCEL, 0)
			   ? write_not_cancel (f-&gt;_fileno, data, to_do)
			   : write (f-&gt;_fileno, data, to_do));
      if (count &lt; 0)
	&#123;
	  f-&gt;_flags |&#x3D; _IO_ERR_SEEN;
	  break;
	&#125;
      to_do -&#x3D; count;
      data &#x3D; (void *) ((char *) data + count);
    &#125;
  n -&#x3D; to_do;
  if (f-&gt;_offset &gt;&#x3D; 0)
    f-&gt;_offset +&#x3D; n;
  return n;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">  0x7ffff7a86ac8 &lt;_IO_file_write+40&gt;     test   byte ptr [r14 + 0x74], 2
  0x7ffff7a86acd &lt;_IO_file_write+45&gt;     je     _IO_file_write+128                &lt;_IO_file_write+128&gt;
   ↓
  0x7ffff7a86b20 &lt;_IO_file_write+128&gt;    mov    edi, dword ptr [r14 + 0x70]
  0x7ffff7a86b24 &lt;_IO_file_write+132&gt;    mov    rdx, rbx
  0x7ffff7a86b27 &lt;_IO_file_write+135&gt;    mov    rsi, rbp
► 0x7ffff7a86b2a &lt;_IO_file_write+138&gt;    call   write                &lt;write&gt;
       fd: 0x3 (&#x2F;home&#x2F;starrysky&#x2F;IO&#x2F;test)
       buf: 0x406250 ◂— 0x0
       n: 0x30

  0x7ffff7a86b2f &lt;_IO_file_write+143&gt;    test   rax, rax
  0x7ffff7a86b32 &lt;_IO_file_write+146&gt;    js     _IO_file_write+82                &lt;_IO_file_write+82&gt;

  0x7ffff7a86b34 &lt;_IO_file_write+148&gt;    sub    rbx, rax
  0x7ffff7a86b37 &lt;_IO_file_write+151&gt;    add    rbp, rax
  0x7ffff7a86b3a &lt;_IO_file_write+154&gt;    test   rbx, rbx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>调用结束后回到<code>_new_do_write</code>函数，设置各种指针刷新输出缓冲区</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">if (fp-&gt;_cur_column &amp;&amp; count)
   fp-&gt;_cur_column &#x3D; _IO_adjust_column (fp-&gt;_cur_column - 1, data, count) + 1;
 _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);
 fp-&gt;_IO_write_base &#x3D; fp-&gt;_IO_write_ptr &#x3D; fp-&gt;_IO_buf_base;
 fp-&gt;_IO_write_end &#x3D; (fp-&gt;_mode &lt;&#x3D; 0
	       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))
	       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>查看一下<code>_IO_list_all</code>结构体，此时输出缓冲区中没有内容</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; p *_IO_list_all
$5 &#x3D; &#123;
  file &#x3D; &#123;
    _flags &#x3D; -72536956,
    _IO_read_ptr &#x3D; 0x406250 &quot;&quot;,
    _IO_read_end &#x3D; 0x406250 &quot;&quot;,
    _IO_read_base &#x3D; 0x406250 &quot;&quot;,
    _IO_write_base &#x3D; 0x406250 &quot;&quot;,
    _IO_write_ptr &#x3D; 0x406250 &quot;&quot;,
    _IO_write_end &#x3D; 0x407250 &quot;&quot;,
    _IO_buf_base &#x3D; 0x406250 &quot;&quot;,
    _IO_buf_end &#x3D; 0x407250 &quot;&quot;,
    _IO_save_base &#x3D; 0x0,
    _IO_backup_base &#x3D; 0x0,
    _IO_save_end &#x3D; 0x0,
    _markers &#x3D; 0x0,
    _chain &#x3D; 0x7ffff7dd2540 &lt;_IO_2_1_stderr_&gt;,
    _fileno &#x3D; 3,
    _flags2 &#x3D; 0,
    _old_offset &#x3D; 0,
    _cur_column &#x3D; 0,
    _vtable_offset &#x3D; 0 &#39;\000&#39;,
    _shortbuf &#x3D; &quot;&quot;,
    _lock &#x3D; 0x406100,
    _offset &#x3D; -1,
    _codecvt &#x3D; 0x0,
    _wide_data &#x3D; 0x406110,
    _freeres_list &#x3D; 0x0,
    _freeres_buf &#x3D; 0x0,
    __pad5 &#x3D; 0,
    _mode &#x3D; -1,
    _unused2 &#x3D; &#39;\000&#39; &lt;repeats 19 times&gt;
  &#125;,
  vtable &#x3D; 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接下来回到<code>_IO_file_xsputn</code>函数，判断剩余输出数据是否大于输入缓冲区<code>buf</code>大小，若大于则不使用输出缓冲区直接调用<code>new_do_write</code>输出并刷新指针</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">     block_size &#x3D; f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;
     do_write &#x3D; to_do - (block_size &gt;&#x3D; 128 ? to_do % block_size : 0);

     if (do_write)
&#123;
  count &#x3D; new_do_write (f, s, do_write);
  to_do -&#x3D; count;
  if (count &lt; do_write)
    return n - to_do;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出完大块的内容剩余的小块的内容继续调用<code>_IO_default_xsputn</code>函数输出到输出缓冲区，在长度不同的时候使用了不同的输出方式，即大于20使用<code>memcpy</code>，小于20使用for循环</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">to_do -&#x3D; _IO_default_xsputn (f, s+do_write, to_do);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">_IO_size_t
_IO_default_xsputn (_IO_FILE *f, const void *data, _IO_size_t n)
&#123;
  const char *s &#x3D; (char *) data;
  _IO_size_t more &#x3D; n;
  if (more &lt;&#x3D; 0)
    return 0;
  for (;;)
    &#123;
      &#x2F;* Space available. *&#x2F;
      if (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)
	&#123;
	  _IO_size_t count &#x3D; f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;
	  if (count &gt; more)
	    count &#x3D; more;
	  if (count &gt; 20)
	    &#123;
#ifdef _LIBC
	      f-&gt;_IO_write_ptr &#x3D; __mempcpy (f-&gt;_IO_write_ptr, s, count);
#else
	      memcpy (f-&gt;_IO_write_ptr, s, count);
	      f-&gt;_IO_write_ptr +&#x3D; count;
#endif
	      s +&#x3D; count;
	    &#125;
	  else if (count)
	    &#123;
	      char *p &#x3D; f-&gt;_IO_write_ptr;
	      _IO_ssize_t i;
	      for (i &#x3D; count; --i &gt;&#x3D; 0; )
		*p++ &#x3D; *s++;
	      f-&gt;_IO_write_ptr &#x3D; p;
	    &#125;
	  more -&#x3D; count;
	&#125;
      if (more &#x3D;&#x3D; 0 || _IO_OVERFLOW (f, (unsigned char) *s++) &#x3D;&#x3D; EOF)
	break;
      more--;
    &#125;
  return n - more;
&#125;
libc_hidden_def (_IO_default_xsputn)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>最后结构体如下，输出缓冲区的大小刚好为<code>0x30</code></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; p *_IO_list_all
$6 &#x3D; &#123;
  file &#x3D; &#123;
    _flags &#x3D; -72536956,
    _IO_read_ptr &#x3D; 0x406250 &quot;&quot;,
    _IO_read_end &#x3D; 0x406250 &quot;&quot;,
    _IO_read_base &#x3D; 0x406250 &quot;&quot;,
    _IO_write_base &#x3D; 0x406250 &quot;&quot;,
    _IO_write_ptr &#x3D; 0x406280 &quot;&quot;,
    _IO_write_end &#x3D; 0x407250 &quot;&quot;,
    _IO_buf_base &#x3D; 0x406250 &quot;&quot;,
    _IO_buf_end &#x3D; 0x407250 &quot;&quot;,
    _IO_save_base &#x3D; 0x0,
    _IO_backup_base &#x3D; 0x0,
    _IO_save_end &#x3D; 0x0,
    _markers &#x3D; 0x0,
    _chain &#x3D; 0x7ffff7dd2540 &lt;_IO_2_1_stderr_&gt;,
    _fileno &#x3D; 3,
    _flags2 &#x3D; 0,
    _old_offset &#x3D; 0,
    _cur_column &#x3D; 0,
    _vtable_offset &#x3D; 0 &#39;\000&#39;,
    _shortbuf &#x3D; &quot;&quot;,
    _lock &#x3D; 0x406100,
    _offset &#x3D; -1,
    _codecvt &#x3D; 0x0,
    _wide_data &#x3D; 0x406110,
    _freeres_list &#x3D; 0x0,
    _freeres_buf &#x3D; 0x0,
    __pad5 &#x3D; 0,
    _mode &#x3D; -1,
    _unused2 &#x3D; &#39;\000&#39; &lt;repeats 19 times&gt;
  &#125;,
  vtable &#x3D; 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其他输出函数最终实现部分调用的也是<code>_IO_new_file_overflow</code>函数，所以利用输出函数就是利用<code>_IO_new_file_overflow</code>函数，需要注意函数对标志位的判断</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">if (f-&gt;_flags &amp; _IO_NO_WRITES) &#x2F;* SET ERROR *&#x2F;
  &#123;
    f-&gt;_flags |&#x3D; _IO_ERR_SEEN;
    __set_errno (EBADF);
    return EOF;
  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>调用<code>vtable</code>中的函数:</p>
<ul>
<li><code>_IO_fwrite</code>函数调用了vtable的<code>_IO_new_file_xsputn</code>。</li>
<li><code>_IO_new_file_xsputn</code>函数调用了vtable中的<code>_IO_new_file_overflow</code>实现缓冲区的建立以及刷新缓冲区。</li>
<li>vtable中的<code>_IO_new_file_overflow</code>函数调用了vtable的<code>_IO_file_doallocate</code>以初始化输入缓冲区。</li>
<li>vtable中的<code>_IO_file_doallocate</code>调用了vtable中的<code>__GI__IO_file_stat</code>以获取文件信息。</li>
<li><code>new_do_write</code>中的<code>_IO_SYSWRITE</code>调用了vtable<code>_IO_new_file_write</code>最终去执行系统调用write。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p><strong><code>fopen</code></strong></p>
<ul>
<li><p><code>_IO_new_fopen</code></p>
<ul>
<li><p><code>__fopen_internal</code></p>
<ul>
<li><p><code>_IO_no_init</code>：初始化<code>fp</code>结构体</p>
</li>
<li><p><code>_IO_file_init	-&gt;	_IO_new_file_init</code>：将<code>fp</code>结构体连接到<code>_IO_list_all</code>结构体中</p>
<ul>
<li><code>_IO_link_in</code>：将文件指针链接到全局文件链表中</li>
</ul>
</li>
<li><p><code>_IO_file_fopen	-&gt;	_IO_new_file_fopen</code>：判断文件是否已打开以及一些标志位</p>
<ul>
<li><code>_IO_file_open</code>：调用<code>open</code>之后设置<code>fileno</code>标志位<ul>
<li><code>open</code></li>
<li><code>_IO_link_in</code>：使结构体进入<code>_IO_list_all</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>fread</code></strong></p>
<ul>
<li><p><code>_IO_fread</code></p>
<ul>
<li><p><code>_IO_sgetn</code></p>
<ul>
<li><p><code>_IO_XSGETN	-&gt;	_IO_file_xsgetn</code> ：从文件流中读取指定数量的字节存储到目标缓冲区</p>
<ul>
<li><code>_IO_doallocbuf </code> ：分配新的缓冲区并设置<code>_IO_buf_base</code>和<code>_IO_buf_end</code><ul>
<li><code>_IO_DOALLOCATE	-&gt;	_IO_file_doallocate</code>：分配缓冲区<ul>
<li><code>_IO_SYSSTAT</code> ：获取文件状态，即<code>st</code>结构体</li>
</ul>
</li>
<li><code>_IO_setb</code>：设置<code>_IO_list_all</code>中的<code>_IO_buf_base</code>和<code>_IO_buf_end</code></li>
</ul>
</li>
<li>将<code>_IO_read_ptr</code>到<code>_IO_read_end</code>之间输入缓冲区原有的数据输入目标缓冲区</li>
<li><code>__underflow</code><ul>
<li><code>**_IO_UNDERFLOW	-&gt;	_IO_new_file_underflow**</code>：首先检查是否有读权限<ul>
<li><code>_IO_doallocbuf</code>：目标缓冲区未初始化时调用来初始化各指针为<code>_IO_buf_base</code></li>
<li><code>_IO_SYSREAD	-&gt;	_IO_file_read</code><ul>
<li><code>read</code>:向输入缓冲区读取大小为<code>fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base</code>的内容</li>
</ul>
</li>
<li>设置输入缓冲区结束地址</li>
</ul>
</li>
</ul>
</li>
<li>再次循环将输入缓冲区复制到目标缓冲区</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>fwrite</code></strong></p>
<ul>
<li><p><code>_IO_fwrite</code></p>
<ul>
<li><p><code>_IO_sputn	-&gt;	_IO_new_file_xsputn</code></p>
<ul>
<li><p>计算输出缓冲区剩余空间，将需要输出数据复制到输出缓冲区</p>
</li>
<li><p><code>**_IO_OVERFLOW	-&gt;	_IO_new_file_overflow**</code>：缓冲区未建立或已满时建立或刷新输出缓冲区，会判断标志位，即是否有可写权限</p>
</li>
<li><p><code>_IO_doallocbuf</code>：若输出缓冲区未创建则调用该函数创建并给<code>_IO_buf_base</code>和<code>_IO_buf_end</code>指针赋值</p>
</li>
<li><p><code>_IO_setg</code>：将输入相关的缓冲区指针赋值为<code>_IO_buf_base</code></p>
<ul>
<li>&#96;&#96;&#96;C<br>#define _IO_setg(fp, eb, g, eg)  ((fp)-&gt;_IO_read_base &#x3D; (eb),<br>  (fp)-&gt;_IO_read_ptr &#x3D; (g), (fp)-&gt;_IO_read_end &#x3D; (eg))<pre class="line-numbers language-none"><code class="language-none">
        - 将&#96;f-&gt;_IO_write_base&#96;、&#96;f-&gt;_IO_write_ptr&#96;设置成&#96;f-&gt;_IO_read_ptr&#96;指针；将&#96;f-&gt;_IO_write_end&#96;赋值为&#96;f-&gt;_IO_buf_end&#96;

      - &#96;_IO_do_write	-&gt;	_IO_new_do_write&#96;

        - &#96;new_do_write&#96;
          - &#96;_IO_SYSWRITE	-&gt;	_IO_new_file_write&#96;
            - &#96;write&#96;
          - 设置各种指针刷新输出缓冲区

      - 根据剩余输出数据大小选择&#96;memcpy&#96;或&#96;for&#96;循环输出并刷新指针

## 劫持vtable原理

&#96;_IO_FILE_plus&#96;结构体

&#96;&#96;&#96;C
struct _IO_FILE_plus
&#123;
  _IO_FILE file;
  const struct _IO_jump_t *vtable;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>其中<code>vtable</code>结构体中存着系统调用最终调用的函数，因此劫持<code>vtable</code>函数之后就可以劫持程序流，需要注意的是在<code>2.23</code>版本以上就会检查<code>vtable</code></p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a target="_blank" rel="noopener" href="https://www.z1r0.top/2021/10/09/IO-FILE">https://www.z1r0.top/2021/10/09/IO-FILE</a></p>

                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/IO/">
                                    <span class="chip bg-color">IO</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/09/24/how2heap/how2heap-chi-xu-geng-xin-ing/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/Steel%20Gray.jpg" class="responsive-img" alt="how2heap">
                        
                        <span class="card-title">how2heap</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            基于堆的漏洞利用
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-09-24
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/heap/" class="post-category">
                                    heap
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/pwn/">
                        <span class="chip bg-color">pwn</span>
                    </a>
                    
                    <a href="/tags/heap/">
                        <span class="chip bg-color">heap</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/08/12/2023-googlectf-ubf/2023-googlectf-ubf/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/Steel%20Gray.jpg" class="responsive-img" alt="2023-googlectf-ubf复现">
                        
                        <span class="card-title">2023-googlectf-ubf复现</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            2023googlectf_ubf复现
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-08-12
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/pwn/" class="post-category">
                                    pwn
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/ubf/">
                        <span class="chip bg-color">ubf</span>
                    </a>
                    
                    <a href="/tags/oob/">
                        <span class="chip bg-color">oob</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2024</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">StarrySky</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">109.4k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/starrysky1004" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:starrysky20041005@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2726736810" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2726736810" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>









    <a href="https://space.bilibili.com/85923475" class="tooltipped" target="_blank" data-tooltip="关注我的bilibili" data-position="top" data-delay="50">
        <i class="fas fa-video"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":260,"height":300},"mobile":{"show":true},"log":false});</script></body>

</html>
